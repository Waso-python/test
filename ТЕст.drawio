<mxfile host="app.diagrams.net" agent="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36 SberBrowser/31.0.0.0" version="28.2.5">
  <diagram name="Страница — 1" id="YzAyhXTebkGU_6SpY-bU">
    <mxGraphModel dx="1372" dy="742" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="3300" pageHeight="4681" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <UserObject label="# idp_client.py&#xa;import os&#xa;import uuid&#xa;import time&#xa;import json&#xa;import requests&#xa;from typing import Optional, Tuple, Dict, Any, List&#xa;from requests.adapters import HTTPAdapter, Retry&#xa;&#xa;&#xa;from core.logging.logger_utils import log&#xa;from scenarios.user.user_model import User&#xa;&#xa;&#xa;&#xa;&#xa;# -----------------------------&#xa;# ВСПОМОГАТЕЛЬНЫЕ НАСТРОЙКИ&#xa;# -----------------------------&#xa;DEFAULT_API_BASE = os.getenv(&quot;IDP_GATEWAY_BASE&quot;, &quot;http://localhost:8000&quot;)  # где крутится твой FastAPI&#xa;ENDPOINT_PATH = os.getenv(&quot;IDP_SEARCH_PATH&quot;, &quot;/idp_search&quot;)&#xa;&#xa;&#xa;# Если ваш Depends(common_headers) ожидает определённые заголовки — добавь их в ENV и сюда&#xa;DEFAULT_HEADERS: Dict[str, str] = {&#xa;    &quot;accept&quot;: &quot;application/json&quot;,&#xa;    &quot;Content-Type&quot;: &quot;application/json&quot;,&#xa;    # Примеры корпоративных заголовков — подставь нужные, если требуется:&#xa;    # &quot;X-Request-Source&quot;: os.getenv(&quot;X_REQUEST_SOURCE&quot;, &quot;your-service&quot;),&#xa;    # &quot;X-Auth-Token&quot;: os.getenv(&quot;X_AUTH_TOKEN&quot;, &quot;&quot;),&#xa;}&#xa;&#xa;&#xa;REQUEST_TIMEOUT = float(os.getenv(&quot;IDP_CLIENT_TIMEOUT&quot;, &quot;30&quot;))  # сек.&#xa;RETRY_TOTAL = int(os.getenv(&quot;IDP_CLIENT_RETRY_TOTAL&quot;, &quot;3&quot;))&#xa;RETRY_BACKOFF = float(os.getenv(&quot;IDP_CLIENT_RETRY_BACKOFF&quot;, &quot;0.5&quot;))  # экспоненциальная пауза&#xa;&#xa;&#xa;&#xa;&#xa;def _build_session() -&gt; requests.Session:&#xa;    &quot;&quot;&quot;&#xa;    Готовим requests.Session с умным ретраем (на случай сетевых глюков, 502/503/504).&#xa;    &quot;&quot;&quot;&#xa;    session = requests.Session()&#xa;    retries = Retry(&#xa;        total=RETRY_TOTAL,&#xa;        backoff_factor=RETRY_BACKOFF,&#xa;        status_forcelist=(502, 503, 504),&#xa;        allowed_methods=frozenset([&quot;POST&quot;]),&#xa;        raise_on_status=False,&#xa;    )&#xa;    adapter = HTTPAdapter(max_retries=retries)&#xa;    session.mount(&quot;http://&quot;, adapter)&#xa;    session.mount(&quot;https://&quot;, adapter)&#xa;    return session&#xa;&#xa;&#xa;&#xa;&#xa;def _safe_get(dct: Dict[str, Any], path: List[str], default=None):&#xa;    &quot;&quot;&quot;&#xa;    Безопасно достаём значение из вложенного словаря по пути ключей.&#xa;    &quot;&quot;&quot;&#xa;    cur = dct&#xa;    for key in path:&#xa;        if not isinstance(cur, dict) or key not in cur:&#xa;            return default&#xa;        cur = cur[key]&#xa;    return cur&#xa;&#xa;&#xa;&#xa;&#xa;def _normalize_answer_text(text: str) -&gt; str:&#xa;    &quot;&quot;&quot;&#xa;    Хук на будущее: если когда-либо вернутся inline-ссылки вида [^1^],&#xa;    здесь можно будет подменять их на понятные ярлыки.&#xa;    Сейчас просто возвращаем как есть.&#xa;    &quot;&quot;&quot;&#xa;    return text&#xa;&#xa;&#xa;&#xa;&#xa;def _compose_url(base: str, path: str) -&gt; str:&#xa;    base = base.rstrip(&quot;/&quot;)&#xa;    path = path if path.startswith(&quot;/&quot;) else f&quot;/{path}&quot;&#xa;    return f&quot;{base}{path}&quot;&#xa;&#xa;&#xa;&#xa;&#xa;def run_idp_search(user: User, api_base: Optional[str] = None) -&gt; None:&#xa;    &quot;&quot;&quot;&#xa;    Отправляет вопрос на FastAPI эндпоинт /idp_search и записывает результат в user.variables.&#xa;&#xa;&#xa;    Вход:&#xa;        - user.variables[&#39;IDP_question&#39;] : строка вопроса.&#xa;    Выход:&#xa;        - user.variables[&#39;IDP_answer&#39;]         : текст ответа или текст ошибки.&#xa;        - user.variables[&#39;IDP_external_uuid&#39;]  : uuid запроса (если вернулся).&#xa;        - user.variables[&#39;IDP_response_time&#39;]  : время ответа в секундах (если вернулось).&#xa;&#xa;&#xa;    Исключения не пробрасываем — всё логируем и безопасно сохраняем в user.variables.&#xa;    &quot;&quot;&quot;&#xa;    question = user.variables.get(&quot;IDP_question&quot;, &quot;&quot;)&#xa;    if not isinstance(question, str) or len(question.strip()) &lt; 4:&#xa;        msg = &quot;Вопрос пустой или короче 4 символов — IDP его отклонит согласно модели схем.&quot;&#xa;        log(msg, level=&quot;ERROR&quot;)&#xa;        user.variables.set(&quot;IDP_answer&quot;, msg)&#xa;        return&#xa;&#xa;&#xa;    base = api_base or DEFAULT_API_BASE&#xa;    url = _compose_url(base, ENDPOINT_PATH)&#xa;&#xa;&#xa;    # Можно прокинуть trace-id в заголовки для сквозной трассировки&#xa;    external_uuid = str(uuid.uuid4())&#xa;&#xa;&#xa;    headers = dict(DEFAULT_HEADERS)&#xa;    headers[&quot;X-External-UUID&quot;] = external_uuid  # опционально — если на бэке это используется&#xa;&#xa;&#xa;    payload = {&quot;question&quot;: question}&#xa;&#xa;&#xa;    log(f&quot;IDP_SEARCH ▶ POST {url} | headers={headers} | payload={payload}&quot;)&#xa;&#xa;&#xa;    session = _build_session()&#xa;    t0 = time.perf_counter()&#xa;&#xa;&#xa;    try:&#xa;        resp = session.post(url, headers=headers, data=json.dumps(payload), timeout=REQUEST_TIMEOUT)&#xa;        elapsed = time.perf_counter() - t0&#xa;&#xa;&#xa;        # 200 OK — успешный ответ&#xa;        if resp.status_code == 200:&#xa;            data = resp.json()&#xa;&#xa;&#xa;            answer = _safe_get(data, [&quot;answer&quot;], &quot;&quot;)&#xa;            response_time = _safe_get(data, [&quot;response_time&quot;], elapsed)&#xa;            returned_uuid = _safe_get(data, [&quot;external_uuid&quot;], external_uuid)&#xa;&#xa;&#xa;            normalized_answer = _normalize_answer_text(answer)&#xa;&#xa;&#xa;            log(&#xa;                f&quot;IDP_SEARCH ✔ 200 | time={response_time:.2f}s | uuid={returned_uuid} | &quot;&#xa;                f&quot;answer_preview=&#39;{(normalized_answer or &#39;&#39;)[:180]}...&#39;&quot;,&#xa;                level=&quot;INFO&quot;,&#xa;            )&#xa;&#xa;&#xa;            user.variables.set(&quot;IDP_answer&quot;, normalized_answer or &quot;&quot;)&#xa;            user.variables.set(&quot;IDP_external_uuid&quot;, returned_uuid)&#xa;            user.variables.set(&quot;IDP_response_time&quot;, response_time)&#xa;            return&#xa;&#xa;&#xa;        # 424 — проксируем описание ошибки из тела по вашей схеме IDPErrorResponse&#xa;        if resp.status_code == 424:&#xa;            try:&#xa;                err = resp.json()&#xa;            except Exception:&#xa;                err = {}&#xa;&#xa;&#xa;            err_desc = _safe_get(err, [&quot;error_description&quot;], &quot;Ошибка при обращении к IDP&quot;)&#xa;            err_code = _safe_get(err, [&quot;error_code&quot;], &quot;IDP_REQUEST_ERROR&quot;)&#xa;            response_time = _safe_get(err, [&quot;response_time&quot;], time.perf_counter() - t0)&#xa;&#xa;&#xa;            log(f&quot;IDP_SEARCH ✖ 424 | {err_code}: {err_desc} | time={response_time:.2f}s&quot;, level=&quot;ERROR&quot;)&#xa;&#xa;&#xa;            user.variables.set(&quot;IDP_answer&quot;, f&quot;{err_desc} (код: {err_code})&quot;)&#xa;            user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;            user.variables.set(&quot;IDP_response_time&quot;, response_time)&#xa;            return&#xa;&#xa;&#xa;        # Прочие статусы — максимально информативный лог + тело&#xa;        body_preview = &quot;&quot;&#xa;        try:&#xa;            body_preview = json.dumps(resp.json(), ensure_ascii=False)[:500]&#xa;        except Exception:&#xa;            body_preview = (resp.text or &quot;&quot;)[:500]&#xa;&#xa;&#xa;        log(&#xa;            f&quot;IDP_SEARCH ✖ {resp.status_code} {resp.reason} | body=&#39;{body_preview}&#39;&quot;,&#xa;            level=&quot;ERROR&quot;,&#xa;        )&#xa;&#xa;&#xa;        user.variables.set(&#xa;            &quot;IDP_answer&quot;,&#xa;            f&quot;Ошибка: {resp.status_code} {resp.reason}. Обратитесь к логам сервиса.&quot;,&#xa;        )&#xa;        user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;        user.variables.set(&quot;IDP_response_time&quot;, time.perf_counter() - t0)&#xa;&#xa;&#xa;    except requests.Timeout as e:&#xa;        elapsed = time.perf_counter() - t0&#xa;        log(f&quot;IDP_SEARCH ⏱ timeout after {elapsed:.2f}s: {str(e)}&quot;, level=&quot;ERROR&quot;)&#xa;        user.variables.set(&quot;IDP_answer&quot;, &quot;Timeout при обращении к /idp_search&quot;)&#xa;        user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;        user.variables.set(&quot;IDP_response_time&quot;, elapsed)&#xa;&#xa;&#xa;    except requests.RequestException as e:&#xa;        elapsed = time.perf_counter() - t0&#xa;        log(f&quot;IDP_SEARCH ⚠ network error: {str(e)}&quot;, level=&quot;ERROR&quot;)&#xa;        user.variables.set(&quot;IDP_answer&quot;, &quot;Сетевая ошибка при обращении к /idp_search&quot;)&#xa;        user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;        user.variables.set(&quot;IDP_response_time&quot;, elapsed)&#xa;&#xa;&#xa;    except Exception as e:&#xa;        elapsed = time.perf_counter() - t0&#xa;        log(f&quot;IDP_SEARCH ☠ unexpected error: {str(e)}&quot;, level=&quot;ERROR&quot;)&#xa;        user.variables.set(&quot;IDP_answer&quot;, &quot;Неожиданная ошибка клиента IDP&quot;)&#xa;        user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;        user.variables.set(&quot;IDP_response_time&quot;, elapsed)&#xa;&#xa;&#xa;&#xa;&#xa;# --------------------------------------&#xa;# НЕОБЯЗАТЕЛЬНО: асинхронная версия (httpx)&#xa;# --------------------------------------&#xa;# Используй, если у тебя асинхронный воркер, и хочется не блокировать луп.&#xa;# Поведение и контракты идентичны синхронной версии.&#xa;async def run_idp_search_async(user: User, api_base: Optional[str] = None) -&gt; None:&#xa;    import httpx&#xa;    import asyncio&#xa;&#xa;&#xa;    question = user.variables.get(&quot;IDP_question&quot;, &quot;&quot;)&#xa;    if not isinstance(question, str) or len(question.strip()) &lt; 4:&#xa;        msg = &quot;Вопрос пустой или короче 4 символов — IDP его отклонит согласно модели схем.&quot;&#xa;        log(msg, level=&quot;ERROR&quot;)&#xa;        user.variables.set(&quot;IDP_answer&quot;, msg)&#xa;        return&#xa;&#xa;&#xa;    base = api_base or DEFAULT_API_BASE&#xa;    url = _compose_url(base, ENDPOINT_PATH)&#xa;&#xa;&#xa;    external_uuid = str(uuid.uuid4())&#xa;    headers = dict(DEFAULT_HEADERS)&#xa;    headers[&quot;X-External-UUID&quot;] = external_uuid&#xa;&#xa;&#xa;    payload = {&quot;question&quot;: question}&#xa;    log(f&quot;IDP_SEARCH(async) ▶ POST {url} | headers={headers} | payload={payload}&quot;)&#xa;&#xa;&#xa;    # Ретраи вручную, т.к. httpx не имеет встроенного Retry, как requests+urllib3&#xa;    attempts = RETRY_TOTAL + 1&#xa;    backoff = RETRY_BACKOFF&#xa;&#xa;&#xa;    t0 = time.perf_counter()&#xa;&#xa;&#xa;    async with httpx.AsyncClient(timeout=REQUEST_TIMEOUT) as client:&#xa;        for attempt in range(1, attempts + 1):&#xa;            try:&#xa;                resp = await client.post(url, headers=headers, json=payload)&#xa;                elapsed = time.perf_counter() - t0&#xa;&#xa;&#xa;                if resp.status_code == 200:&#xa;                    data = resp.json()&#xa;                    answer = data.get(&quot;answer&quot;, &quot;&quot;)&#xa;                    response_time = data.get(&quot;response_time&quot;, elapsed)&#xa;                    returned_uuid = data.get(&quot;external_uuid&quot;, external_uuid)&#xa;&#xa;&#xa;                    normalized_answer = _normalize_answer_text(answer)&#xa;                    log(&#xa;                        f&quot;IDP_SEARCH(async) ✔ 200 | time={response_time:.2f}s | uuid={returned_uuid} | &quot;&#xa;                        f&quot;answer_preview=&#39;{(normalized_answer or &#39;&#39;)[:180]}...&#39;&quot;,&#xa;                        level=&quot;INFO&quot;,&#xa;                    )&#xa;                    user.variables.set(&quot;IDP_answer&quot;, normalized_answer or &quot;&quot;)&#xa;                    user.variables.set(&quot;IDP_external_uuid&quot;, returned_uuid)&#xa;                    user.variables.set(&quot;IDP_response_time&quot;, response_time)&#xa;                    return&#xa;&#xa;&#xa;                if resp.status_code == 424:&#xa;                    err = resp.json()&#xa;                    err_desc = err.get(&quot;error_description&quot;, &quot;Ошибка при обращении к IDP&quot;)&#xa;                    err_code = err.get(&quot;error_code&quot;, &quot;IDP_REQUEST_ERROR&quot;)&#xa;                    response_time = err.get(&quot;response_time&quot;, elapsed)&#xa;&#xa;&#xa;                    log(f&quot;IDP_SEARCH(async) ✖ 424 | {err_code}: {err_desc} | time={response_time:.2f}s&quot;, level=&quot;ERROR&quot;)&#xa;                    user.variables.set(&quot;IDP_answer&quot;, f&quot;{err_desc} (код: {err_code})&quot;)&#xa;                    user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;                    user.variables.set(&quot;IDP_response_time&quot;, response_time)&#xa;                    return&#xa;&#xa;&#xa;                # На 502/503/504 поделаем ретраи&#xa;                if resp.status_code in (502, 503, 504) and attempt &lt; attempts:&#xa;                    log(f&quot;IDP_SEARCH(async) ↻ retry {attempt}/{attempts-1} after {backoff:.1f}s (status {resp.status_code})&quot;)&#xa;                    await asyncio.sleep(backoff)&#xa;                    backoff *= 2&#xa;                    continue&#xa;&#xa;&#xa;                # Иначе — ошибка без ретрая&#xa;                body_preview = &quot;&quot;&#xa;                try:&#xa;                    body_preview = json.dumps(resp.json(), ensure_ascii=False)[:500]&#xa;                except Exception:&#xa;                    body_preview = (resp.text or &quot;&quot;)[:500]&#xa;&#xa;&#xa;                log(&#xa;                    f&quot;IDP_SEARCH(async) ✖ {resp.status_code} {resp.reason_phrase} | body=&#39;{body_preview}&#39;&quot;,&#xa;                    level=&quot;ERROR&quot;,&#xa;                )&#xa;                user.variables.set(&#xa;                    &quot;IDP_answer&quot;,&#xa;                    f&quot;Ошибка: {resp.status_code} {resp.reason_phrase}. Обратитесь к логам сервиса.&quot;,&#xa;                )&#xa;                user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;                user.variables.set(&quot;IDP_response_time&quot;, elapsed)&#xa;                return&#xa;&#xa;&#xa;            except (httpx.TimeoutException, httpx.TransportError) as e:&#xa;                if attempt &lt; attempts:&#xa;                    log(f&quot;IDP_SEARCH(async) ↻ retry {attempt}/{attempts-1} after {backoff:.1f}s due to network error: {e}&quot;)&#xa;                    await asyncio.sleep(backoff)&#xa;                    backoff *= 2&#xa;                    continue&#xa;&#xa;&#xa;                elapsed = time.perf_counter() - t0&#xa;                log(f&quot;IDP_SEARCH(async) ⚠ network/timeout error: {str(e)}&quot;, level=&quot;ERROR&quot;)&#xa;                user.variables.set(&quot;IDP_answer&quot;, &quot;Сетевая ошибка при обращении к /idp_search&quot;)&#xa;                user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;                user.variables.set(&quot;IDP_response_time&quot;, elapsed)&#xa;                return&#xa;&#xa;&#xa;&#xa;&#xa;if __name__ == &quot;__main__&quot;:&#xa;    # Пример запуска как у тебя, но через новый клиент&#xa;    questions = [&#xa;        &quot;Какие манипуляции с долгом возможны в отчетности?&quot;,&#xa;        &quot;По какому участнику сделки требуется построение прогноза движения денежных средств при установлении ИР на Консолидированную Группу?&quot;,&#xa;        &quot;На какой срок строятся будущие денежные потоки?&quot;,&#xa;        &quot;Как определить, что деятельность носит сезонный характер?&quot;,&#xa;        &quot;Можно ли строить будущие денежные потоки в иностранной валюте?&quot;,&#xa;        &quot;Относится ли к прочим изменениям увеличение срока действующей банковской гарантии?&quot;,&#xa;        &quot;Требуется ли проверка Fraud-риска по техническим изменениям?&quot;,&#xa;        &quot;Является ли прочим изменением продление периода выборки по сделке УФН?&quot;,&#xa;        &quot;Финансирует ли Банк казино?&quot;,&#xa;        &quot;Особенности финансирования по договорам простого товарищества&quot;,&#xa;        &quot;Может ли банк финансировать некоммерческие организации?&quot;,&#xa;    ]&#xa;&#xa;&#xa;    # Импорт твоей модели User остаётся прежним.&#xa;    # Ниже — простая заглушка. В реальном коде у тебя уже есть инстанс user.&#xa;    class _VarStore(dict):&#xa;        def set(self, k, v):&#xa;            self[k] = v&#xa;&#xa;&#xa;    class _User:&#xa;        def __init__(self):&#xa;            self.variables = _VarStore()&#xa;&#xa;&#xa;    for q in questions:&#xa;        u = _User()&#xa;        u.variables.set(&quot;IDP_question&quot;, q)&#xa;        run_idp_search(u)&#xa;        print(f&quot;Q: {q}\nA: {u.variables.get(&#39;IDP_answer&#39;)}\nUUID: {u.variables.get(&#39;IDP_external_uuid&#39;)}, &quot;&#xa;              f&quot;Time: {u.variables.get(&#39;IDP_response_time&#39;)}s\n{&#39;-&#39;*80}&quot;)" link="# idp_client.py&#xa;import os&#xa;import uuid&#xa;import time&#xa;import json&#xa;import requests&#xa;from typing import Optional, Tuple, Dict, Any, List&#xa;from requests.adapters import HTTPAdapter, Retry&#xa;&#xa;&#xa;from core.logging.logger_utils import log&#xa;from scenarios.user.user_model import User&#xa;&#xa;&#xa;&#xa;&#xa;# -----------------------------&#xa;# ВСПОМОГАТЕЛЬНЫЕ НАСТРОЙКИ&#xa;# -----------------------------&#xa;DEFAULT_API_BASE = os.getenv(&quot;IDP_GATEWAY_BASE&quot;, &quot;http://localhost:8000&quot;)  # где крутится твой FastAPI&#xa;ENDPOINT_PATH = os.getenv(&quot;IDP_SEARCH_PATH&quot;, &quot;/idp_search&quot;)&#xa;&#xa;&#xa;# Если ваш Depends(common_headers) ожидает определённые заголовки — добавь их в ENV и сюда&#xa;DEFAULT_HEADERS: Dict[str, str] = {&#xa;    &quot;accept&quot;: &quot;application/json&quot;,&#xa;    &quot;Content-Type&quot;: &quot;application/json&quot;,&#xa;    # Примеры корпоративных заголовков — подставь нужные, если требуется:&#xa;    # &quot;X-Request-Source&quot;: os.getenv(&quot;X_REQUEST_SOURCE&quot;, &quot;your-service&quot;),&#xa;    # &quot;X-Auth-Token&quot;: os.getenv(&quot;X_AUTH_TOKEN&quot;, &quot;&quot;),&#xa;}&#xa;&#xa;&#xa;REQUEST_TIMEOUT = float(os.getenv(&quot;IDP_CLIENT_TIMEOUT&quot;, &quot;30&quot;))  # сек.&#xa;RETRY_TOTAL = int(os.getenv(&quot;IDP_CLIENT_RETRY_TOTAL&quot;, &quot;3&quot;))&#xa;RETRY_BACKOFF = float(os.getenv(&quot;IDP_CLIENT_RETRY_BACKOFF&quot;, &quot;0.5&quot;))  # экспоненциальная пауза&#xa;&#xa;&#xa;&#xa;&#xa;def _build_session() -&gt; requests.Session:&#xa;    &quot;&quot;&quot;&#xa;    Готовим requests.Session с умным ретраем (на случай сетевых глюков, 502/503/504).&#xa;    &quot;&quot;&quot;&#xa;    session = requests.Session()&#xa;    retries = Retry(&#xa;        total=RETRY_TOTAL,&#xa;        backoff_factor=RETRY_BACKOFF,&#xa;        status_forcelist=(502, 503, 504),&#xa;        allowed_methods=frozenset([&quot;POST&quot;]),&#xa;        raise_on_status=False,&#xa;    )&#xa;    adapter = HTTPAdapter(max_retries=retries)&#xa;    session.mount(&quot;http://&quot;, adapter)&#xa;    session.mount(&quot;https://&quot;, adapter)&#xa;    return session&#xa;&#xa;&#xa;&#xa;&#xa;def _safe_get(dct: Dict[str, Any], path: List[str], default=None):&#xa;    &quot;&quot;&quot;&#xa;    Безопасно достаём значение из вложенного словаря по пути ключей.&#xa;    &quot;&quot;&quot;&#xa;    cur = dct&#xa;    for key in path:&#xa;        if not isinstance(cur, dict) or key not in cur:&#xa;            return default&#xa;        cur = cur[key]&#xa;    return cur&#xa;&#xa;&#xa;&#xa;&#xa;def _normalize_answer_text(text: str) -&gt; str:&#xa;    &quot;&quot;&quot;&#xa;    Хук на будущее: если когда-либо вернутся inline-ссылки вида [^1^],&#xa;    здесь можно будет подменять их на понятные ярлыки.&#xa;    Сейчас просто возвращаем как есть.&#xa;    &quot;&quot;&quot;&#xa;    return text&#xa;&#xa;&#xa;&#xa;&#xa;def _compose_url(base: str, path: str) -&gt; str:&#xa;    base = base.rstrip(&quot;/&quot;)&#xa;    path = path if path.startswith(&quot;/&quot;) else f&quot;/{path}&quot;&#xa;    return f&quot;{base}{path}&quot;&#xa;&#xa;&#xa;&#xa;&#xa;def run_idp_search(user: User, api_base: Optional[str] = None) -&gt; None:&#xa;    &quot;&quot;&quot;&#xa;    Отправляет вопрос на FastAPI эндпоинт /idp_search и записывает результат в user.variables.&#xa;&#xa;&#xa;    Вход:&#xa;        - user.variables[&#39;IDP_question&#39;] : строка вопроса.&#xa;    Выход:&#xa;        - user.variables[&#39;IDP_answer&#39;]         : текст ответа или текст ошибки.&#xa;        - user.variables[&#39;IDP_external_uuid&#39;]  : uuid запроса (если вернулся).&#xa;        - user.variables[&#39;IDP_response_time&#39;]  : время ответа в секундах (если вернулось).&#xa;&#xa;&#xa;    Исключения не пробрасываем — всё логируем и безопасно сохраняем в user.variables.&#xa;    &quot;&quot;&quot;&#xa;    question = user.variables.get(&quot;IDP_question&quot;, &quot;&quot;)&#xa;    if not isinstance(question, str) or len(question.strip()) &lt; 4:&#xa;        msg = &quot;Вопрос пустой или короче 4 символов — IDP его отклонит согласно модели схем.&quot;&#xa;        log(msg, level=&quot;ERROR&quot;)&#xa;        user.variables.set(&quot;IDP_answer&quot;, msg)&#xa;        return&#xa;&#xa;&#xa;    base = api_base or DEFAULT_API_BASE&#xa;    url = _compose_url(base, ENDPOINT_PATH)&#xa;&#xa;&#xa;    # Можно прокинуть trace-id в заголовки для сквозной трассировки&#xa;    external_uuid = str(uuid.uuid4())&#xa;&#xa;&#xa;    headers = dict(DEFAULT_HEADERS)&#xa;    headers[&quot;X-External-UUID&quot;] = external_uuid  # опционально — если на бэке это используется&#xa;&#xa;&#xa;    payload = {&quot;question&quot;: question}&#xa;&#xa;&#xa;    log(f&quot;IDP_SEARCH ▶ POST {url} | headers={headers} | payload={payload}&quot;)&#xa;&#xa;&#xa;    session = _build_session()&#xa;    t0 = time.perf_counter()&#xa;&#xa;&#xa;    try:&#xa;        resp = session.post(url, headers=headers, data=json.dumps(payload), timeout=REQUEST_TIMEOUT)&#xa;        elapsed = time.perf_counter() - t0&#xa;&#xa;&#xa;        # 200 OK — успешный ответ&#xa;        if resp.status_code == 200:&#xa;            data = resp.json()&#xa;&#xa;&#xa;            answer = _safe_get(data, [&quot;answer&quot;], &quot;&quot;)&#xa;            response_time = _safe_get(data, [&quot;response_time&quot;], elapsed)&#xa;            returned_uuid = _safe_get(data, [&quot;external_uuid&quot;], external_uuid)&#xa;&#xa;&#xa;            normalized_answer = _normalize_answer_text(answer)&#xa;&#xa;&#xa;            log(&#xa;                f&quot;IDP_SEARCH ✔ 200 | time={response_time:.2f}s | uuid={returned_uuid} | &quot;&#xa;                f&quot;answer_preview=&#39;{(normalized_answer or &#39;&#39;)[:180]}...&#39;&quot;,&#xa;                level=&quot;INFO&quot;,&#xa;            )&#xa;&#xa;&#xa;            user.variables.set(&quot;IDP_answer&quot;, normalized_answer or &quot;&quot;)&#xa;            user.variables.set(&quot;IDP_external_uuid&quot;, returned_uuid)&#xa;            user.variables.set(&quot;IDP_response_time&quot;, response_time)&#xa;            return&#xa;&#xa;&#xa;        # 424 — проксируем описание ошибки из тела по вашей схеме IDPErrorResponse&#xa;        if resp.status_code == 424:&#xa;            try:&#xa;                err = resp.json()&#xa;            except Exception:&#xa;                err = {}&#xa;&#xa;&#xa;            err_desc = _safe_get(err, [&quot;error_description&quot;], &quot;Ошибка при обращении к IDP&quot;)&#xa;            err_code = _safe_get(err, [&quot;error_code&quot;], &quot;IDP_REQUEST_ERROR&quot;)&#xa;            response_time = _safe_get(err, [&quot;response_time&quot;], time.perf_counter() - t0)&#xa;&#xa;&#xa;            log(f&quot;IDP_SEARCH ✖ 424 | {err_code}: {err_desc} | time={response_time:.2f}s&quot;, level=&quot;ERROR&quot;)&#xa;&#xa;&#xa;            user.variables.set(&quot;IDP_answer&quot;, f&quot;{err_desc} (код: {err_code})&quot;)&#xa;            user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;            user.variables.set(&quot;IDP_response_time&quot;, response_time)&#xa;            return&#xa;&#xa;&#xa;        # Прочие статусы — максимально информативный лог + тело&#xa;        body_preview = &quot;&quot;&#xa;        try:&#xa;            body_preview = json.dumps(resp.json(), ensure_ascii=False)[:500]&#xa;        except Exception:&#xa;            body_preview = (resp.text or &quot;&quot;)[:500]&#xa;&#xa;&#xa;        log(&#xa;            f&quot;IDP_SEARCH ✖ {resp.status_code} {resp.reason} | body=&#39;{body_preview}&#39;&quot;,&#xa;            level=&quot;ERROR&quot;,&#xa;        )&#xa;&#xa;&#xa;        user.variables.set(&#xa;            &quot;IDP_answer&quot;,&#xa;            f&quot;Ошибка: {resp.status_code} {resp.reason}. Обратитесь к логам сервиса.&quot;,&#xa;        )&#xa;        user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;        user.variables.set(&quot;IDP_response_time&quot;, time.perf_counter() - t0)&#xa;&#xa;&#xa;    except requests.Timeout as e:&#xa;        elapsed = time.perf_counter() - t0&#xa;        log(f&quot;IDP_SEARCH ⏱ timeout after {elapsed:.2f}s: {str(e)}&quot;, level=&quot;ERROR&quot;)&#xa;        user.variables.set(&quot;IDP_answer&quot;, &quot;Timeout при обращении к /idp_search&quot;)&#xa;        user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;        user.variables.set(&quot;IDP_response_time&quot;, elapsed)&#xa;&#xa;&#xa;    except requests.RequestException as e:&#xa;        elapsed = time.perf_counter() - t0&#xa;        log(f&quot;IDP_SEARCH ⚠ network error: {str(e)}&quot;, level=&quot;ERROR&quot;)&#xa;        user.variables.set(&quot;IDP_answer&quot;, &quot;Сетевая ошибка при обращении к /idp_search&quot;)&#xa;        user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;        user.variables.set(&quot;IDP_response_time&quot;, elapsed)&#xa;&#xa;&#xa;    except Exception as e:&#xa;        elapsed = time.perf_counter() - t0&#xa;        log(f&quot;IDP_SEARCH ☠ unexpected error: {str(e)}&quot;, level=&quot;ERROR&quot;)&#xa;        user.variables.set(&quot;IDP_answer&quot;, &quot;Неожиданная ошибка клиента IDP&quot;)&#xa;        user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;        user.variables.set(&quot;IDP_response_time&quot;, elapsed)&#xa;&#xa;&#xa;&#xa;&#xa;# --------------------------------------&#xa;# НЕОБЯЗАТЕЛЬНО: асинхронная версия (httpx)&#xa;# --------------------------------------&#xa;# Используй, если у тебя асинхронный воркер, и хочется не блокировать луп.&#xa;# Поведение и контракты идентичны синхронной версии.&#xa;async def run_idp_search_async(user: User, api_base: Optional[str] = None) -&gt; None:&#xa;    import httpx&#xa;    import asyncio&#xa;&#xa;&#xa;    question = user.variables.get(&quot;IDP_question&quot;, &quot;&quot;)&#xa;    if not isinstance(question, str) or len(question.strip()) &lt; 4:&#xa;        msg = &quot;Вопрос пустой или короче 4 символов — IDP его отклонит согласно модели схем.&quot;&#xa;        log(msg, level=&quot;ERROR&quot;)&#xa;        user.variables.set(&quot;IDP_answer&quot;, msg)&#xa;        return&#xa;&#xa;&#xa;    base = api_base or DEFAULT_API_BASE&#xa;    url = _compose_url(base, ENDPOINT_PATH)&#xa;&#xa;&#xa;    external_uuid = str(uuid.uuid4())&#xa;    headers = dict(DEFAULT_HEADERS)&#xa;    headers[&quot;X-External-UUID&quot;] = external_uuid&#xa;&#xa;&#xa;    payload = {&quot;question&quot;: question}&#xa;    log(f&quot;IDP_SEARCH(async) ▶ POST {url} | headers={headers} | payload={payload}&quot;)&#xa;&#xa;&#xa;    # Ретраи вручную, т.к. httpx не имеет встроенного Retry, как requests+urllib3&#xa;    attempts = RETRY_TOTAL + 1&#xa;    backoff = RETRY_BACKOFF&#xa;&#xa;&#xa;    t0 = time.perf_counter()&#xa;&#xa;&#xa;    async with httpx.AsyncClient(timeout=REQUEST_TIMEOUT) as client:&#xa;        for attempt in range(1, attempts + 1):&#xa;            try:&#xa;                resp = await client.post(url, headers=headers, json=payload)&#xa;                elapsed = time.perf_counter() - t0&#xa;&#xa;&#xa;                if resp.status_code == 200:&#xa;                    data = resp.json()&#xa;                    answer = data.get(&quot;answer&quot;, &quot;&quot;)&#xa;                    response_time = data.get(&quot;response_time&quot;, elapsed)&#xa;                    returned_uuid = data.get(&quot;external_uuid&quot;, external_uuid)&#xa;&#xa;&#xa;                    normalized_answer = _normalize_answer_text(answer)&#xa;                    log(&#xa;                        f&quot;IDP_SEARCH(async) ✔ 200 | time={response_time:.2f}s | uuid={returned_uuid} | &quot;&#xa;                        f&quot;answer_preview=&#39;{(normalized_answer or &#39;&#39;)[:180]}...&#39;&quot;,&#xa;                        level=&quot;INFO&quot;,&#xa;                    )&#xa;                    user.variables.set(&quot;IDP_answer&quot;, normalized_answer or &quot;&quot;)&#xa;                    user.variables.set(&quot;IDP_external_uuid&quot;, returned_uuid)&#xa;                    user.variables.set(&quot;IDP_response_time&quot;, response_time)&#xa;                    return&#xa;&#xa;&#xa;                if resp.status_code == 424:&#xa;                    err = resp.json()&#xa;                    err_desc = err.get(&quot;error_description&quot;, &quot;Ошибка при обращении к IDP&quot;)&#xa;                    err_code = err.get(&quot;error_code&quot;, &quot;IDP_REQUEST_ERROR&quot;)&#xa;                    response_time = err.get(&quot;response_time&quot;, elapsed)&#xa;&#xa;&#xa;                    log(f&quot;IDP_SEARCH(async) ✖ 424 | {err_code}: {err_desc} | time={response_time:.2f}s&quot;, level=&quot;ERROR&quot;)&#xa;                    user.variables.set(&quot;IDP_answer&quot;, f&quot;{err_desc} (код: {err_code})&quot;)&#xa;                    user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;                    user.variables.set(&quot;IDP_response_time&quot;, response_time)&#xa;                    return&#xa;&#xa;&#xa;                # На 502/503/504 поделаем ретраи&#xa;                if resp.status_code in (502, 503, 504) and attempt &lt; attempts:&#xa;                    log(f&quot;IDP_SEARCH(async) ↻ retry {attempt}/{attempts-1} after {backoff:.1f}s (status {resp.status_code})&quot;)&#xa;                    await asyncio.sleep(backoff)&#xa;                    backoff *= 2&#xa;                    continue&#xa;&#xa;&#xa;                # Иначе — ошибка без ретрая&#xa;                body_preview = &quot;&quot;&#xa;                try:&#xa;                    body_preview = json.dumps(resp.json(), ensure_ascii=False)[:500]&#xa;                except Exception:&#xa;                    body_preview = (resp.text or &quot;&quot;)[:500]&#xa;&#xa;&#xa;                log(&#xa;                    f&quot;IDP_SEARCH(async) ✖ {resp.status_code} {resp.reason_phrase} | body=&#39;{body_preview}&#39;&quot;,&#xa;                    level=&quot;ERROR&quot;,&#xa;                )&#xa;                user.variables.set(&#xa;                    &quot;IDP_answer&quot;,&#xa;                    f&quot;Ошибка: {resp.status_code} {resp.reason_phrase}. Обратитесь к логам сервиса.&quot;,&#xa;                )&#xa;                user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;                user.variables.set(&quot;IDP_response_time&quot;, elapsed)&#xa;                return&#xa;&#xa;&#xa;            except (httpx.TimeoutException, httpx.TransportError) as e:&#xa;                if attempt &lt; attempts:&#xa;                    log(f&quot;IDP_SEARCH(async) ↻ retry {attempt}/{attempts-1} after {backoff:.1f}s due to network error: {e}&quot;)&#xa;                    await asyncio.sleep(backoff)&#xa;                    backoff *= 2&#xa;                    continue&#xa;&#xa;&#xa;                elapsed = time.perf_counter() - t0&#xa;                log(f&quot;IDP_SEARCH(async) ⚠ network/timeout error: {str(e)}&quot;, level=&quot;ERROR&quot;)&#xa;                user.variables.set(&quot;IDP_answer&quot;, &quot;Сетевая ошибка при обращении к /idp_search&quot;)&#xa;                user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;                user.variables.set(&quot;IDP_response_time&quot;, elapsed)&#xa;                return&#xa;&#xa;&#xa;&#xa;&#xa;if __name__ == &quot;__main__&quot;:&#xa;    # Пример запуска как у тебя, но через новый клиент&#xa;    questions = [&#xa;        &quot;Какие манипуляции с долгом возможны в отчетности?&quot;,&#xa;        &quot;По какому участнику сделки требуется построение прогноза движения денежных средств при установлении ИР на Консолидированную Группу?&quot;,&#xa;        &quot;На какой срок строятся будущие денежные потоки?&quot;,&#xa;        &quot;Как определить, что деятельность носит сезонный характер?&quot;,&#xa;        &quot;Можно ли строить будущие денежные потоки в иностранной валюте?&quot;,&#xa;        &quot;Относится ли к прочим изменениям увеличение срока действующей банковской гарантии?&quot;,&#xa;        &quot;Требуется ли проверка Fraud-риска по техническим изменениям?&quot;,&#xa;        &quot;Является ли прочим изменением продление периода выборки по сделке УФН?&quot;,&#xa;        &quot;Финансирует ли Банк казино?&quot;,&#xa;        &quot;Особенности финансирования по договорам простого товарищества&quot;,&#xa;        &quot;Может ли банк финансировать некоммерческие организации?&quot;,&#xa;    ]&#xa;&#xa;&#xa;    # Импорт твоей модели User остаётся прежним.&#xa;    # Ниже — простая заглушка. В реальном коде у тебя уже есть инстанс user.&#xa;    class _VarStore(dict):&#xa;        def set(self, k, v):&#xa;            self[k] = v&#xa;&#xa;&#xa;    class _User:&#xa;        def __init__(self):&#xa;            self.variables = _VarStore()&#xa;&#xa;&#xa;    for q in questions:&#xa;        u = _User()&#xa;        u.variables.set(&quot;IDP_question&quot;, q)&#xa;        run_idp_search(u)&#xa;        print(f&quot;Q: {q}\nA: {u.variables.get(&#39;IDP_answer&#39;)}\nUUID: {u.variables.get(&#39;IDP_external_uuid&#39;)}, &quot;&#xa;              f&quot;Time: {u.variables.get(&#39;IDP_response_time&#39;)}s\n{&#39;-&#39;*80}&quot;)" id="xQ9-_gr5QTslfE1LpaSg-1">
          <mxCell style="text;whiteSpace=wrap;" parent="1" vertex="1">
            <mxGeometry x="1710" y="480" width="560" height="6030" as="geometry" />
          </mxCell>
        </UserObject>
        <UserObject label="from datetime import datetime, timezone, timedelta&#xa;&#xa;&#xa;def request_time_header(offset_hours: int = 3) -&gt; str:&#xa;    &quot;&quot;&quot;Возвращает строку формата &#39;Request-Time: 2025-08-25T22:58:32.469340+03:00&#39;.&quot;&quot;&quot;&#xa;    tz = timezone(timedelta(hours=offset_hours))&#xa;    now = datetime.now(tz)  # TZ-aware&#xa;    # isoformat уже включает оффсет как +HH:MM, микросекунды идут по умолчанию&#xa;    return f&quot;Request-Time: {now.isoformat()}&quot;" link="from datetime import datetime, timezone, timedelta&#xa;&#xa;&#xa;def request_time_header(offset_hours: int = 3) -&gt; str:&#xa;    &quot;&quot;&quot;Возвращает строку формата &#39;Request-Time: 2025-08-25T22:58:32.469340+03:00&#39;.&quot;&quot;&quot;&#xa;    tz = timezone(timedelta(hours=offset_hours))&#xa;    now = datetime.now(tz)  # TZ-aware&#xa;    # isoformat уже включает оффсет как +HH:MM, микросекунды идут по умолчанию&#xa;    return f&quot;Request-Time: {now.isoformat()}&quot;" id="xQ9-_gr5QTslfE1LpaSg-2">
          <mxCell style="text;whiteSpace=wrap;" parent="1" vertex="1">
            <mxGeometry x="1460" y="700" width="520" height="150" as="geometry" />
          </mxCell>
        </UserObject>
        <mxCell id="zntTJmJaQ5f6_OLdWCkL-2" value="&lt;h1 data-start=&quot;83&quot; data-end=&quot;134&quot;&gt;Дорожная карта по развитию ассистента (Q4 2025)&lt;/h1&gt;&#xa;&lt;div class=&quot;_tableContainer_1rjym_1&quot;&gt;&lt;div tabindex=&quot;-1&quot; class=&quot;group _tableWrapper_1rjym_13 flex w-fit flex-col-reverse&quot;&gt;&lt;table data-start=&quot;136&quot; data-end=&quot;1017&quot; class=&quot;w-fit min-w-(--thread-content-width)&quot;&gt;&lt;thead data-start=&quot;136&quot; data-end=&quot;175&quot;&gt;&lt;tr data-start=&quot;136&quot; data-end=&quot;175&quot;&gt;&lt;th data-start=&quot;136&quot; data-end=&quot;145&quot; data-col-size=&quot;sm&quot;&gt;Период&lt;/th&gt;&lt;th data-start=&quot;145&quot; data-end=&quot;151&quot; data-col-size=&quot;sm&quot;&gt;Шаг&lt;/th&gt;&lt;th data-start=&quot;151&quot; data-end=&quot;162&quot; data-col-size=&quot;md&quot;&gt;Действие&lt;/th&gt;&lt;th data-start=&quot;162&quot; data-end=&quot;175&quot; data-col-size=&quot;md&quot;&gt;Результат&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody data-start=&quot;217&quot; data-end=&quot;1017&quot;&gt;&lt;tr data-start=&quot;217&quot; data-end=&quot;339&quot;&gt;&lt;td data-start=&quot;217&quot; data-end=&quot;231&quot; data-col-size=&quot;sm&quot;&gt;&lt;strong data-start=&quot;219&quot; data-end=&quot;230&quot;&gt;Октябрь&lt;/strong&gt;&lt;/td&gt;&lt;td data-start=&quot;231&quot; data-end=&quot;248&quot; data-col-size=&quot;sm&quot;&gt;&lt;strong data-start=&quot;233&quot; data-end=&quot;247&quot;&gt;1. Запросы&lt;/strong&gt;&lt;/td&gt;&lt;td data-start=&quot;248&quot; data-end=&quot;303&quot; data-col-size=&quot;md&quot;&gt;Внедрение переформулирования и декомпозиции вопросов&lt;/td&gt;&lt;td data-start=&quot;303&quot; data-end=&quot;339&quot; data-col-size=&quot;md&quot;&gt;Более корректные запросы в поиск&lt;/td&gt;&lt;/tr&gt;&lt;tr data-start=&quot;340&quot; data-end=&quot;487&quot;&gt;&lt;td data-start=&quot;340&quot; data-end=&quot;361&quot; data-col-size=&quot;sm&quot;&gt;&lt;strong data-start=&quot;342&quot; data-end=&quot;360&quot;&gt;Октябрь–ноябрь&lt;/strong&gt;&lt;/td&gt;&lt;td data-start=&quot;361&quot; data-end=&quot;376&quot; data-col-size=&quot;sm&quot;&gt;&lt;strong data-start=&quot;363&quot; data-end=&quot;375&quot;&gt;2. Поиск&lt;/strong&gt;&lt;/td&gt;&lt;td data-start=&quot;376&quot; data-end=&quot;444&quot; data-col-size=&quot;md&quot;&gt;Настройка гибридного поиска (BM25+векторный) + внедрение reranker&lt;/td&gt;&lt;td data-start=&quot;444&quot; data-end=&quot;487&quot; data-col-size=&quot;md&quot;&gt;Рост релевантности найденных фрагментов&lt;/td&gt;&lt;/tr&gt;&lt;tr data-start=&quot;488&quot; data-end=&quot;593&quot;&gt;&lt;td data-start=&quot;488&quot; data-end=&quot;501&quot; data-col-size=&quot;sm&quot;&gt;&lt;strong data-start=&quot;490&quot; data-end=&quot;500&quot;&gt;Ноябрь&lt;/strong&gt;&lt;/td&gt;&lt;td data-start=&quot;501&quot; data-end=&quot;514&quot; data-col-size=&quot;sm&quot;&gt;&lt;strong data-start=&quot;503&quot; data-end=&quot;513&quot;&gt;3. FAQ&lt;/strong&gt;&lt;/td&gt;&lt;td data-start=&quot;514&quot; data-end=&quot;556&quot; data-col-size=&quot;md&quot;&gt;Интеграция базы FAQ в поиск и генерацию&lt;/td&gt;&lt;td data-start=&quot;556&quot; data-end=&quot;593&quot; data-col-size=&quot;md&quot;&gt;Использование проверенных ответов&lt;/td&gt;&lt;/tr&gt;&lt;tr data-start=&quot;594&quot; data-end=&quot;754&quot;&gt;&lt;td data-start=&quot;594&quot; data-end=&quot;615&quot; data-col-size=&quot;sm&quot;&gt;&lt;strong data-start=&quot;596&quot; data-end=&quot;614&quot;&gt;Ноябрь–декабрь&lt;/strong&gt;&lt;/td&gt;&lt;td data-start=&quot;615&quot; data-end=&quot;634&quot; data-col-size=&quot;sm&quot;&gt;&lt;strong data-start=&quot;617&quot; data-end=&quot;633&quot;&gt;4. Генерация&lt;/strong&gt;&lt;/td&gt;&lt;td data-start=&quot;634&quot; data-end=&quot;711&quot; data-col-size=&quot;md&quot;&gt;Оптимизация промптов GigaChat, настройка подачи контекста, примеры ответов&lt;/td&gt;&lt;td data-start=&quot;711&quot; data-end=&quot;754&quot; data-col-size=&quot;md&quot;&gt;Более точные и структурированные ответы&lt;/td&gt;&lt;/tr&gt;&lt;tr data-start=&quot;755&quot; data-end=&quot;877&quot;&gt;&lt;td data-start=&quot;755&quot; data-end=&quot;769&quot; data-col-size=&quot;sm&quot;&gt;&lt;strong data-start=&quot;757&quot; data-end=&quot;768&quot;&gt;Декабрь&lt;/strong&gt;&lt;/td&gt;&lt;td data-start=&quot;769&quot; data-end=&quot;785&quot; data-col-size=&quot;sm&quot;&gt;&lt;strong data-start=&quot;771&quot; data-end=&quot;784&quot;&gt;5. Диалог&lt;/strong&gt;&lt;/td&gt;&lt;td data-start=&quot;785&quot; data-end=&quot;845&quot; data-col-size=&quot;md&quot;&gt;Реализация уточняющих вопросов и автоматических подсказок&lt;/td&gt;&lt;td data-start=&quot;845&quot; data-end=&quot;877&quot; data-col-size=&quot;md&quot;&gt;Улучшение опыта пользователя&lt;/td&gt;&lt;/tr&gt;&lt;tr data-start=&quot;878&quot; data-end=&quot;1017&quot;&gt;&lt;td data-start=&quot;878&quot; data-end=&quot;892&quot; data-col-size=&quot;sm&quot;&gt;&lt;strong data-start=&quot;880&quot; data-end=&quot;891&quot;&gt;Декабрь&lt;/strong&gt;&lt;/td&gt;&lt;td data-start=&quot;892&quot; data-end=&quot;910&quot; data-col-size=&quot;sm&quot;&gt;&lt;strong data-start=&quot;894&quot; data-end=&quot;909&quot;&gt;6. Качество&lt;/strong&gt;&lt;/td&gt;&lt;td data-start=&quot;910&quot; data-end=&quot;971&quot; data-col-size=&quot;md&quot;&gt;Эталонный набор, метрики (nDCG), пилотное A/B тестирование&lt;/td&gt;&lt;td data-start=&quot;971&quot; data-end=&quot;1017&quot; data-col-size=&quot;md&quot;&gt;Система обратной связи и контроль качества&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;" style="text;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="370" y="1410" width="560" height="370" as="geometry" />
        </mxCell>
        <mxCell id="zntTJmJaQ5f6_OLdWCkL-3" value="&lt;p data-start=&quot;55&quot; data-end=&quot;90&quot;&gt;&lt;strong data-start=&quot;55&quot; data-end=&quot;88&quot;&gt;Шаг 1. Предобработка запросов&lt;/strong&gt;&lt;/p&gt;&#xa;&lt;ul data-start=&quot;91&quot; data-end=&quot;261&quot;&gt;&#xa;&lt;li data-start=&quot;91&quot; data-end=&quot;174&quot;&gt;&#xa;&lt;p data-start=&quot;93&quot; data-end=&quot;174&quot;&gt;Внедрить переформулирование и расширение вопросов (query rewriting, expansion).&lt;/p&gt;&#xa;&lt;/li&gt;&#xa;&lt;li data-start=&quot;175&quot; data-end=&quot;211&quot;&gt;&#xa;&lt;p data-start=&quot;177&quot; data-end=&quot;211&quot;&gt;Декомпозировать сложные запросы.&lt;/p&gt;&#xa;&lt;/li&gt;&#xa;&lt;li data-start=&quot;212&quot; data-end=&quot;261&quot;&gt;&#xa;&lt;p data-start=&quot;214&quot; data-end=&quot;261&quot;&gt;Уточнять расплывчатые вопросы у пользователя.&lt;/p&gt;&#xa;&lt;/li&gt;&#xa;&lt;/ul&gt;&#xa;&lt;p data-start=&quot;263&quot; data-end=&quot;301&quot;&gt;&lt;strong data-start=&quot;263&quot; data-end=&quot;299&quot;&gt;Шаг 2. Повышение качества поиска&lt;/strong&gt;&lt;/p&gt;&#xa;&lt;ul data-start=&quot;302&quot; data-end=&quot;477&quot;&gt;&#xa;&lt;li data-start=&quot;302&quot; data-end=&quot;354&quot;&gt;&#xa;&lt;p data-start=&quot;304&quot; data-end=&quot;354&quot;&gt;Использовать гибридный поиск (BM25 + векторный).&lt;/p&gt;&#xa;&lt;/li&gt;&#xa;&lt;li data-start=&quot;355&quot; data-end=&quot;408&quot;&gt;&#xa;&lt;p data-start=&quot;357&quot; data-end=&quot;408&quot;&gt;Добавить переранжирование результатов (reranker).&lt;/p&gt;&#xa;&lt;/li&gt;&#xa;&lt;li data-start=&quot;409&quot; data-end=&quot;477&quot;&gt;&#xa;&lt;p data-start=&quot;411&quot; data-end=&quot;477&quot;&gt;Применять фильтрацию и метаданные (по ВНД, подразделению, дате).&lt;/p&gt;&#xa;&lt;/li&gt;&#xa;&lt;/ul&gt;&#xa;&lt;p data-start=&quot;479&quot; data-end=&quot;509&quot;&gt;&lt;strong data-start=&quot;479&quot; data-end=&quot;507&quot;&gt;Шаг 3. Использование FAQ&lt;/strong&gt;&lt;/p&gt;&#xa;&lt;ul data-start=&quot;510&quot; data-end=&quot;600&quot;&gt;&#xa;&lt;li data-start=&quot;510&quot; data-end=&quot;545&quot;&gt;&#xa;&lt;p data-start=&quot;512&quot; data-end=&quot;545&quot;&gt;Интегрировать базу FAQ в поиск.&lt;/p&gt;&#xa;&lt;/li&gt;&#xa;&lt;li data-start=&quot;546&quot; data-end=&quot;600&quot;&gt;&#xa;&lt;p data-start=&quot;548&quot; data-end=&quot;600&quot;&gt;Подмешивать готовые проверенные ответы в контекст.&lt;/p&gt;&#xa;&lt;/li&gt;&#xa;&lt;/ul&gt;&#xa;&lt;p data-start=&quot;602&quot; data-end=&quot;653&quot;&gt;&lt;strong data-start=&quot;602&quot; data-end=&quot;651&quot;&gt;Шаг 4. Настройка генерации ответов (GigaChat)&lt;/strong&gt;&lt;/p&gt;&#xa;&lt;ul data-start=&quot;654&quot; data-end=&quot;831&quot;&gt;&#xa;&lt;li data-start=&quot;654&quot; data-end=&quot;716&quot;&gt;&#xa;&lt;p data-start=&quot;656&quot; data-end=&quot;716&quot;&gt;Оптимизировать промпт (инструкции, запрет на выдумывание).&lt;/p&gt;&#xa;&lt;/li&gt;&#xa;&lt;li data-start=&quot;717&quot; data-end=&quot;784&quot;&gt;&#xa;&lt;p data-start=&quot;719&quot; data-end=&quot;784&quot;&gt;Давать структурированный контекст (самое релевантное – первым).&lt;/p&gt;&#xa;&lt;/li&gt;&#xa;&lt;li data-start=&quot;785&quot; data-end=&quot;831&quot;&gt;&#xa;&lt;p data-start=&quot;787&quot; data-end=&quot;831&quot;&gt;Использовать примеры качественных ответов.&lt;/p&gt;&#xa;&lt;/li&gt;&#xa;&lt;/ul&gt;&#xa;&lt;p data-start=&quot;833&quot; data-end=&quot;871&quot;&gt;&lt;strong data-start=&quot;833&quot; data-end=&quot;869&quot;&gt;Шаг 5. Диалоговое взаимодействие&lt;/strong&gt;&lt;/p&gt;&#xa;&lt;ul data-start=&quot;872&quot; data-end=&quot;957&quot;&gt;&#xa;&lt;li data-start=&quot;872&quot; data-end=&quot;916&quot;&gt;&#xa;&lt;p data-start=&quot;874&quot; data-end=&quot;916&quot;&gt;Поддержка уточняющих вопросов в диалоге.&lt;/p&gt;&#xa;&lt;/li&gt;&#xa;&lt;li data-start=&quot;917&quot; data-end=&quot;957&quot;&gt;&#xa;&lt;p data-start=&quot;919&quot; data-end=&quot;957&quot;&gt;Автоматические подсказки (саджесты).&lt;/p&gt;&#xa;&lt;/li&gt;&#xa;&lt;/ul&gt;&#xa;&lt;p data-start=&quot;959&quot; data-end=&quot;1000&quot;&gt;&lt;strong data-start=&quot;959&quot; data-end=&quot;998&quot;&gt;Шаг 6. Контроль качества и обучение&lt;/strong&gt;&lt;/p&gt;&#xa;&lt;ul data-start=&quot;1001&quot; data-end=&quot;1234&quot;&gt;&#xa;&lt;li data-start=&quot;1001&quot; data-end=&quot;1055&quot;&gt;&#xa;&lt;p data-start=&quot;1003&quot; data-end=&quot;1055&quot;&gt;Создать эталонный набор вопросов для тестирования.&lt;/p&gt;&#xa;&lt;/li&gt;&#xa;&lt;li data-start=&quot;1056&quot; data-end=&quot;1121&quot;&gt;&#xa;&lt;p data-start=&quot;1058&quot; data-end=&quot;1121&quot;&gt;Внедрить регулярную экспертную оценку и метрики (nDCG и др.).&lt;/p&gt;&#xa;&lt;/li&gt;&#xa;&lt;li data-start=&quot;1122&quot; data-end=&quot;1183&quot;&gt;&#xa;&lt;p data-start=&quot;1124&quot; data-end=&quot;1183&quot;&gt;Использовать обратную связь пользователей для дообучения.&lt;/p&gt;&#xa;&lt;/li&gt;&#xa;&lt;li data-start=&quot;1184&quot; data-end=&quot;1234&quot;&gt;&#xa;&lt;p data-start=&quot;1186&quot; data-end=&quot;1234&quot;&gt;Постепенно внедрять улучшения через A/B тесты.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;" style="text;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="910" y="1130" width="560" height="1990" as="geometry" />
        </mxCell>
        <UserObject label="import json&#xa;import time&#xa;from datetime import datetime&#xa;&#xa;&#xa;from fastapi import Request, status&#xa;from starlette.concurrency import iterate_in_threadpool&#xa;&#xa;&#xa;from aigw_service.context import APP_CTX&#xa;&#xa;&#xa;NON_LOGGED_ENDPOINTS = (&#xa;    &quot;/like&quot;,&#xa;    &quot;/dislike&quot;,&#xa;    &quot;/health&quot;,&#xa;    &quot;/info&quot;,&#xa;    &quot;/openapi.json&quot;,&#xa;    &quot;/docs&quot;,&#xa;)&#xa;&#xa;&#xa;HEADERS_WHITE_LIST_TO_LOG = (&#xa;    &quot;x-trace-id&quot;,&#xa;    &quot;x-request-time&quot;,&#xa;    &quot;x-client-id&quot;,&#xa;    &quot;x-aigw-session-id&quot;,&#xa;    &quot;x-user-id&quot;,&#xa;)&#xa;&#xa;&#xa;&#xa;&#xa;def _get_decoded_body(raw_body: bytes, message_type: str, logger):&#xa;    decoded_body = {}&#xa;    try:&#xa;        decoded_body = json.loads(raw_body.decode())&#xa;    except (json.JSONDecodeError, UnicodeDecodeError):&#xa;        logger.warning(f&quot;{message_type} body is not json&quot;)&#xa;    return decoded_body&#xa;&#xa;&#xa;&#xa;&#xa;async def log_requests(request: Request, call_next):&#xa;    start_time = time.time()&#xa;    logger = APP_CTX.get_logger()&#xa;    request_path = request.url.path&#xa;&#xa;&#xa;    # Достаем заголовки запроса&#xa;    allowed_headers_to_log = ((k, request.headers.get(k)) for k in HEADERS_WHITE_LIST_TO_LOG)&#xa;    headers_to_log = {header_name: header_value for header_name, header_value in allowed_headers_to_log if header_value}&#xa;&#xa;&#xa;    # Устанавливаем контекстные переменные&#xa;    APP_CTX.get_context_vars_container().set_context_vars(&#xa;        x_trace_id=headers_to_log.get(&quot;x-trace-id&quot;, &quot;&quot;),&#xa;        x_request_time=headers_to_log.get(&quot;x-request-time&quot;, &quot;&quot;),&#xa;        x_client_id=headers_to_log.get(&quot;x-client-id&quot;, &quot;&quot;),&#xa;        x_aigw_session_id=headers_to_log.get(&quot;x-aigw-session-id&quot;, &quot;&quot;),&#xa;        x_user_id=headers_to_log.get(&quot;x-user-id&quot;, &quot;&quot;),&#xa;    )&#xa;&#xa;&#xa;    # Логируем получение запроса&#xa;    if request_path in NON_LOGGED_ENDPOINTS:  # Не следует логировать эти эндпоинты&#xa;        response = await call_next(request)&#xa;        logger.debug(f&quot;Processed request for {request_path} with code {response.status_code}&quot;)&#xa;    # Проверка на наличие заголовка x-trace-id в запросе&#xa;    elif headers_to_log.get(&quot;x-trace-id&quot;, None):&#xa;        # Получаем тело запроса&#xa;        raw_request_body = await request.body()&#xa;        request_body_decoded = _get_decoded_body(raw_request_body, &quot;request&quot;, logger)&#xa;        # Логируем, кидаем событие в аудит, кидаем метрику о количестве запросов&#xa;        logger.info(&#xa;            f&quot;Incoming {request.method}-request for {request_path}&quot;,&#xa;            args={&#xa;                &quot;headers&quot;: headers_to_log,&#xa;                &quot;message&quot;: request_body_decoded,&#xa;            },&#xa;            message_type=&quot;request&quot;,&#xa;            path=request_path,&#xa;        )&#xa;        client_id = headers_to_log.get(&quot;x-user-id&quot;, None)&#xa;        if client_id:&#xa;            logger.metric(&#xa;                metric_name=f&quot;aigw_service_user_{client_id}&quot;,&#xa;                metric_value=1,&#xa;            )&#xa;        logger.metric(&#xa;            metric_name=&quot;aigw_service_requests_total&quot;,&#xa;            metric_value=1,&#xa;        )&#xa;        logger.audit(&#xa;            event_name=&quot;BusinessRequestReceived&quot;,&#xa;            event_params=json.dumps(&#xa;                request_body_decoded,&#xa;                ensure_ascii=False,&#xa;            ),&#xa;        )&#xa;&#xa;&#xa;        response = await call_next(request)&#xa;&#xa;&#xa;        # Тело response - это итератор, по которому нельзя пройти повторно.&#xa;        # Один из вариантов решения - это собрать итератор повторно, что и представлено ниже&#xa;        response_body = [chunk async for chunk in response.body_iterator]&#xa;        response.body_iterator = iterate_in_threadpool(iter(response_body))&#xa;&#xa;&#xa;        # Добавляем заголовки ответа&#xa;        headers_to_log[&quot;x-response-time&quot;] = datetime.now(APP_CTX.get_pytz_timezone()).isoformat()&#xa;        for header in headers_to_log:&#xa;            response.headers[header] = headers_to_log[header]&#xa;&#xa;&#xa;        # Логируем ответ приложения и кидаем метрику количества ответов&#xa;        response_body_extracted = response_body[0] if len(response_body) &gt; 0 else b&quot;&quot;&#xa;        decoded_response_body = _get_decoded_body(response_body_extracted, &quot;response&quot;, logger)&#xa;        logger.info(&#xa;            &quot;Outgoing response to client system&quot;,&#xa;            args={&#xa;                &quot;headers&quot;: headers_to_log,&#xa;                &quot;message&quot;: decoded_response_body,&#xa;            },&#xa;            message_type=&quot;response&quot;,&#xa;            path=request_path,&#xa;        )&#xa;        logger.metric(&#xa;            metric_name=&quot;aigw_service_responses_total&quot;,&#xa;            metric_value=1,&#xa;        )&#xa;        logger.audit(&#xa;            event_name=&quot;BusinessRequestFinished&quot;,&#xa;            event_params=json.dumps(&#xa;                decoded_response_body,&#xa;                ensure_ascii=False,&#xa;            ),&#xa;        )&#xa;&#xa;&#xa;        # Логируем время обработки запроса и кидаем метрику скорости ответа&#xa;        processing_time_ms = int(round(time.time() - start_time, 3) * 1000)&#xa;        logger.info(f&quot;Request processing time for {request_path}: {processing_time_ms} ms&quot;)&#xa;        logger.metric(&#xa;            metric_name=&quot;aigw_service_process_duration_ms&quot;,&#xa;            metric_value=processing_time_ms,&#xa;        )&#xa;&#xa;&#xa;        # Кидаем метрику статуса обработки запроса&#xa;        if response.status_code &lt; status.HTTP_400_BAD_REQUEST:&#xa;            logger.metric(&#xa;                metric_name=&quot;aigw_service_request_status_success_total&quot;,&#xa;                metric_value=1,&#xa;            )&#xa;        else:&#xa;            logger.metric(&#xa;                metric_name=&quot;aigw_service_request_status_failure_total&quot;,&#xa;                metric_value=1,&#xa;            )&#xa;    else:&#xa;        # Логируем получение запроса без x-trace-id и обрабатываем его&#xa;        logger.info(f&quot;Incoming {request.method}-request with no id for {request_path}&quot;)&#xa;        response = await call_next(request)&#xa;        logger.info(f&quot;Request with no id for {request_path} processing time: {time.time() - start_time: .3f} s&quot;)&#xa;&#xa;&#xa;    return response&#xa;&#xa;&#xa;&#xa;&#xa;__all__ = [&#xa;    &quot;log_requests&quot;,&#xa;]" link="import json&#xa;import time&#xa;from datetime import datetime&#xa;&#xa;&#xa;from fastapi import Request, status&#xa;from starlette.concurrency import iterate_in_threadpool&#xa;&#xa;&#xa;from aigw_service.context import APP_CTX&#xa;&#xa;&#xa;NON_LOGGED_ENDPOINTS = (&#xa;    &quot;/like&quot;,&#xa;    &quot;/dislike&quot;,&#xa;    &quot;/health&quot;,&#xa;    &quot;/info&quot;,&#xa;    &quot;/openapi.json&quot;,&#xa;    &quot;/docs&quot;,&#xa;)&#xa;&#xa;&#xa;HEADERS_WHITE_LIST_TO_LOG = (&#xa;    &quot;x-trace-id&quot;,&#xa;    &quot;x-request-time&quot;,&#xa;    &quot;x-client-id&quot;,&#xa;    &quot;x-aigw-session-id&quot;,&#xa;    &quot;x-user-id&quot;,&#xa;)&#xa;&#xa;&#xa;&#xa;&#xa;def _get_decoded_body(raw_body: bytes, message_type: str, logger):&#xa;    decoded_body = {}&#xa;    try:&#xa;        decoded_body = json.loads(raw_body.decode())&#xa;    except (json.JSONDecodeError, UnicodeDecodeError):&#xa;        logger.warning(f&quot;{message_type} body is not json&quot;)&#xa;    return decoded_body&#xa;&#xa;&#xa;&#xa;&#xa;async def log_requests(request: Request, call_next):&#xa;    start_time = time.time()&#xa;    logger = APP_CTX.get_logger()&#xa;    request_path = request.url.path&#xa;&#xa;&#xa;    # Достаем заголовки запроса&#xa;    allowed_headers_to_log = ((k, request.headers.get(k)) for k in HEADERS_WHITE_LIST_TO_LOG)&#xa;    headers_to_log = {header_name: header_value for header_name, header_value in allowed_headers_to_log if header_value}&#xa;&#xa;&#xa;    # Устанавливаем контекстные переменные&#xa;    APP_CTX.get_context_vars_container().set_context_vars(&#xa;        x_trace_id=headers_to_log.get(&quot;x-trace-id&quot;, &quot;&quot;),&#xa;        x_request_time=headers_to_log.get(&quot;x-request-time&quot;, &quot;&quot;),&#xa;        x_client_id=headers_to_log.get(&quot;x-client-id&quot;, &quot;&quot;),&#xa;        x_aigw_session_id=headers_to_log.get(&quot;x-aigw-session-id&quot;, &quot;&quot;),&#xa;        x_user_id=headers_to_log.get(&quot;x-user-id&quot;, &quot;&quot;),&#xa;    )&#xa;&#xa;&#xa;    # Логируем получение запроса&#xa;    if request_path in NON_LOGGED_ENDPOINTS:  # Не следует логировать эти эндпоинты&#xa;        response = await call_next(request)&#xa;        logger.debug(f&quot;Processed request for {request_path} with code {response.status_code}&quot;)&#xa;    # Проверка на наличие заголовка x-trace-id в запросе&#xa;    elif headers_to_log.get(&quot;x-trace-id&quot;, None):&#xa;        # Получаем тело запроса&#xa;        raw_request_body = await request.body()&#xa;        request_body_decoded = _get_decoded_body(raw_request_body, &quot;request&quot;, logger)&#xa;        # Логируем, кидаем событие в аудит, кидаем метрику о количестве запросов&#xa;        logger.info(&#xa;            f&quot;Incoming {request.method}-request for {request_path}&quot;,&#xa;            args={&#xa;                &quot;headers&quot;: headers_to_log,&#xa;                &quot;message&quot;: request_body_decoded,&#xa;            },&#xa;            message_type=&quot;request&quot;,&#xa;            path=request_path,&#xa;        )&#xa;        client_id = headers_to_log.get(&quot;x-user-id&quot;, None)&#xa;        if client_id:&#xa;            logger.metric(&#xa;                metric_name=f&quot;aigw_service_user_{client_id}&quot;,&#xa;                metric_value=1,&#xa;            )&#xa;        logger.metric(&#xa;            metric_name=&quot;aigw_service_requests_total&quot;,&#xa;            metric_value=1,&#xa;        )&#xa;        logger.audit(&#xa;            event_name=&quot;BusinessRequestReceived&quot;,&#xa;            event_params=json.dumps(&#xa;                request_body_decoded,&#xa;                ensure_ascii=False,&#xa;            ),&#xa;        )&#xa;&#xa;&#xa;        response = await call_next(request)&#xa;&#xa;&#xa;        # Тело response - это итератор, по которому нельзя пройти повторно.&#xa;        # Один из вариантов решения - это собрать итератор повторно, что и представлено ниже&#xa;        response_body = [chunk async for chunk in response.body_iterator]&#xa;        response.body_iterator = iterate_in_threadpool(iter(response_body))&#xa;&#xa;&#xa;        # Добавляем заголовки ответа&#xa;        headers_to_log[&quot;x-response-time&quot;] = datetime.now(APP_CTX.get_pytz_timezone()).isoformat()&#xa;        for header in headers_to_log:&#xa;            response.headers[header] = headers_to_log[header]&#xa;&#xa;&#xa;        # Логируем ответ приложения и кидаем метрику количества ответов&#xa;        response_body_extracted = response_body[0] if len(response_body) &gt; 0 else b&quot;&quot;&#xa;        decoded_response_body = _get_decoded_body(response_body_extracted, &quot;response&quot;, logger)&#xa;        logger.info(&#xa;            &quot;Outgoing response to client system&quot;,&#xa;            args={&#xa;                &quot;headers&quot;: headers_to_log,&#xa;                &quot;message&quot;: decoded_response_body,&#xa;            },&#xa;            message_type=&quot;response&quot;,&#xa;            path=request_path,&#xa;        )&#xa;        logger.metric(&#xa;            metric_name=&quot;aigw_service_responses_total&quot;,&#xa;            metric_value=1,&#xa;        )&#xa;        logger.audit(&#xa;            event_name=&quot;BusinessRequestFinished&quot;,&#xa;            event_params=json.dumps(&#xa;                decoded_response_body,&#xa;                ensure_ascii=False,&#xa;            ),&#xa;        )&#xa;&#xa;&#xa;        # Логируем время обработки запроса и кидаем метрику скорости ответа&#xa;        processing_time_ms = int(round(time.time() - start_time, 3) * 1000)&#xa;        logger.info(f&quot;Request processing time for {request_path}: {processing_time_ms} ms&quot;)&#xa;        logger.metric(&#xa;            metric_name=&quot;aigw_service_process_duration_ms&quot;,&#xa;            metric_value=processing_time_ms,&#xa;        )&#xa;&#xa;&#xa;        # Кидаем метрику статуса обработки запроса&#xa;        if response.status_code &lt; status.HTTP_400_BAD_REQUEST:&#xa;            logger.metric(&#xa;                metric_name=&quot;aigw_service_request_status_success_total&quot;,&#xa;                metric_value=1,&#xa;            )&#xa;        else:&#xa;            logger.metric(&#xa;                metric_name=&quot;aigw_service_request_status_failure_total&quot;,&#xa;                metric_value=1,&#xa;            )&#xa;    else:&#xa;        # Логируем получение запроса без x-trace-id и обрабатываем его&#xa;        logger.info(f&quot;Incoming {request.method}-request with no id for {request_path}&quot;)&#xa;        response = await call_next(request)&#xa;        logger.info(f&quot;Request with no id for {request_path} processing time: {time.time() - start_time: .3f} s&quot;)&#xa;&#xa;&#xa;    return response&#xa;&#xa;&#xa;&#xa;&#xa;__all__ = [&#xa;    &quot;log_requests&quot;,&#xa;]" id="FwriIrbwdFO0P3CciquX-1">
          <mxCell style="text;whiteSpace=wrap;" vertex="1" parent="1">
            <mxGeometry x="120" y="1470" width="560" height="2670" as="geometry" />
          </mxCell>
        </UserObject>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
