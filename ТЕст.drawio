<mxfile host="app.diagrams.net" agent="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36 SberBrowser/31.0.0.0" version="28.2.5">
  <diagram name="Страница — 1" id="YzAyhXTebkGU_6SpY-bU">
    <mxGraphModel dx="1372" dy="742" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="3300" pageHeight="4681" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <UserObject label="# idp_client.py&#xa;import os&#xa;import uuid&#xa;import time&#xa;import json&#xa;import requests&#xa;from typing import Optional, Tuple, Dict, Any, List&#xa;from requests.adapters import HTTPAdapter, Retry&#xa;&#xa;&#xa;from core.logging.logger_utils import log&#xa;from scenarios.user.user_model import User&#xa;&#xa;&#xa;&#xa;&#xa;# -----------------------------&#xa;# ВСПОМОГАТЕЛЬНЫЕ НАСТРОЙКИ&#xa;# -----------------------------&#xa;DEFAULT_API_BASE = os.getenv(&quot;IDP_GATEWAY_BASE&quot;, &quot;http://localhost:8000&quot;)  # где крутится твой FastAPI&#xa;ENDPOINT_PATH = os.getenv(&quot;IDP_SEARCH_PATH&quot;, &quot;/idp_search&quot;)&#xa;&#xa;&#xa;# Если ваш Depends(common_headers) ожидает определённые заголовки — добавь их в ENV и сюда&#xa;DEFAULT_HEADERS: Dict[str, str] = {&#xa;    &quot;accept&quot;: &quot;application/json&quot;,&#xa;    &quot;Content-Type&quot;: &quot;application/json&quot;,&#xa;    # Примеры корпоративных заголовков — подставь нужные, если требуется:&#xa;    # &quot;X-Request-Source&quot;: os.getenv(&quot;X_REQUEST_SOURCE&quot;, &quot;your-service&quot;),&#xa;    # &quot;X-Auth-Token&quot;: os.getenv(&quot;X_AUTH_TOKEN&quot;, &quot;&quot;),&#xa;}&#xa;&#xa;&#xa;REQUEST_TIMEOUT = float(os.getenv(&quot;IDP_CLIENT_TIMEOUT&quot;, &quot;30&quot;))  # сек.&#xa;RETRY_TOTAL = int(os.getenv(&quot;IDP_CLIENT_RETRY_TOTAL&quot;, &quot;3&quot;))&#xa;RETRY_BACKOFF = float(os.getenv(&quot;IDP_CLIENT_RETRY_BACKOFF&quot;, &quot;0.5&quot;))  # экспоненциальная пауза&#xa;&#xa;&#xa;&#xa;&#xa;def _build_session() -&gt; requests.Session:&#xa;    &quot;&quot;&quot;&#xa;    Готовим requests.Session с умным ретраем (на случай сетевых глюков, 502/503/504).&#xa;    &quot;&quot;&quot;&#xa;    session = requests.Session()&#xa;    retries = Retry(&#xa;        total=RETRY_TOTAL,&#xa;        backoff_factor=RETRY_BACKOFF,&#xa;        status_forcelist=(502, 503, 504),&#xa;        allowed_methods=frozenset([&quot;POST&quot;]),&#xa;        raise_on_status=False,&#xa;    )&#xa;    adapter = HTTPAdapter(max_retries=retries)&#xa;    session.mount(&quot;http://&quot;, adapter)&#xa;    session.mount(&quot;https://&quot;, adapter)&#xa;    return session&#xa;&#xa;&#xa;&#xa;&#xa;def _safe_get(dct: Dict[str, Any], path: List[str], default=None):&#xa;    &quot;&quot;&quot;&#xa;    Безопасно достаём значение из вложенного словаря по пути ключей.&#xa;    &quot;&quot;&quot;&#xa;    cur = dct&#xa;    for key in path:&#xa;        if not isinstance(cur, dict) or key not in cur:&#xa;            return default&#xa;        cur = cur[key]&#xa;    return cur&#xa;&#xa;&#xa;&#xa;&#xa;def _normalize_answer_text(text: str) -&gt; str:&#xa;    &quot;&quot;&quot;&#xa;    Хук на будущее: если когда-либо вернутся inline-ссылки вида [^1^],&#xa;    здесь можно будет подменять их на понятные ярлыки.&#xa;    Сейчас просто возвращаем как есть.&#xa;    &quot;&quot;&quot;&#xa;    return text&#xa;&#xa;&#xa;&#xa;&#xa;def _compose_url(base: str, path: str) -&gt; str:&#xa;    base = base.rstrip(&quot;/&quot;)&#xa;    path = path if path.startswith(&quot;/&quot;) else f&quot;/{path}&quot;&#xa;    return f&quot;{base}{path}&quot;&#xa;&#xa;&#xa;&#xa;&#xa;def run_idp_search(user: User, api_base: Optional[str] = None) -&gt; None:&#xa;    &quot;&quot;&quot;&#xa;    Отправляет вопрос на FastAPI эндпоинт /idp_search и записывает результат в user.variables.&#xa;&#xa;&#xa;    Вход:&#xa;        - user.variables[&#39;IDP_question&#39;] : строка вопроса.&#xa;    Выход:&#xa;        - user.variables[&#39;IDP_answer&#39;]         : текст ответа или текст ошибки.&#xa;        - user.variables[&#39;IDP_external_uuid&#39;]  : uuid запроса (если вернулся).&#xa;        - user.variables[&#39;IDP_response_time&#39;]  : время ответа в секундах (если вернулось).&#xa;&#xa;&#xa;    Исключения не пробрасываем — всё логируем и безопасно сохраняем в user.variables.&#xa;    &quot;&quot;&quot;&#xa;    question = user.variables.get(&quot;IDP_question&quot;, &quot;&quot;)&#xa;    if not isinstance(question, str) or len(question.strip()) &lt; 4:&#xa;        msg = &quot;Вопрос пустой или короче 4 символов — IDP его отклонит согласно модели схем.&quot;&#xa;        log(msg, level=&quot;ERROR&quot;)&#xa;        user.variables.set(&quot;IDP_answer&quot;, msg)&#xa;        return&#xa;&#xa;&#xa;    base = api_base or DEFAULT_API_BASE&#xa;    url = _compose_url(base, ENDPOINT_PATH)&#xa;&#xa;&#xa;    # Можно прокинуть trace-id в заголовки для сквозной трассировки&#xa;    external_uuid = str(uuid.uuid4())&#xa;&#xa;&#xa;    headers = dict(DEFAULT_HEADERS)&#xa;    headers[&quot;X-External-UUID&quot;] = external_uuid  # опционально — если на бэке это используется&#xa;&#xa;&#xa;    payload = {&quot;question&quot;: question}&#xa;&#xa;&#xa;    log(f&quot;IDP_SEARCH ▶ POST {url} | headers={headers} | payload={payload}&quot;)&#xa;&#xa;&#xa;    session = _build_session()&#xa;    t0 = time.perf_counter()&#xa;&#xa;&#xa;    try:&#xa;        resp = session.post(url, headers=headers, data=json.dumps(payload), timeout=REQUEST_TIMEOUT)&#xa;        elapsed = time.perf_counter() - t0&#xa;&#xa;&#xa;        # 200 OK — успешный ответ&#xa;        if resp.status_code == 200:&#xa;            data = resp.json()&#xa;&#xa;&#xa;            answer = _safe_get(data, [&quot;answer&quot;], &quot;&quot;)&#xa;            response_time = _safe_get(data, [&quot;response_time&quot;], elapsed)&#xa;            returned_uuid = _safe_get(data, [&quot;external_uuid&quot;], external_uuid)&#xa;&#xa;&#xa;            normalized_answer = _normalize_answer_text(answer)&#xa;&#xa;&#xa;            log(&#xa;                f&quot;IDP_SEARCH ✔ 200 | time={response_time:.2f}s | uuid={returned_uuid} | &quot;&#xa;                f&quot;answer_preview=&#39;{(normalized_answer or &#39;&#39;)[:180]}...&#39;&quot;,&#xa;                level=&quot;INFO&quot;,&#xa;            )&#xa;&#xa;&#xa;            user.variables.set(&quot;IDP_answer&quot;, normalized_answer or &quot;&quot;)&#xa;            user.variables.set(&quot;IDP_external_uuid&quot;, returned_uuid)&#xa;            user.variables.set(&quot;IDP_response_time&quot;, response_time)&#xa;            return&#xa;&#xa;&#xa;        # 424 — проксируем описание ошибки из тела по вашей схеме IDPErrorResponse&#xa;        if resp.status_code == 424:&#xa;            try:&#xa;                err = resp.json()&#xa;            except Exception:&#xa;                err = {}&#xa;&#xa;&#xa;            err_desc = _safe_get(err, [&quot;error_description&quot;], &quot;Ошибка при обращении к IDP&quot;)&#xa;            err_code = _safe_get(err, [&quot;error_code&quot;], &quot;IDP_REQUEST_ERROR&quot;)&#xa;            response_time = _safe_get(err, [&quot;response_time&quot;], time.perf_counter() - t0)&#xa;&#xa;&#xa;            log(f&quot;IDP_SEARCH ✖ 424 | {err_code}: {err_desc} | time={response_time:.2f}s&quot;, level=&quot;ERROR&quot;)&#xa;&#xa;&#xa;            user.variables.set(&quot;IDP_answer&quot;, f&quot;{err_desc} (код: {err_code})&quot;)&#xa;            user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;            user.variables.set(&quot;IDP_response_time&quot;, response_time)&#xa;            return&#xa;&#xa;&#xa;        # Прочие статусы — максимально информативный лог + тело&#xa;        body_preview = &quot;&quot;&#xa;        try:&#xa;            body_preview = json.dumps(resp.json(), ensure_ascii=False)[:500]&#xa;        except Exception:&#xa;            body_preview = (resp.text or &quot;&quot;)[:500]&#xa;&#xa;&#xa;        log(&#xa;            f&quot;IDP_SEARCH ✖ {resp.status_code} {resp.reason} | body=&#39;{body_preview}&#39;&quot;,&#xa;            level=&quot;ERROR&quot;,&#xa;        )&#xa;&#xa;&#xa;        user.variables.set(&#xa;            &quot;IDP_answer&quot;,&#xa;            f&quot;Ошибка: {resp.status_code} {resp.reason}. Обратитесь к логам сервиса.&quot;,&#xa;        )&#xa;        user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;        user.variables.set(&quot;IDP_response_time&quot;, time.perf_counter() - t0)&#xa;&#xa;&#xa;    except requests.Timeout as e:&#xa;        elapsed = time.perf_counter() - t0&#xa;        log(f&quot;IDP_SEARCH ⏱ timeout after {elapsed:.2f}s: {str(e)}&quot;, level=&quot;ERROR&quot;)&#xa;        user.variables.set(&quot;IDP_answer&quot;, &quot;Timeout при обращении к /idp_search&quot;)&#xa;        user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;        user.variables.set(&quot;IDP_response_time&quot;, elapsed)&#xa;&#xa;&#xa;    except requests.RequestException as e:&#xa;        elapsed = time.perf_counter() - t0&#xa;        log(f&quot;IDP_SEARCH ⚠ network error: {str(e)}&quot;, level=&quot;ERROR&quot;)&#xa;        user.variables.set(&quot;IDP_answer&quot;, &quot;Сетевая ошибка при обращении к /idp_search&quot;)&#xa;        user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;        user.variables.set(&quot;IDP_response_time&quot;, elapsed)&#xa;&#xa;&#xa;    except Exception as e:&#xa;        elapsed = time.perf_counter() - t0&#xa;        log(f&quot;IDP_SEARCH ☠ unexpected error: {str(e)}&quot;, level=&quot;ERROR&quot;)&#xa;        user.variables.set(&quot;IDP_answer&quot;, &quot;Неожиданная ошибка клиента IDP&quot;)&#xa;        user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;        user.variables.set(&quot;IDP_response_time&quot;, elapsed)&#xa;&#xa;&#xa;&#xa;&#xa;# --------------------------------------&#xa;# НЕОБЯЗАТЕЛЬНО: асинхронная версия (httpx)&#xa;# --------------------------------------&#xa;# Используй, если у тебя асинхронный воркер, и хочется не блокировать луп.&#xa;# Поведение и контракты идентичны синхронной версии.&#xa;async def run_idp_search_async(user: User, api_base: Optional[str] = None) -&gt; None:&#xa;    import httpx&#xa;    import asyncio&#xa;&#xa;&#xa;    question = user.variables.get(&quot;IDP_question&quot;, &quot;&quot;)&#xa;    if not isinstance(question, str) or len(question.strip()) &lt; 4:&#xa;        msg = &quot;Вопрос пустой или короче 4 символов — IDP его отклонит согласно модели схем.&quot;&#xa;        log(msg, level=&quot;ERROR&quot;)&#xa;        user.variables.set(&quot;IDP_answer&quot;, msg)&#xa;        return&#xa;&#xa;&#xa;    base = api_base or DEFAULT_API_BASE&#xa;    url = _compose_url(base, ENDPOINT_PATH)&#xa;&#xa;&#xa;    external_uuid = str(uuid.uuid4())&#xa;    headers = dict(DEFAULT_HEADERS)&#xa;    headers[&quot;X-External-UUID&quot;] = external_uuid&#xa;&#xa;&#xa;    payload = {&quot;question&quot;: question}&#xa;    log(f&quot;IDP_SEARCH(async) ▶ POST {url} | headers={headers} | payload={payload}&quot;)&#xa;&#xa;&#xa;    # Ретраи вручную, т.к. httpx не имеет встроенного Retry, как requests+urllib3&#xa;    attempts = RETRY_TOTAL + 1&#xa;    backoff = RETRY_BACKOFF&#xa;&#xa;&#xa;    t0 = time.perf_counter()&#xa;&#xa;&#xa;    async with httpx.AsyncClient(timeout=REQUEST_TIMEOUT) as client:&#xa;        for attempt in range(1, attempts + 1):&#xa;            try:&#xa;                resp = await client.post(url, headers=headers, json=payload)&#xa;                elapsed = time.perf_counter() - t0&#xa;&#xa;&#xa;                if resp.status_code == 200:&#xa;                    data = resp.json()&#xa;                    answer = data.get(&quot;answer&quot;, &quot;&quot;)&#xa;                    response_time = data.get(&quot;response_time&quot;, elapsed)&#xa;                    returned_uuid = data.get(&quot;external_uuid&quot;, external_uuid)&#xa;&#xa;&#xa;                    normalized_answer = _normalize_answer_text(answer)&#xa;                    log(&#xa;                        f&quot;IDP_SEARCH(async) ✔ 200 | time={response_time:.2f}s | uuid={returned_uuid} | &quot;&#xa;                        f&quot;answer_preview=&#39;{(normalized_answer or &#39;&#39;)[:180]}...&#39;&quot;,&#xa;                        level=&quot;INFO&quot;,&#xa;                    )&#xa;                    user.variables.set(&quot;IDP_answer&quot;, normalized_answer or &quot;&quot;)&#xa;                    user.variables.set(&quot;IDP_external_uuid&quot;, returned_uuid)&#xa;                    user.variables.set(&quot;IDP_response_time&quot;, response_time)&#xa;                    return&#xa;&#xa;&#xa;                if resp.status_code == 424:&#xa;                    err = resp.json()&#xa;                    err_desc = err.get(&quot;error_description&quot;, &quot;Ошибка при обращении к IDP&quot;)&#xa;                    err_code = err.get(&quot;error_code&quot;, &quot;IDP_REQUEST_ERROR&quot;)&#xa;                    response_time = err.get(&quot;response_time&quot;, elapsed)&#xa;&#xa;&#xa;                    log(f&quot;IDP_SEARCH(async) ✖ 424 | {err_code}: {err_desc} | time={response_time:.2f}s&quot;, level=&quot;ERROR&quot;)&#xa;                    user.variables.set(&quot;IDP_answer&quot;, f&quot;{err_desc} (код: {err_code})&quot;)&#xa;                    user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;                    user.variables.set(&quot;IDP_response_time&quot;, response_time)&#xa;                    return&#xa;&#xa;&#xa;                # На 502/503/504 поделаем ретраи&#xa;                if resp.status_code in (502, 503, 504) and attempt &lt; attempts:&#xa;                    log(f&quot;IDP_SEARCH(async) ↻ retry {attempt}/{attempts-1} after {backoff:.1f}s (status {resp.status_code})&quot;)&#xa;                    await asyncio.sleep(backoff)&#xa;                    backoff *= 2&#xa;                    continue&#xa;&#xa;&#xa;                # Иначе — ошибка без ретрая&#xa;                body_preview = &quot;&quot;&#xa;                try:&#xa;                    body_preview = json.dumps(resp.json(), ensure_ascii=False)[:500]&#xa;                except Exception:&#xa;                    body_preview = (resp.text or &quot;&quot;)[:500]&#xa;&#xa;&#xa;                log(&#xa;                    f&quot;IDP_SEARCH(async) ✖ {resp.status_code} {resp.reason_phrase} | body=&#39;{body_preview}&#39;&quot;,&#xa;                    level=&quot;ERROR&quot;,&#xa;                )&#xa;                user.variables.set(&#xa;                    &quot;IDP_answer&quot;,&#xa;                    f&quot;Ошибка: {resp.status_code} {resp.reason_phrase}. Обратитесь к логам сервиса.&quot;,&#xa;                )&#xa;                user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;                user.variables.set(&quot;IDP_response_time&quot;, elapsed)&#xa;                return&#xa;&#xa;&#xa;            except (httpx.TimeoutException, httpx.TransportError) as e:&#xa;                if attempt &lt; attempts:&#xa;                    log(f&quot;IDP_SEARCH(async) ↻ retry {attempt}/{attempts-1} after {backoff:.1f}s due to network error: {e}&quot;)&#xa;                    await asyncio.sleep(backoff)&#xa;                    backoff *= 2&#xa;                    continue&#xa;&#xa;&#xa;                elapsed = time.perf_counter() - t0&#xa;                log(f&quot;IDP_SEARCH(async) ⚠ network/timeout error: {str(e)}&quot;, level=&quot;ERROR&quot;)&#xa;                user.variables.set(&quot;IDP_answer&quot;, &quot;Сетевая ошибка при обращении к /idp_search&quot;)&#xa;                user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;                user.variables.set(&quot;IDP_response_time&quot;, elapsed)&#xa;                return&#xa;&#xa;&#xa;&#xa;&#xa;if __name__ == &quot;__main__&quot;:&#xa;    # Пример запуска как у тебя, но через новый клиент&#xa;    questions = [&#xa;        &quot;Какие манипуляции с долгом возможны в отчетности?&quot;,&#xa;        &quot;По какому участнику сделки требуется построение прогноза движения денежных средств при установлении ИР на Консолидированную Группу?&quot;,&#xa;        &quot;На какой срок строятся будущие денежные потоки?&quot;,&#xa;        &quot;Как определить, что деятельность носит сезонный характер?&quot;,&#xa;        &quot;Можно ли строить будущие денежные потоки в иностранной валюте?&quot;,&#xa;        &quot;Относится ли к прочим изменениям увеличение срока действующей банковской гарантии?&quot;,&#xa;        &quot;Требуется ли проверка Fraud-риска по техническим изменениям?&quot;,&#xa;        &quot;Является ли прочим изменением продление периода выборки по сделке УФН?&quot;,&#xa;        &quot;Финансирует ли Банк казино?&quot;,&#xa;        &quot;Особенности финансирования по договорам простого товарищества&quot;,&#xa;        &quot;Может ли банк финансировать некоммерческие организации?&quot;,&#xa;    ]&#xa;&#xa;&#xa;    # Импорт твоей модели User остаётся прежним.&#xa;    # Ниже — простая заглушка. В реальном коде у тебя уже есть инстанс user.&#xa;    class _VarStore(dict):&#xa;        def set(self, k, v):&#xa;            self[k] = v&#xa;&#xa;&#xa;    class _User:&#xa;        def __init__(self):&#xa;            self.variables = _VarStore()&#xa;&#xa;&#xa;    for q in questions:&#xa;        u = _User()&#xa;        u.variables.set(&quot;IDP_question&quot;, q)&#xa;        run_idp_search(u)&#xa;        print(f&quot;Q: {q}\nA: {u.variables.get(&#39;IDP_answer&#39;)}\nUUID: {u.variables.get(&#39;IDP_external_uuid&#39;)}, &quot;&#xa;              f&quot;Time: {u.variables.get(&#39;IDP_response_time&#39;)}s\n{&#39;-&#39;*80}&quot;)" link="# idp_client.py&#xa;import os&#xa;import uuid&#xa;import time&#xa;import json&#xa;import requests&#xa;from typing import Optional, Tuple, Dict, Any, List&#xa;from requests.adapters import HTTPAdapter, Retry&#xa;&#xa;&#xa;from core.logging.logger_utils import log&#xa;from scenarios.user.user_model import User&#xa;&#xa;&#xa;&#xa;&#xa;# -----------------------------&#xa;# ВСПОМОГАТЕЛЬНЫЕ НАСТРОЙКИ&#xa;# -----------------------------&#xa;DEFAULT_API_BASE = os.getenv(&quot;IDP_GATEWAY_BASE&quot;, &quot;http://localhost:8000&quot;)  # где крутится твой FastAPI&#xa;ENDPOINT_PATH = os.getenv(&quot;IDP_SEARCH_PATH&quot;, &quot;/idp_search&quot;)&#xa;&#xa;&#xa;# Если ваш Depends(common_headers) ожидает определённые заголовки — добавь их в ENV и сюда&#xa;DEFAULT_HEADERS: Dict[str, str] = {&#xa;    &quot;accept&quot;: &quot;application/json&quot;,&#xa;    &quot;Content-Type&quot;: &quot;application/json&quot;,&#xa;    # Примеры корпоративных заголовков — подставь нужные, если требуется:&#xa;    # &quot;X-Request-Source&quot;: os.getenv(&quot;X_REQUEST_SOURCE&quot;, &quot;your-service&quot;),&#xa;    # &quot;X-Auth-Token&quot;: os.getenv(&quot;X_AUTH_TOKEN&quot;, &quot;&quot;),&#xa;}&#xa;&#xa;&#xa;REQUEST_TIMEOUT = float(os.getenv(&quot;IDP_CLIENT_TIMEOUT&quot;, &quot;30&quot;))  # сек.&#xa;RETRY_TOTAL = int(os.getenv(&quot;IDP_CLIENT_RETRY_TOTAL&quot;, &quot;3&quot;))&#xa;RETRY_BACKOFF = float(os.getenv(&quot;IDP_CLIENT_RETRY_BACKOFF&quot;, &quot;0.5&quot;))  # экспоненциальная пауза&#xa;&#xa;&#xa;&#xa;&#xa;def _build_session() -&gt; requests.Session:&#xa;    &quot;&quot;&quot;&#xa;    Готовим requests.Session с умным ретраем (на случай сетевых глюков, 502/503/504).&#xa;    &quot;&quot;&quot;&#xa;    session = requests.Session()&#xa;    retries = Retry(&#xa;        total=RETRY_TOTAL,&#xa;        backoff_factor=RETRY_BACKOFF,&#xa;        status_forcelist=(502, 503, 504),&#xa;        allowed_methods=frozenset([&quot;POST&quot;]),&#xa;        raise_on_status=False,&#xa;    )&#xa;    adapter = HTTPAdapter(max_retries=retries)&#xa;    session.mount(&quot;http://&quot;, adapter)&#xa;    session.mount(&quot;https://&quot;, adapter)&#xa;    return session&#xa;&#xa;&#xa;&#xa;&#xa;def _safe_get(dct: Dict[str, Any], path: List[str], default=None):&#xa;    &quot;&quot;&quot;&#xa;    Безопасно достаём значение из вложенного словаря по пути ключей.&#xa;    &quot;&quot;&quot;&#xa;    cur = dct&#xa;    for key in path:&#xa;        if not isinstance(cur, dict) or key not in cur:&#xa;            return default&#xa;        cur = cur[key]&#xa;    return cur&#xa;&#xa;&#xa;&#xa;&#xa;def _normalize_answer_text(text: str) -&gt; str:&#xa;    &quot;&quot;&quot;&#xa;    Хук на будущее: если когда-либо вернутся inline-ссылки вида [^1^],&#xa;    здесь можно будет подменять их на понятные ярлыки.&#xa;    Сейчас просто возвращаем как есть.&#xa;    &quot;&quot;&quot;&#xa;    return text&#xa;&#xa;&#xa;&#xa;&#xa;def _compose_url(base: str, path: str) -&gt; str:&#xa;    base = base.rstrip(&quot;/&quot;)&#xa;    path = path if path.startswith(&quot;/&quot;) else f&quot;/{path}&quot;&#xa;    return f&quot;{base}{path}&quot;&#xa;&#xa;&#xa;&#xa;&#xa;def run_idp_search(user: User, api_base: Optional[str] = None) -&gt; None:&#xa;    &quot;&quot;&quot;&#xa;    Отправляет вопрос на FastAPI эндпоинт /idp_search и записывает результат в user.variables.&#xa;&#xa;&#xa;    Вход:&#xa;        - user.variables[&#39;IDP_question&#39;] : строка вопроса.&#xa;    Выход:&#xa;        - user.variables[&#39;IDP_answer&#39;]         : текст ответа или текст ошибки.&#xa;        - user.variables[&#39;IDP_external_uuid&#39;]  : uuid запроса (если вернулся).&#xa;        - user.variables[&#39;IDP_response_time&#39;]  : время ответа в секундах (если вернулось).&#xa;&#xa;&#xa;    Исключения не пробрасываем — всё логируем и безопасно сохраняем в user.variables.&#xa;    &quot;&quot;&quot;&#xa;    question = user.variables.get(&quot;IDP_question&quot;, &quot;&quot;)&#xa;    if not isinstance(question, str) or len(question.strip()) &lt; 4:&#xa;        msg = &quot;Вопрос пустой или короче 4 символов — IDP его отклонит согласно модели схем.&quot;&#xa;        log(msg, level=&quot;ERROR&quot;)&#xa;        user.variables.set(&quot;IDP_answer&quot;, msg)&#xa;        return&#xa;&#xa;&#xa;    base = api_base or DEFAULT_API_BASE&#xa;    url = _compose_url(base, ENDPOINT_PATH)&#xa;&#xa;&#xa;    # Можно прокинуть trace-id в заголовки для сквозной трассировки&#xa;    external_uuid = str(uuid.uuid4())&#xa;&#xa;&#xa;    headers = dict(DEFAULT_HEADERS)&#xa;    headers[&quot;X-External-UUID&quot;] = external_uuid  # опционально — если на бэке это используется&#xa;&#xa;&#xa;    payload = {&quot;question&quot;: question}&#xa;&#xa;&#xa;    log(f&quot;IDP_SEARCH ▶ POST {url} | headers={headers} | payload={payload}&quot;)&#xa;&#xa;&#xa;    session = _build_session()&#xa;    t0 = time.perf_counter()&#xa;&#xa;&#xa;    try:&#xa;        resp = session.post(url, headers=headers, data=json.dumps(payload), timeout=REQUEST_TIMEOUT)&#xa;        elapsed = time.perf_counter() - t0&#xa;&#xa;&#xa;        # 200 OK — успешный ответ&#xa;        if resp.status_code == 200:&#xa;            data = resp.json()&#xa;&#xa;&#xa;            answer = _safe_get(data, [&quot;answer&quot;], &quot;&quot;)&#xa;            response_time = _safe_get(data, [&quot;response_time&quot;], elapsed)&#xa;            returned_uuid = _safe_get(data, [&quot;external_uuid&quot;], external_uuid)&#xa;&#xa;&#xa;            normalized_answer = _normalize_answer_text(answer)&#xa;&#xa;&#xa;            log(&#xa;                f&quot;IDP_SEARCH ✔ 200 | time={response_time:.2f}s | uuid={returned_uuid} | &quot;&#xa;                f&quot;answer_preview=&#39;{(normalized_answer or &#39;&#39;)[:180]}...&#39;&quot;,&#xa;                level=&quot;INFO&quot;,&#xa;            )&#xa;&#xa;&#xa;            user.variables.set(&quot;IDP_answer&quot;, normalized_answer or &quot;&quot;)&#xa;            user.variables.set(&quot;IDP_external_uuid&quot;, returned_uuid)&#xa;            user.variables.set(&quot;IDP_response_time&quot;, response_time)&#xa;            return&#xa;&#xa;&#xa;        # 424 — проксируем описание ошибки из тела по вашей схеме IDPErrorResponse&#xa;        if resp.status_code == 424:&#xa;            try:&#xa;                err = resp.json()&#xa;            except Exception:&#xa;                err = {}&#xa;&#xa;&#xa;            err_desc = _safe_get(err, [&quot;error_description&quot;], &quot;Ошибка при обращении к IDP&quot;)&#xa;            err_code = _safe_get(err, [&quot;error_code&quot;], &quot;IDP_REQUEST_ERROR&quot;)&#xa;            response_time = _safe_get(err, [&quot;response_time&quot;], time.perf_counter() - t0)&#xa;&#xa;&#xa;            log(f&quot;IDP_SEARCH ✖ 424 | {err_code}: {err_desc} | time={response_time:.2f}s&quot;, level=&quot;ERROR&quot;)&#xa;&#xa;&#xa;            user.variables.set(&quot;IDP_answer&quot;, f&quot;{err_desc} (код: {err_code})&quot;)&#xa;            user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;            user.variables.set(&quot;IDP_response_time&quot;, response_time)&#xa;            return&#xa;&#xa;&#xa;        # Прочие статусы — максимально информативный лог + тело&#xa;        body_preview = &quot;&quot;&#xa;        try:&#xa;            body_preview = json.dumps(resp.json(), ensure_ascii=False)[:500]&#xa;        except Exception:&#xa;            body_preview = (resp.text or &quot;&quot;)[:500]&#xa;&#xa;&#xa;        log(&#xa;            f&quot;IDP_SEARCH ✖ {resp.status_code} {resp.reason} | body=&#39;{body_preview}&#39;&quot;,&#xa;            level=&quot;ERROR&quot;,&#xa;        )&#xa;&#xa;&#xa;        user.variables.set(&#xa;            &quot;IDP_answer&quot;,&#xa;            f&quot;Ошибка: {resp.status_code} {resp.reason}. Обратитесь к логам сервиса.&quot;,&#xa;        )&#xa;        user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;        user.variables.set(&quot;IDP_response_time&quot;, time.perf_counter() - t0)&#xa;&#xa;&#xa;    except requests.Timeout as e:&#xa;        elapsed = time.perf_counter() - t0&#xa;        log(f&quot;IDP_SEARCH ⏱ timeout after {elapsed:.2f}s: {str(e)}&quot;, level=&quot;ERROR&quot;)&#xa;        user.variables.set(&quot;IDP_answer&quot;, &quot;Timeout при обращении к /idp_search&quot;)&#xa;        user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;        user.variables.set(&quot;IDP_response_time&quot;, elapsed)&#xa;&#xa;&#xa;    except requests.RequestException as e:&#xa;        elapsed = time.perf_counter() - t0&#xa;        log(f&quot;IDP_SEARCH ⚠ network error: {str(e)}&quot;, level=&quot;ERROR&quot;)&#xa;        user.variables.set(&quot;IDP_answer&quot;, &quot;Сетевая ошибка при обращении к /idp_search&quot;)&#xa;        user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;        user.variables.set(&quot;IDP_response_time&quot;, elapsed)&#xa;&#xa;&#xa;    except Exception as e:&#xa;        elapsed = time.perf_counter() - t0&#xa;        log(f&quot;IDP_SEARCH ☠ unexpected error: {str(e)}&quot;, level=&quot;ERROR&quot;)&#xa;        user.variables.set(&quot;IDP_answer&quot;, &quot;Неожиданная ошибка клиента IDP&quot;)&#xa;        user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;        user.variables.set(&quot;IDP_response_time&quot;, elapsed)&#xa;&#xa;&#xa;&#xa;&#xa;# --------------------------------------&#xa;# НЕОБЯЗАТЕЛЬНО: асинхронная версия (httpx)&#xa;# --------------------------------------&#xa;# Используй, если у тебя асинхронный воркер, и хочется не блокировать луп.&#xa;# Поведение и контракты идентичны синхронной версии.&#xa;async def run_idp_search_async(user: User, api_base: Optional[str] = None) -&gt; None:&#xa;    import httpx&#xa;    import asyncio&#xa;&#xa;&#xa;    question = user.variables.get(&quot;IDP_question&quot;, &quot;&quot;)&#xa;    if not isinstance(question, str) or len(question.strip()) &lt; 4:&#xa;        msg = &quot;Вопрос пустой или короче 4 символов — IDP его отклонит согласно модели схем.&quot;&#xa;        log(msg, level=&quot;ERROR&quot;)&#xa;        user.variables.set(&quot;IDP_answer&quot;, msg)&#xa;        return&#xa;&#xa;&#xa;    base = api_base or DEFAULT_API_BASE&#xa;    url = _compose_url(base, ENDPOINT_PATH)&#xa;&#xa;&#xa;    external_uuid = str(uuid.uuid4())&#xa;    headers = dict(DEFAULT_HEADERS)&#xa;    headers[&quot;X-External-UUID&quot;] = external_uuid&#xa;&#xa;&#xa;    payload = {&quot;question&quot;: question}&#xa;    log(f&quot;IDP_SEARCH(async) ▶ POST {url} | headers={headers} | payload={payload}&quot;)&#xa;&#xa;&#xa;    # Ретраи вручную, т.к. httpx не имеет встроенного Retry, как requests+urllib3&#xa;    attempts = RETRY_TOTAL + 1&#xa;    backoff = RETRY_BACKOFF&#xa;&#xa;&#xa;    t0 = time.perf_counter()&#xa;&#xa;&#xa;    async with httpx.AsyncClient(timeout=REQUEST_TIMEOUT) as client:&#xa;        for attempt in range(1, attempts + 1):&#xa;            try:&#xa;                resp = await client.post(url, headers=headers, json=payload)&#xa;                elapsed = time.perf_counter() - t0&#xa;&#xa;&#xa;                if resp.status_code == 200:&#xa;                    data = resp.json()&#xa;                    answer = data.get(&quot;answer&quot;, &quot;&quot;)&#xa;                    response_time = data.get(&quot;response_time&quot;, elapsed)&#xa;                    returned_uuid = data.get(&quot;external_uuid&quot;, external_uuid)&#xa;&#xa;&#xa;                    normalized_answer = _normalize_answer_text(answer)&#xa;                    log(&#xa;                        f&quot;IDP_SEARCH(async) ✔ 200 | time={response_time:.2f}s | uuid={returned_uuid} | &quot;&#xa;                        f&quot;answer_preview=&#39;{(normalized_answer or &#39;&#39;)[:180]}...&#39;&quot;,&#xa;                        level=&quot;INFO&quot;,&#xa;                    )&#xa;                    user.variables.set(&quot;IDP_answer&quot;, normalized_answer or &quot;&quot;)&#xa;                    user.variables.set(&quot;IDP_external_uuid&quot;, returned_uuid)&#xa;                    user.variables.set(&quot;IDP_response_time&quot;, response_time)&#xa;                    return&#xa;&#xa;&#xa;                if resp.status_code == 424:&#xa;                    err = resp.json()&#xa;                    err_desc = err.get(&quot;error_description&quot;, &quot;Ошибка при обращении к IDP&quot;)&#xa;                    err_code = err.get(&quot;error_code&quot;, &quot;IDP_REQUEST_ERROR&quot;)&#xa;                    response_time = err.get(&quot;response_time&quot;, elapsed)&#xa;&#xa;&#xa;                    log(f&quot;IDP_SEARCH(async) ✖ 424 | {err_code}: {err_desc} | time={response_time:.2f}s&quot;, level=&quot;ERROR&quot;)&#xa;                    user.variables.set(&quot;IDP_answer&quot;, f&quot;{err_desc} (код: {err_code})&quot;)&#xa;                    user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;                    user.variables.set(&quot;IDP_response_time&quot;, response_time)&#xa;                    return&#xa;&#xa;&#xa;                # На 502/503/504 поделаем ретраи&#xa;                if resp.status_code in (502, 503, 504) and attempt &lt; attempts:&#xa;                    log(f&quot;IDP_SEARCH(async) ↻ retry {attempt}/{attempts-1} after {backoff:.1f}s (status {resp.status_code})&quot;)&#xa;                    await asyncio.sleep(backoff)&#xa;                    backoff *= 2&#xa;                    continue&#xa;&#xa;&#xa;                # Иначе — ошибка без ретрая&#xa;                body_preview = &quot;&quot;&#xa;                try:&#xa;                    body_preview = json.dumps(resp.json(), ensure_ascii=False)[:500]&#xa;                except Exception:&#xa;                    body_preview = (resp.text or &quot;&quot;)[:500]&#xa;&#xa;&#xa;                log(&#xa;                    f&quot;IDP_SEARCH(async) ✖ {resp.status_code} {resp.reason_phrase} | body=&#39;{body_preview}&#39;&quot;,&#xa;                    level=&quot;ERROR&quot;,&#xa;                )&#xa;                user.variables.set(&#xa;                    &quot;IDP_answer&quot;,&#xa;                    f&quot;Ошибка: {resp.status_code} {resp.reason_phrase}. Обратитесь к логам сервиса.&quot;,&#xa;                )&#xa;                user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;                user.variables.set(&quot;IDP_response_time&quot;, elapsed)&#xa;                return&#xa;&#xa;&#xa;            except (httpx.TimeoutException, httpx.TransportError) as e:&#xa;                if attempt &lt; attempts:&#xa;                    log(f&quot;IDP_SEARCH(async) ↻ retry {attempt}/{attempts-1} after {backoff:.1f}s due to network error: {e}&quot;)&#xa;                    await asyncio.sleep(backoff)&#xa;                    backoff *= 2&#xa;                    continue&#xa;&#xa;&#xa;                elapsed = time.perf_counter() - t0&#xa;                log(f&quot;IDP_SEARCH(async) ⚠ network/timeout error: {str(e)}&quot;, level=&quot;ERROR&quot;)&#xa;                user.variables.set(&quot;IDP_answer&quot;, &quot;Сетевая ошибка при обращении к /idp_search&quot;)&#xa;                user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;                user.variables.set(&quot;IDP_response_time&quot;, elapsed)&#xa;                return&#xa;&#xa;&#xa;&#xa;&#xa;if __name__ == &quot;__main__&quot;:&#xa;    # Пример запуска как у тебя, но через новый клиент&#xa;    questions = [&#xa;        &quot;Какие манипуляции с долгом возможны в отчетности?&quot;,&#xa;        &quot;По какому участнику сделки требуется построение прогноза движения денежных средств при установлении ИР на Консолидированную Группу?&quot;,&#xa;        &quot;На какой срок строятся будущие денежные потоки?&quot;,&#xa;        &quot;Как определить, что деятельность носит сезонный характер?&quot;,&#xa;        &quot;Можно ли строить будущие денежные потоки в иностранной валюте?&quot;,&#xa;        &quot;Относится ли к прочим изменениям увеличение срока действующей банковской гарантии?&quot;,&#xa;        &quot;Требуется ли проверка Fraud-риска по техническим изменениям?&quot;,&#xa;        &quot;Является ли прочим изменением продление периода выборки по сделке УФН?&quot;,&#xa;        &quot;Финансирует ли Банк казино?&quot;,&#xa;        &quot;Особенности финансирования по договорам простого товарищества&quot;,&#xa;        &quot;Может ли банк финансировать некоммерческие организации?&quot;,&#xa;    ]&#xa;&#xa;&#xa;    # Импорт твоей модели User остаётся прежним.&#xa;    # Ниже — простая заглушка. В реальном коде у тебя уже есть инстанс user.&#xa;    class _VarStore(dict):&#xa;        def set(self, k, v):&#xa;            self[k] = v&#xa;&#xa;&#xa;    class _User:&#xa;        def __init__(self):&#xa;            self.variables = _VarStore()&#xa;&#xa;&#xa;    for q in questions:&#xa;        u = _User()&#xa;        u.variables.set(&quot;IDP_question&quot;, q)&#xa;        run_idp_search(u)&#xa;        print(f&quot;Q: {q}\nA: {u.variables.get(&#39;IDP_answer&#39;)}\nUUID: {u.variables.get(&#39;IDP_external_uuid&#39;)}, &quot;&#xa;              f&quot;Time: {u.variables.get(&#39;IDP_response_time&#39;)}s\n{&#39;-&#39;*80}&quot;)" id="xQ9-_gr5QTslfE1LpaSg-1">
          <mxCell style="text;whiteSpace=wrap;" parent="1" vertex="1">
            <mxGeometry x="1710" y="480" width="560" height="6030" as="geometry" />
          </mxCell>
        </UserObject>
        <UserObject label="from datetime import datetime, timezone, timedelta&#xa;&#xa;&#xa;def request_time_header(offset_hours: int = 3) -&gt; str:&#xa;    &quot;&quot;&quot;Возвращает строку формата &#39;Request-Time: 2025-08-25T22:58:32.469340+03:00&#39;.&quot;&quot;&quot;&#xa;    tz = timezone(timedelta(hours=offset_hours))&#xa;    now = datetime.now(tz)  # TZ-aware&#xa;    # isoformat уже включает оффсет как +HH:MM, микросекунды идут по умолчанию&#xa;    return f&quot;Request-Time: {now.isoformat()}&quot;" link="from datetime import datetime, timezone, timedelta&#xa;&#xa;&#xa;def request_time_header(offset_hours: int = 3) -&gt; str:&#xa;    &quot;&quot;&quot;Возвращает строку формата &#39;Request-Time: 2025-08-25T22:58:32.469340+03:00&#39;.&quot;&quot;&quot;&#xa;    tz = timezone(timedelta(hours=offset_hours))&#xa;    now = datetime.now(tz)  # TZ-aware&#xa;    # isoformat уже включает оффсет как +HH:MM, микросекунды идут по умолчанию&#xa;    return f&quot;Request-Time: {now.isoformat()}&quot;" id="xQ9-_gr5QTslfE1LpaSg-2">
          <mxCell style="text;whiteSpace=wrap;" parent="1" vertex="1">
            <mxGeometry x="1460" y="700" width="520" height="150" as="geometry" />
          </mxCell>
        </UserObject>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
