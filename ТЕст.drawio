<mxfile host="app.diagrams.net" agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36" version="28.2.5">
  <diagram name="Страница — 1" id="YzAyhXTebkGU_6SpY-bU">
    <mxGraphModel dx="1152" dy="692" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="3300" pageHeight="4681" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <UserObject label="20734976@sigma.sbrf.ru@SZB-WSN-0002258:~/kib-vas-agent/kib-vas-agent$ poetry run examples/gigachat_connect_test.py &#xa;&#xa;&#xa;[Errno 13] Permission denied: &#39;examples/gigachat_connect_test.py&#39;" link="20734976@sigma.sbrf.ru@SZB-WSN-0002258:~/kib-vas-agent/kib-vas-agent$ poetry run examples/gigachat_connect_test.py &#xa;&#xa;&#xa;[Errno 13] Permission denied: &#39;examples/gigachat_connect_test.py&#39;" id="DSNMYpRrBqVaP7X5KKwe-1">
          <mxCell style="text;whiteSpace=wrap;" parent="1" vertex="1">
            <mxGeometry x="1050" y="180" width="560" height="100" as="geometry" />
          </mxCell>
        </UserObject>
        <UserObject label="import uuid&#xa;import os&#xa;import re&#xa;import requests&#xa;from datetime import datetime&#xa;from core.logging.logger_utils import log&#xa;from scenarios.user.user_model import User&#xa;&#xa;&#xa;&#xa;&#xa;def run_request(user: User, service_id: str = &quot;faq&quot;) -&gt; None:&#xa;    &quot;&quot;&quot;Отправляет запрос к серверу в соответствии с новым форматом&quot;&quot;&quot;&#xa;    HEADERS = {&#xa;        &#39;accept&#39;: &#39;application/json&#39;,&#xa;        &#39;Content-Type&#39;: &#39;application/json&#39;,&#xa;    }&#xa;    external_uuid = str(uuid.uuid4())&#xa;    SOURCE_ID = os.getenv(&#39;SOURCE_ID&#39;, &#39;957ec5e0-a331-4da8-9fa7-15a1c4d86035&#39;)&#xa;    INDEX_ID_FAQ = os.getenv(&#39;INDEX_ID&#39;, &#39;9870147f-a646-4421-aa96-aa8960c821fb_dkpp_index_faq_0_1_0&#39;)&#xa;    INDEX_ID_SOURCES = os.getenv(&#39;INDEX_ID_SOURCES&#39;, &#39;9870147f-a646-4421-aa96-aa8960c821fb_dkpp_index_nofaq_0_2_1&#39;)&#xa;    URL = os.getenv(&#39;IDP_API&#39;, &#39;sm.apps.dev-terra000003-ids.ocp.delta.sbrf.ru&#39;)&#xa;    MODEL_NAME = &quot;GigaChat-2-Max&quot;&#xa;&#xa;&#xa;    uri = r&quot;http://&quot; + URL + r&quot;/sync/skill/universal_search&quot;&#xa;&#xa;&#xa;        &#xa;    search_config = {&#xa;    &quot;agent_type&quot;: &quot;universal&quot;,&#xa;    &quot;agent_configuration&quot;: {&#xa;        &quot;index_type&quot;: &quot;opensearch&quot;,&#xa;        &quot;data_sources&quot;: [&#xa;            {&#xa;                &quot;index_id&quot;: INDEX_ID_SOURCES&#xa;            }&#xa;        ],&#xa;        &quot;data_sources_faq&quot;: [&#xa;            {&#xa;                &quot;index_id&quot;: INDEX_ID_FAQ&#xa;            }&#xa;        ],&#xa;        &quot;query_rewriter&quot;: {&#xa;            &quot;enabled&quot;: False&#xa;        },&#xa;        &quot;reranker&quot;: {&#xa;            &quot;enabled&quot;: False&#xa;        },&#xa;        &quot;reranker_faq&quot;: {&#xa;            &quot;enabled&quot;: False&#xa;        },&#xa;        &quot;retriever&quot;: {&#xa;            &quot;bm25_weight&quot;: 0.3,&#xa;            &quot;global_size&quot;: 100,&#xa;            &quot;size&quot;: 10,&#xa;            &quot;embedder&quot;: {&#xa;                &quot;model_name&quot;: &quot;gigachat&quot;&#xa;            }&#xa;        },&#xa;        &quot;retriever_faq&quot;: {&#xa;            &quot;bm25_weight&quot;: 0.2,&#xa;            &quot;global_size&quot;: 100,&#xa;            &quot;size&quot;: 10,&#xa;            &quot;embedder&quot;: {&#xa;                &quot;model_name&quot;: &quot;gigachat&quot;&#xa;            }&#xa;        },&#xa;        &quot;context_expansion&quot;: {&#xa;            &quot;enabled&quot;: False,&#xa;            &quot;chapter_aggregation&quot;: True,&#xa;            &quot;max_tokens&quot;: 2000&#xa;        },&#xa;        &quot;qa&quot;: {&#xa;            &quot;enabled&quot;: True,&#xa;            &quot;qa_scenario&quot;: &quot;stuff&quot;,&#xa;            &quot;model_name&quot;: MODEL_NAME,&#xa;            &quot;temperature&quot;: 0.1,&#xa;            &quot;top_p&quot;: 0,&#xa;            &quot;repetition_penalty&quot;: 1&#xa;        },&#xa;        &quot;sources&quot;: {&#xa;            &quot;enabled&quot;: True,&#xa;            &quot;source_type&quot;: &quot;passage&quot;&#xa;        },&#xa;        &quot;inline_sources&quot;: {&#xa;            &quot;enabled&quot;: True,&#xa;            &quot;format&quot;: &quot;index_caret&quot;,&#xa;            &quot;source_type&quot;: &quot;passage&quot;&#xa;        }&#xa;    }&#xa;}&#xa;&#xa;&#xa;&#xa;&#xa;    chat = {&#xa;        &quot;request_type&quot;: &quot;chat&quot;,&#xa;        &quot;request&quot;: {&#xa;            &quot;messages&quot;: [&#xa;            {&#xa;                &quot;role&quot;: &quot;user&quot;,&#xa;                &quot;content&quot;: user.variables.get(&#39;IDP_question&#39;, &#39;&#39;),&#xa;            }&#xa;        ],&#xa;        }&#xa;    }&#xa;&#xa;&#xa;    request_body = {&#xa;        &quot;meta&quot;: {&quot;external_uuid&quot;: external_uuid, &quot;source_uuid&quot;: SOURCE_ID},&#xa;        &quot;message&quot;: chat,&#xa;        &quot;path&quot;: &quot;/predict&quot;,&#xa;        &quot;timeout&quot;: 600,&#xa;        &quot;configuration&quot;: search_config&#xa;    }&#xa;&#xa;&#xa;    try:&#xa;        log(f&quot;ПОПЫТКА ОТПРАВИТЬ ЗАПРОС НА УНИВЕРСАЛЬНЫЙ СКИЛЛ IDP {uri}, {str(HEADERS)}, {str(request_body)}&quot;)&#xa;        response = requests.post(&#xa;            uri,&#xa;            headers=HEADERS,&#xa;            json=request_body,&#xa;            verify=True&#xa;        )&#xa;&#xa;&#xa;        ## Замена численных источников на названия документов&#xa;&#xa;&#xa;        revert_replacements = {&#xa;            &#39;_SPACE_&#39;: &#39; &#39;,&#xa;            &#39;_COMMA_&#39;: &#39;,&#39;,&#xa;            &#39;_DOT_&#39;: &#39;.&#39;,&#xa;            &#39;_EXCLAMATIONMARK_&#39;: &#39;!&#39;,&#xa;            &#39;_QUESTIONMARK_&#39;: &#39;?&#39;,&#xa;            &#39;_COLON_&#39;: &#39;:&#39;,&#xa;            &#39;_SEMICOLON_&#39;: &#39;;&#39;,&#xa;            &#39;_HYPHEN_&#39;: &#39;-&#39;,&#xa;            &#39;_UNDERSCORE_&#39;: &#39;_&#39;,&#xa;            &#39;_LEFTPARENTHESIS_&#39;: &#39;(&#39;,&#xa;            &#39;_RIGHTPARENTHESIS_&#39;: &#39;)&#39;,&#xa;            &#39;_LEFTBRACKET_&#39;: &#39;[&#39;,&#xa;            &#39;_RIGHTBRACKET_&#39;: &#39;]&#39;,&#xa;            &#39;_LEFTBRACE_&#39;: &#39;{&#39;,&#xa;            &#39;_RIGHTBRACE_&#39;: &#39;}&#39;,&#xa;            &#39;_APOSTROPHE_&#39;: &quot;&#39;&quot;,&#xa;            &#39;_QUOTATIONMARK_&#39;: &#39;&quot;&#39;,&#xa;            &#39;_SLASH_&#39;: &#39;/&#39;,&#xa;            &#39;_BACKSLASH_&#39;: &#39;\\&#39;,&#xa;            &#39;_VERTICALBAR_&#39;: &#39;|&#39;,&#xa;            &#39;_ATSIGN_&#39;: &#39;@&#39;,&#xa;            &#39;_HASHTAG_&#39;: &#39;#&#39;,&#xa;            &#39;_DOLLARSIGN_&#39;: &#39;$&#39;,&#xa;            &#39;_PERCENTSIGN_&#39;: &#39;%&#39;,&#xa;            &#39;_CARET_&#39;: &#39;^&#39;,&#xa;            &#39;_AMPERSAND_&#39;: &#39;&amp;&#39;,&#xa;            &#39;_ASTERISK_&#39;: &#39;*&#39;,&#xa;            &#39;_PLUSSIGN_&#39;: &#39;+&#39;,&#xa;            &#39;_EQUALSIGN_&#39;: &#39;=&#39;,&#xa;            &#39;_LESSTHAN_&#39;: &#39;&lt;&#39;,&#xa;            &#39;_GREATERTHAN_&#39;: &#39;&gt;&#39;,&#xa;            &#39;_GRAVEACCENT_&#39;: &#39;`&#39;,&#xa;            &#39;_TILDE_&#39;: &#39;~&#39;,&#xa;            &#39;_NUMBERSYMB_&#39;: &#39;№&#39;,&#xa;        }&#xa;&#xa;&#xa;        pattern = re.compile(&#39;|&#39;.join(re.escape(char) for char in revert_replacements.keys()))&#xa;&#xa;&#xa;        def replacer(match):&#xa;            return revert_replacements[match.group(0)]&#xa;&#xa;&#xa;        response_clean = response.json()[&#39;result&#39;][&#39;response&#39;][&#39;messages&#39;][-1]&#xa;        server_answer_content = response_clean[&#39;content&#39;]&#xa;        # inline_sources = response_clean[&#39;faq_sources&#39;]&#xa;        # for i in range(len(inline_sources)):&#xa;        #     replace_on_raw = inline_sources[i][&#39;metadata&#39;][&#39;tags&#39;][0]&#xa;        #     replace_on = pattern.sub(replacer, replace_on_raw)[1:]&#xa;        #     server_answer_content = server_answer_content.replace(f&#39;[^{i+1}^]&#39;, f&quot;[{replace_on}]&quot;)&#xa;&#xa;&#xa;        inline_sources = response.json()[&#39;result&#39;][&#39;response&#39;][&#39;messages&#39;][-1][&#39;inline_sources&#39;]&#xa;        for i, inl_src in enumerate(inline_sources):&#xa;            replace_on = &quot;&quot;&#xa;            if inl_src[&#39;source_type&#39;] == &#39;faq&#39;:&#xa;                replace_on_raw = inl_src[&#39;source&#39;][&#39;metadata&#39;][&#39;tags&#39;][0]&#xa;                replace_on = &#39;[&#39; + pattern.sub(replacer, replace_on_raw)[1:] + &#39;]&#39;&#xa;            elif inl_src[&#39;source_type&#39;] == &#39;passage&#39;:&#xa;                path_elements = inl_src[&#39;source&#39;][&#39;metadata&#39;][&#39;breadcrumbs&#39;].split(&#39;/&#39;)&#xa;                if len(path_elements) &gt; 1:&#xa;                    replace_on = &#39;[&#39; + path_elements[-2] + &#39;]&#39;&#xa;            server_answer_content = server_answer_content.replace(f&#39;[^{i+1}^]&#39;, f&quot;{replace_on}&quot;)&#xa;&#xa;&#xa;&#xa;&#xa;        log(f&quot;ПОЛУЧЕННЫЙ ОТВЕТ С IDP {server_answer_content}&quot;)&#xa;        user.variables.set(&#39;IDP_answer&#39;, server_answer_content)&#xa;        log(f&quot;Успешный запрос к {uri}. Ответ обработан.&quot;, level=&quot;INFO&quot;)&#xa;        log(f&quot;ПОЛУЧЕННЫЙ ОТВЕТ С IDP {server_answer_content}&quot;)&#xa;        user.variables.set(&#39;IDP_answer&#39;, server_answer_content)&#xa;        log(f&quot;Успешный запрос к {uri}. Ответ обработан.&quot;, level=&quot;INFO&quot;)&#xa;&#xa;&#xa;    except requests.RequestException as e:&#xa;        user.variables.set(&#39;IDP_answer&#39;, &#39;Ошибка при обработке запроса&#39;)&#xa;        log(f&quot;Ответ от IDP: {response.text}&quot;, level=&quot;INFO&quot;)&#xa;        log(f&quot;Ошибка запроса к {uri}: {str(e)}&quot;, level=&quot;ERROR&quot;)&#xa;    except (KeyError, IndexError, ValueError) as e:&#xa;        user.variables.set(&#39;IDP_answer&#39;, &#39;Ошибка при обработке ответа&#39;)&#xa;        log(f&quot;Ответ от IDP: {response.text}&quot;, level=&quot;INFO&quot;)&#xa;        log(f&quot;Ошибка обработки ответа: {str(e)}&quot;, level=&quot;ERROR&quot;)&#xa;&#xa;&#xa;if __name__ == &#39;__main__&#39;:&#xa;    questions = [&quot;Какие манипуляции с долгом возможны в отчетности?&quot;,&#xa;&quot;По какому участнику сделки требуется построение прогноза движения денежных средств при установлении ИР на Консолидированную Группу?&quot;,&#xa;&quot;На какой срок строятся будущие денежные потоки?&quot;,&#xa;&quot;Как определить, что деятельность носит сезонный характер?&quot;,&#xa;&quot;Можно ли строить будущие денежные потоки в иностранной валюте?&quot;,&#xa;&quot;Относится ли к прочим изменениям увеличение срока действующей банковской гарантии в пределах срока лимита ЕДБГ без увеличения срока действия лимита ЕДБГ?&quot;,&#xa;&quot;Требуется ли проверка Fraud-риска по техническим изменениям?&quot;,&#xa;&quot;Является ли прочим изменением продление периода выборки по сделке УФН?&quot;,&#xa;&quot;Финансирует ли Банк казино?&quot;,&#xa;&quot;Особенности финансирования по договорам простого товарищества&quot;,&#xa;&quot;Может ли банк финансировать некоммерческие организации?&quot;]&#xa;    for question in questions:&#xa;        run_request(question)&#xa;Это скрипт для отправки запроса в сервис.&#xa;Нужно сделать аналогичный, для отправки на такой API:&#xa;@router.post(&#xa;    &quot;/idp_search&quot;,&#xa;    status_code=status.HTTP_200_OK,&#xa;    response_model=schemas.IDPSearchResponse,&#xa;    responses={&#xa;        status.HTTP_424_FAILED_DEPENDENCY: {&#xa;            &quot;description&quot;: &quot;Ошибка при взаимодействии с IDP системой&quot;,&#xa;            &quot;model&quot;: schemas.IDPErrorResponse,&#xa;        },&#xa;    },&#xa;)&#xa;async def idp_search(&#xa;    request: schemas.IDPSearchRequest,&#xa;    headers: dict = Depends(common_headers),&#xa;):&#xa;    &quot;&quot;&quot;&#xa;    Поиск информации в IDP (Intelligent Data Platform).&#xa;    &#xa;    Этот endpoint позволяет выполнить поиск информации в корпоративной базе знаний &#xa;    через IDP API. Система автоматически обрабатывает запрос, выполняет поиск&#xa;    по документам и возвращает ответ с ссылками на источники.&#xa;    &quot;&quot;&quot;&#xa;    logger.info(f&quot;Processing IDP search request: &#39;{request.question[:100]}...&#39;&quot;)&#xa;    &#xa;    # Отправляем запрос через IDP сервис&#xa;    answer, response_time, error_msg, external_uuid = await idp_service.search(request.question)&#xa;    &#xa;    if error_msg:&#xa;        logger.error(f&quot;IDP search failed: {error_msg}&quot;)&#xa;        return JSONResponse(&#xa;            status_code=status.HTTP_424_FAILED_DEPENDENCY,&#xa;            content=schemas.IDPErrorResponse(&#xa;                error_description=f&quot;Ошибка при обращении к IDP: {error_msg}&quot;,&#xa;                error_code=error_msg,&#xa;                response_time=response_time,&#xa;            ).model_dump(),&#xa;        )&#xa;    &#xa;    logger.info(f&quot;IDP search completed in {response_time:.2f}s&quot;)&#xa;    return schemas.IDPSearchResponse(&#xa;        answer=answer,&#xa;        response_time=response_time,&#xa;        external_uuid=external_uuid,&#xa;    )&#xa;&#xa;&#xa;# IDP Schemas&#xa;&#xa;&#xa;class IDPSearchRequest(BaseModel):&#xa;    &quot;&quot;&quot;Тело запроса для IDP поиска&quot;&quot;&quot;&#xa;&#xa;&#xa;    question: str = Field(&#xa;        description=&quot;Вопрос для поиска в IDP (Intelligent Data Platform)&quot;,&#xa;        min_length=4,&#xa;        examples=[&#xa;            &quot;Какие манипуляции с долгом возможны в отчетности?&quot;,&#xa;            &quot;По какому участнику сделки требуется построение прогноза движения денежных средств?&quot;,&#xa;            &quot;На какой срок строятся будущие денежные потоки?&quot;&#xa;        ],&#xa;    )&#xa;&#xa;&#xa;&#xa;&#xa;class IDPSearchResponse(BaseModel):&#xa;    &quot;&quot;&quot;Ответ для IDP поиска&quot;&quot;&quot;&#xa;&#xa;&#xa;    answer: str = Field(&#xa;        description=&quot;Ответ от IDP с информацией из базы знаний и ссылками на источники&quot;,&#xa;        examples=[&#xa;            &quot;Согласно документации [Руководство по кредитным операциям], манипуляции с долгом включают реструктуризацию, рефинансирование и списание безнадежной задолженности.&quot;&#xa;        ],&#xa;    )&#xa;    response_time: float = Field(&#xa;        description=&quot;Время ответа в секундах&quot;,&#xa;        examples=[3.24],&#xa;    )&#xa;    external_uuid: str = Field(&#xa;        description=&quot;Уникальный идентификатор запроса&quot;,&#xa;        examples=[&quot;550e8400-e29b-41d4-a716-446655440000&quot;],&#xa;    )&#xa;&#xa;&#xa;&#xa;&#xa;class IDPErrorResponse(BaseModel):&#xa;    &quot;&quot;&quot;Ошибка при работе с IDP&quot;&quot;&quot;&#xa;&#xa;&#xa;    error_description: str = Field(&#xa;        description=&quot;Описание ошибки при обращении к IDP&quot;,&#xa;        examples=[&#xa;            &quot;Ошибка при обработке запроса к IDP&quot;,&#xa;            &quot;Timeout при обращении к IDP API&quot;,&#xa;            &quot;Ошибка при обработке ответа от IDP&quot;&#xa;        ],&#xa;    )&#xa;    error_code: str = Field(&#xa;        description=&quot;Код ошибки&quot;,&#xa;        examples=[&quot;IDP_REQUEST_ERROR&quot;, &quot;IDP_TIMEOUT_ERROR&quot;, &quot;IDP_RESPONSE_ERROR&quot;],&#xa;    )&#xa;    response_time: Optional[float] = Field(&#xa;        description=&quot;Время ответа в секундах (если доступно)&quot;,&#xa;        examples=[5.0],&#xa;        default=None,&#xa;    )" link="import uuid&#xa;import os&#xa;import re&#xa;import requests&#xa;from datetime import datetime&#xa;from core.logging.logger_utils import log&#xa;from scenarios.user.user_model import User&#xa;&#xa;&#xa;&#xa;&#xa;def run_request(user: User, service_id: str = &quot;faq&quot;) -&gt; None:&#xa;    &quot;&quot;&quot;Отправляет запрос к серверу в соответствии с новым форматом&quot;&quot;&quot;&#xa;    HEADERS = {&#xa;        &#39;accept&#39;: &#39;application/json&#39;,&#xa;        &#39;Content-Type&#39;: &#39;application/json&#39;,&#xa;    }&#xa;    external_uuid = str(uuid.uuid4())&#xa;    SOURCE_ID = os.getenv(&#39;SOURCE_ID&#39;, &#39;957ec5e0-a331-4da8-9fa7-15a1c4d86035&#39;)&#xa;    INDEX_ID_FAQ = os.getenv(&#39;INDEX_ID&#39;, &#39;9870147f-a646-4421-aa96-aa8960c821fb_dkpp_index_faq_0_1_0&#39;)&#xa;    INDEX_ID_SOURCES = os.getenv(&#39;INDEX_ID_SOURCES&#39;, &#39;9870147f-a646-4421-aa96-aa8960c821fb_dkpp_index_nofaq_0_2_1&#39;)&#xa;    URL = os.getenv(&#39;IDP_API&#39;, &#39;sm.apps.dev-terra000003-ids.ocp.delta.sbrf.ru&#39;)&#xa;    MODEL_NAME = &quot;GigaChat-2-Max&quot;&#xa;&#xa;&#xa;    uri = r&quot;http://&quot; + URL + r&quot;/sync/skill/universal_search&quot;&#xa;&#xa;&#xa;        &#xa;    search_config = {&#xa;    &quot;agent_type&quot;: &quot;universal&quot;,&#xa;    &quot;agent_configuration&quot;: {&#xa;        &quot;index_type&quot;: &quot;opensearch&quot;,&#xa;        &quot;data_sources&quot;: [&#xa;            {&#xa;                &quot;index_id&quot;: INDEX_ID_SOURCES&#xa;            }&#xa;        ],&#xa;        &quot;data_sources_faq&quot;: [&#xa;            {&#xa;                &quot;index_id&quot;: INDEX_ID_FAQ&#xa;            }&#xa;        ],&#xa;        &quot;query_rewriter&quot;: {&#xa;            &quot;enabled&quot;: False&#xa;        },&#xa;        &quot;reranker&quot;: {&#xa;            &quot;enabled&quot;: False&#xa;        },&#xa;        &quot;reranker_faq&quot;: {&#xa;            &quot;enabled&quot;: False&#xa;        },&#xa;        &quot;retriever&quot;: {&#xa;            &quot;bm25_weight&quot;: 0.3,&#xa;            &quot;global_size&quot;: 100,&#xa;            &quot;size&quot;: 10,&#xa;            &quot;embedder&quot;: {&#xa;                &quot;model_name&quot;: &quot;gigachat&quot;&#xa;            }&#xa;        },&#xa;        &quot;retriever_faq&quot;: {&#xa;            &quot;bm25_weight&quot;: 0.2,&#xa;            &quot;global_size&quot;: 100,&#xa;            &quot;size&quot;: 10,&#xa;            &quot;embedder&quot;: {&#xa;                &quot;model_name&quot;: &quot;gigachat&quot;&#xa;            }&#xa;        },&#xa;        &quot;context_expansion&quot;: {&#xa;            &quot;enabled&quot;: False,&#xa;            &quot;chapter_aggregation&quot;: True,&#xa;            &quot;max_tokens&quot;: 2000&#xa;        },&#xa;        &quot;qa&quot;: {&#xa;            &quot;enabled&quot;: True,&#xa;            &quot;qa_scenario&quot;: &quot;stuff&quot;,&#xa;            &quot;model_name&quot;: MODEL_NAME,&#xa;            &quot;temperature&quot;: 0.1,&#xa;            &quot;top_p&quot;: 0,&#xa;            &quot;repetition_penalty&quot;: 1&#xa;        },&#xa;        &quot;sources&quot;: {&#xa;            &quot;enabled&quot;: True,&#xa;            &quot;source_type&quot;: &quot;passage&quot;&#xa;        },&#xa;        &quot;inline_sources&quot;: {&#xa;            &quot;enabled&quot;: True,&#xa;            &quot;format&quot;: &quot;index_caret&quot;,&#xa;            &quot;source_type&quot;: &quot;passage&quot;&#xa;        }&#xa;    }&#xa;}&#xa;&#xa;&#xa;&#xa;&#xa;    chat = {&#xa;        &quot;request_type&quot;: &quot;chat&quot;,&#xa;        &quot;request&quot;: {&#xa;            &quot;messages&quot;: [&#xa;            {&#xa;                &quot;role&quot;: &quot;user&quot;,&#xa;                &quot;content&quot;: user.variables.get(&#39;IDP_question&#39;, &#39;&#39;),&#xa;            }&#xa;        ],&#xa;        }&#xa;    }&#xa;&#xa;&#xa;    request_body = {&#xa;        &quot;meta&quot;: {&quot;external_uuid&quot;: external_uuid, &quot;source_uuid&quot;: SOURCE_ID},&#xa;        &quot;message&quot;: chat,&#xa;        &quot;path&quot;: &quot;/predict&quot;,&#xa;        &quot;timeout&quot;: 600,&#xa;        &quot;configuration&quot;: search_config&#xa;    }&#xa;&#xa;&#xa;    try:&#xa;        log(f&quot;ПОПЫТКА ОТПРАВИТЬ ЗАПРОС НА УНИВЕРСАЛЬНЫЙ СКИЛЛ IDP {uri}, {str(HEADERS)}, {str(request_body)}&quot;)&#xa;        response = requests.post(&#xa;            uri,&#xa;            headers=HEADERS,&#xa;            json=request_body,&#xa;            verify=True&#xa;        )&#xa;&#xa;&#xa;        ## Замена численных источников на названия документов&#xa;&#xa;&#xa;        revert_replacements = {&#xa;            &#39;_SPACE_&#39;: &#39; &#39;,&#xa;            &#39;_COMMA_&#39;: &#39;,&#39;,&#xa;            &#39;_DOT_&#39;: &#39;.&#39;,&#xa;            &#39;_EXCLAMATIONMARK_&#39;: &#39;!&#39;,&#xa;            &#39;_QUESTIONMARK_&#39;: &#39;?&#39;,&#xa;            &#39;_COLON_&#39;: &#39;:&#39;,&#xa;            &#39;_SEMICOLON_&#39;: &#39;;&#39;,&#xa;            &#39;_HYPHEN_&#39;: &#39;-&#39;,&#xa;            &#39;_UNDERSCORE_&#39;: &#39;_&#39;,&#xa;            &#39;_LEFTPARENTHESIS_&#39;: &#39;(&#39;,&#xa;            &#39;_RIGHTPARENTHESIS_&#39;: &#39;)&#39;,&#xa;            &#39;_LEFTBRACKET_&#39;: &#39;[&#39;,&#xa;            &#39;_RIGHTBRACKET_&#39;: &#39;]&#39;,&#xa;            &#39;_LEFTBRACE_&#39;: &#39;{&#39;,&#xa;            &#39;_RIGHTBRACE_&#39;: &#39;}&#39;,&#xa;            &#39;_APOSTROPHE_&#39;: &quot;&#39;&quot;,&#xa;            &#39;_QUOTATIONMARK_&#39;: &#39;&quot;&#39;,&#xa;            &#39;_SLASH_&#39;: &#39;/&#39;,&#xa;            &#39;_BACKSLASH_&#39;: &#39;\\&#39;,&#xa;            &#39;_VERTICALBAR_&#39;: &#39;|&#39;,&#xa;            &#39;_ATSIGN_&#39;: &#39;@&#39;,&#xa;            &#39;_HASHTAG_&#39;: &#39;#&#39;,&#xa;            &#39;_DOLLARSIGN_&#39;: &#39;$&#39;,&#xa;            &#39;_PERCENTSIGN_&#39;: &#39;%&#39;,&#xa;            &#39;_CARET_&#39;: &#39;^&#39;,&#xa;            &#39;_AMPERSAND_&#39;: &#39;&amp;&#39;,&#xa;            &#39;_ASTERISK_&#39;: &#39;*&#39;,&#xa;            &#39;_PLUSSIGN_&#39;: &#39;+&#39;,&#xa;            &#39;_EQUALSIGN_&#39;: &#39;=&#39;,&#xa;            &#39;_LESSTHAN_&#39;: &#39;&lt;&#39;,&#xa;            &#39;_GREATERTHAN_&#39;: &#39;&gt;&#39;,&#xa;            &#39;_GRAVEACCENT_&#39;: &#39;`&#39;,&#xa;            &#39;_TILDE_&#39;: &#39;~&#39;,&#xa;            &#39;_NUMBERSYMB_&#39;: &#39;№&#39;,&#xa;        }&#xa;&#xa;&#xa;        pattern = re.compile(&#39;|&#39;.join(re.escape(char) for char in revert_replacements.keys()))&#xa;&#xa;&#xa;        def replacer(match):&#xa;            return revert_replacements[match.group(0)]&#xa;&#xa;&#xa;        response_clean = response.json()[&#39;result&#39;][&#39;response&#39;][&#39;messages&#39;][-1]&#xa;        server_answer_content = response_clean[&#39;content&#39;]&#xa;        # inline_sources = response_clean[&#39;faq_sources&#39;]&#xa;        # for i in range(len(inline_sources)):&#xa;        #     replace_on_raw = inline_sources[i][&#39;metadata&#39;][&#39;tags&#39;][0]&#xa;        #     replace_on = pattern.sub(replacer, replace_on_raw)[1:]&#xa;        #     server_answer_content = server_answer_content.replace(f&#39;[^{i+1}^]&#39;, f&quot;[{replace_on}]&quot;)&#xa;&#xa;&#xa;        inline_sources = response.json()[&#39;result&#39;][&#39;response&#39;][&#39;messages&#39;][-1][&#39;inline_sources&#39;]&#xa;        for i, inl_src in enumerate(inline_sources):&#xa;            replace_on = &quot;&quot;&#xa;            if inl_src[&#39;source_type&#39;] == &#39;faq&#39;:&#xa;                replace_on_raw = inl_src[&#39;source&#39;][&#39;metadata&#39;][&#39;tags&#39;][0]&#xa;                replace_on = &#39;[&#39; + pattern.sub(replacer, replace_on_raw)[1:] + &#39;]&#39;&#xa;            elif inl_src[&#39;source_type&#39;] == &#39;passage&#39;:&#xa;                path_elements = inl_src[&#39;source&#39;][&#39;metadata&#39;][&#39;breadcrumbs&#39;].split(&#39;/&#39;)&#xa;                if len(path_elements) &gt; 1:&#xa;                    replace_on = &#39;[&#39; + path_elements[-2] + &#39;]&#39;&#xa;            server_answer_content = server_answer_content.replace(f&#39;[^{i+1}^]&#39;, f&quot;{replace_on}&quot;)&#xa;&#xa;&#xa;&#xa;&#xa;        log(f&quot;ПОЛУЧЕННЫЙ ОТВЕТ С IDP {server_answer_content}&quot;)&#xa;        user.variables.set(&#39;IDP_answer&#39;, server_answer_content)&#xa;        log(f&quot;Успешный запрос к {uri}. Ответ обработан.&quot;, level=&quot;INFO&quot;)&#xa;        log(f&quot;ПОЛУЧЕННЫЙ ОТВЕТ С IDP {server_answer_content}&quot;)&#xa;        user.variables.set(&#39;IDP_answer&#39;, server_answer_content)&#xa;        log(f&quot;Успешный запрос к {uri}. Ответ обработан.&quot;, level=&quot;INFO&quot;)&#xa;&#xa;&#xa;    except requests.RequestException as e:&#xa;        user.variables.set(&#39;IDP_answer&#39;, &#39;Ошибка при обработке запроса&#39;)&#xa;        log(f&quot;Ответ от IDP: {response.text}&quot;, level=&quot;INFO&quot;)&#xa;        log(f&quot;Ошибка запроса к {uri}: {str(e)}&quot;, level=&quot;ERROR&quot;)&#xa;    except (KeyError, IndexError, ValueError) as e:&#xa;        user.variables.set(&#39;IDP_answer&#39;, &#39;Ошибка при обработке ответа&#39;)&#xa;        log(f&quot;Ответ от IDP: {response.text}&quot;, level=&quot;INFO&quot;)&#xa;        log(f&quot;Ошибка обработки ответа: {str(e)}&quot;, level=&quot;ERROR&quot;)&#xa;&#xa;&#xa;if __name__ == &#39;__main__&#39;:&#xa;    questions = [&quot;Какие манипуляции с долгом возможны в отчетности?&quot;,&#xa;&quot;По какому участнику сделки требуется построение прогноза движения денежных средств при установлении ИР на Консолидированную Группу?&quot;,&#xa;&quot;На какой срок строятся будущие денежные потоки?&quot;,&#xa;&quot;Как определить, что деятельность носит сезонный характер?&quot;,&#xa;&quot;Можно ли строить будущие денежные потоки в иностранной валюте?&quot;,&#xa;&quot;Относится ли к прочим изменениям увеличение срока действующей банковской гарантии в пределах срока лимита ЕДБГ без увеличения срока действия лимита ЕДБГ?&quot;,&#xa;&quot;Требуется ли проверка Fraud-риска по техническим изменениям?&quot;,&#xa;&quot;Является ли прочим изменением продление периода выборки по сделке УФН?&quot;,&#xa;&quot;Финансирует ли Банк казино?&quot;,&#xa;&quot;Особенности финансирования по договорам простого товарищества&quot;,&#xa;&quot;Может ли банк финансировать некоммерческие организации?&quot;]&#xa;    for question in questions:&#xa;        run_request(question)&#xa;Это скрипт для отправки запроса в сервис.&#xa;Нужно сделать аналогичный, для отправки на такой API:&#xa;@router.post(&#xa;    &quot;/idp_search&quot;,&#xa;    status_code=status.HTTP_200_OK,&#xa;    response_model=schemas.IDPSearchResponse,&#xa;    responses={&#xa;        status.HTTP_424_FAILED_DEPENDENCY: {&#xa;            &quot;description&quot;: &quot;Ошибка при взаимодействии с IDP системой&quot;,&#xa;            &quot;model&quot;: schemas.IDPErrorResponse,&#xa;        },&#xa;    },&#xa;)&#xa;async def idp_search(&#xa;    request: schemas.IDPSearchRequest,&#xa;    headers: dict = Depends(common_headers),&#xa;):&#xa;    &quot;&quot;&quot;&#xa;    Поиск информации в IDP (Intelligent Data Platform).&#xa;    &#xa;    Этот endpoint позволяет выполнить поиск информации в корпоративной базе знаний &#xa;    через IDP API. Система автоматически обрабатывает запрос, выполняет поиск&#xa;    по документам и возвращает ответ с ссылками на источники.&#xa;    &quot;&quot;&quot;&#xa;    logger.info(f&quot;Processing IDP search request: &#39;{request.question[:100]}...&#39;&quot;)&#xa;    &#xa;    # Отправляем запрос через IDP сервис&#xa;    answer, response_time, error_msg, external_uuid = await idp_service.search(request.question)&#xa;    &#xa;    if error_msg:&#xa;        logger.error(f&quot;IDP search failed: {error_msg}&quot;)&#xa;        return JSONResponse(&#xa;            status_code=status.HTTP_424_FAILED_DEPENDENCY,&#xa;            content=schemas.IDPErrorResponse(&#xa;                error_description=f&quot;Ошибка при обращении к IDP: {error_msg}&quot;,&#xa;                error_code=error_msg,&#xa;                response_time=response_time,&#xa;            ).model_dump(),&#xa;        )&#xa;    &#xa;    logger.info(f&quot;IDP search completed in {response_time:.2f}s&quot;)&#xa;    return schemas.IDPSearchResponse(&#xa;        answer=answer,&#xa;        response_time=response_time,&#xa;        external_uuid=external_uuid,&#xa;    )&#xa;&#xa;&#xa;# IDP Schemas&#xa;&#xa;&#xa;class IDPSearchRequest(BaseModel):&#xa;    &quot;&quot;&quot;Тело запроса для IDP поиска&quot;&quot;&quot;&#xa;&#xa;&#xa;    question: str = Field(&#xa;        description=&quot;Вопрос для поиска в IDP (Intelligent Data Platform)&quot;,&#xa;        min_length=4,&#xa;        examples=[&#xa;            &quot;Какие манипуляции с долгом возможны в отчетности?&quot;,&#xa;            &quot;По какому участнику сделки требуется построение прогноза движения денежных средств?&quot;,&#xa;            &quot;На какой срок строятся будущие денежные потоки?&quot;&#xa;        ],&#xa;    )&#xa;&#xa;&#xa;&#xa;&#xa;class IDPSearchResponse(BaseModel):&#xa;    &quot;&quot;&quot;Ответ для IDP поиска&quot;&quot;&quot;&#xa;&#xa;&#xa;    answer: str = Field(&#xa;        description=&quot;Ответ от IDP с информацией из базы знаний и ссылками на источники&quot;,&#xa;        examples=[&#xa;            &quot;Согласно документации [Руководство по кредитным операциям], манипуляции с долгом включают реструктуризацию, рефинансирование и списание безнадежной задолженности.&quot;&#xa;        ],&#xa;    )&#xa;    response_time: float = Field(&#xa;        description=&quot;Время ответа в секундах&quot;,&#xa;        examples=[3.24],&#xa;    )&#xa;    external_uuid: str = Field(&#xa;        description=&quot;Уникальный идентификатор запроса&quot;,&#xa;        examples=[&quot;550e8400-e29b-41d4-a716-446655440000&quot;],&#xa;    )&#xa;&#xa;&#xa;&#xa;&#xa;class IDPErrorResponse(BaseModel):&#xa;    &quot;&quot;&quot;Ошибка при работе с IDP&quot;&quot;&quot;&#xa;&#xa;&#xa;    error_description: str = Field(&#xa;        description=&quot;Описание ошибки при обращении к IDP&quot;,&#xa;        examples=[&#xa;            &quot;Ошибка при обработке запроса к IDP&quot;,&#xa;            &quot;Timeout при обращении к IDP API&quot;,&#xa;            &quot;Ошибка при обработке ответа от IDP&quot;&#xa;        ],&#xa;    )&#xa;    error_code: str = Field(&#xa;        description=&quot;Код ошибки&quot;,&#xa;        examples=[&quot;IDP_REQUEST_ERROR&quot;, &quot;IDP_TIMEOUT_ERROR&quot;, &quot;IDP_RESPONSE_ERROR&quot;],&#xa;    )&#xa;    response_time: Optional[float] = Field(&#xa;        description=&quot;Время ответа в секундах (если доступно)&quot;,&#xa;        examples=[5.0],&#xa;        default=None,&#xa;    )" id="tjXOWgZFEl35QNcsJMh5-1">
          <mxCell style="text;whiteSpace=wrap;" parent="1" vertex="1">
            <mxGeometry x="1030" y="330" width="560" height="5090" as="geometry" />
          </mxCell>
        </UserObject>
        <UserObject label="# idp_client.py&#xa;import os&#xa;import uuid&#xa;import time&#xa;import json&#xa;import requests&#xa;from typing import Optional, Tuple, Dict, Any, List&#xa;from requests.adapters import HTTPAdapter, Retry&#xa;&#xa;&#xa;from core.logging.logger_utils import log&#xa;from scenarios.user.user_model import User&#xa;&#xa;&#xa;&#xa;&#xa;# -----------------------------&#xa;# ВСПОМОГАТЕЛЬНЫЕ НАСТРОЙКИ&#xa;# -----------------------------&#xa;DEFAULT_API_BASE = os.getenv(&quot;IDP_GATEWAY_BASE&quot;, &quot;http://localhost:8000&quot;)  # где крутится твой FastAPI&#xa;ENDPOINT_PATH = os.getenv(&quot;IDP_SEARCH_PATH&quot;, &quot;/idp_search&quot;)&#xa;&#xa;&#xa;# Если ваш Depends(common_headers) ожидает определённые заголовки — добавь их в ENV и сюда&#xa;DEFAULT_HEADERS: Dict[str, str] = {&#xa;    &quot;accept&quot;: &quot;application/json&quot;,&#xa;    &quot;Content-Type&quot;: &quot;application/json&quot;,&#xa;    # Примеры корпоративных заголовков — подставь нужные, если требуется:&#xa;    # &quot;X-Request-Source&quot;: os.getenv(&quot;X_REQUEST_SOURCE&quot;, &quot;your-service&quot;),&#xa;    # &quot;X-Auth-Token&quot;: os.getenv(&quot;X_AUTH_TOKEN&quot;, &quot;&quot;),&#xa;}&#xa;&#xa;&#xa;REQUEST_TIMEOUT = float(os.getenv(&quot;IDP_CLIENT_TIMEOUT&quot;, &quot;30&quot;))  # сек.&#xa;RETRY_TOTAL = int(os.getenv(&quot;IDP_CLIENT_RETRY_TOTAL&quot;, &quot;3&quot;))&#xa;RETRY_BACKOFF = float(os.getenv(&quot;IDP_CLIENT_RETRY_BACKOFF&quot;, &quot;0.5&quot;))  # экспоненциальная пауза&#xa;&#xa;&#xa;&#xa;&#xa;def _build_session() -&gt; requests.Session:&#xa;    &quot;&quot;&quot;&#xa;    Готовим requests.Session с умным ретраем (на случай сетевых глюков, 502/503/504).&#xa;    &quot;&quot;&quot;&#xa;    session = requests.Session()&#xa;    retries = Retry(&#xa;        total=RETRY_TOTAL,&#xa;        backoff_factor=RETRY_BACKOFF,&#xa;        status_forcelist=(502, 503, 504),&#xa;        allowed_methods=frozenset([&quot;POST&quot;]),&#xa;        raise_on_status=False,&#xa;    )&#xa;    adapter = HTTPAdapter(max_retries=retries)&#xa;    session.mount(&quot;http://&quot;, adapter)&#xa;    session.mount(&quot;https://&quot;, adapter)&#xa;    return session&#xa;&#xa;&#xa;&#xa;&#xa;def _safe_get(dct: Dict[str, Any], path: List[str], default=None):&#xa;    &quot;&quot;&quot;&#xa;    Безопасно достаём значение из вложенного словаря по пути ключей.&#xa;    &quot;&quot;&quot;&#xa;    cur = dct&#xa;    for key in path:&#xa;        if not isinstance(cur, dict) or key not in cur:&#xa;            return default&#xa;        cur = cur[key]&#xa;    return cur&#xa;&#xa;&#xa;&#xa;&#xa;def _normalize_answer_text(text: str) -&gt; str:&#xa;    &quot;&quot;&quot;&#xa;    Хук на будущее: если когда-либо вернутся inline-ссылки вида [^1^],&#xa;    здесь можно будет подменять их на понятные ярлыки.&#xa;    Сейчас просто возвращаем как есть.&#xa;    &quot;&quot;&quot;&#xa;    return text&#xa;&#xa;&#xa;&#xa;&#xa;def _compose_url(base: str, path: str) -&gt; str:&#xa;    base = base.rstrip(&quot;/&quot;)&#xa;    path = path if path.startswith(&quot;/&quot;) else f&quot;/{path}&quot;&#xa;    return f&quot;{base}{path}&quot;&#xa;&#xa;&#xa;&#xa;&#xa;def run_idp_search(user: User, api_base: Optional[str] = None) -&gt; None:&#xa;    &quot;&quot;&quot;&#xa;    Отправляет вопрос на FastAPI эндпоинт /idp_search и записывает результат в user.variables.&#xa;&#xa;&#xa;    Вход:&#xa;        - user.variables[&#39;IDP_question&#39;] : строка вопроса.&#xa;    Выход:&#xa;        - user.variables[&#39;IDP_answer&#39;]         : текст ответа или текст ошибки.&#xa;        - user.variables[&#39;IDP_external_uuid&#39;]  : uuid запроса (если вернулся).&#xa;        - user.variables[&#39;IDP_response_time&#39;]  : время ответа в секундах (если вернулось).&#xa;&#xa;&#xa;    Исключения не пробрасываем — всё логируем и безопасно сохраняем в user.variables.&#xa;    &quot;&quot;&quot;&#xa;    question = user.variables.get(&quot;IDP_question&quot;, &quot;&quot;)&#xa;    if not isinstance(question, str) or len(question.strip()) &lt; 4:&#xa;        msg = &quot;Вопрос пустой или короче 4 символов — IDP его отклонит согласно модели схем.&quot;&#xa;        log(msg, level=&quot;ERROR&quot;)&#xa;        user.variables.set(&quot;IDP_answer&quot;, msg)&#xa;        return&#xa;&#xa;&#xa;    base = api_base or DEFAULT_API_BASE&#xa;    url = _compose_url(base, ENDPOINT_PATH)&#xa;&#xa;&#xa;    # Можно прокинуть trace-id в заголовки для сквозной трассировки&#xa;    external_uuid = str(uuid.uuid4())&#xa;&#xa;&#xa;    headers = dict(DEFAULT_HEADERS)&#xa;    headers[&quot;X-External-UUID&quot;] = external_uuid  # опционально — если на бэке это используется&#xa;&#xa;&#xa;    payload = {&quot;question&quot;: question}&#xa;&#xa;&#xa;    log(f&quot;IDP_SEARCH ▶ POST {url} | headers={headers} | payload={payload}&quot;)&#xa;&#xa;&#xa;    session = _build_session()&#xa;    t0 = time.perf_counter()&#xa;&#xa;&#xa;    try:&#xa;        resp = session.post(url, headers=headers, data=json.dumps(payload), timeout=REQUEST_TIMEOUT)&#xa;        elapsed = time.perf_counter() - t0&#xa;&#xa;&#xa;        # 200 OK — успешный ответ&#xa;        if resp.status_code == 200:&#xa;            data = resp.json()&#xa;&#xa;&#xa;            answer = _safe_get(data, [&quot;answer&quot;], &quot;&quot;)&#xa;            response_time = _safe_get(data, [&quot;response_time&quot;], elapsed)&#xa;            returned_uuid = _safe_get(data, [&quot;external_uuid&quot;], external_uuid)&#xa;&#xa;&#xa;            normalized_answer = _normalize_answer_text(answer)&#xa;&#xa;&#xa;            log(&#xa;                f&quot;IDP_SEARCH ✔ 200 | time={response_time:.2f}s | uuid={returned_uuid} | &quot;&#xa;                f&quot;answer_preview=&#39;{(normalized_answer or &#39;&#39;)[:180]}...&#39;&quot;,&#xa;                level=&quot;INFO&quot;,&#xa;            )&#xa;&#xa;&#xa;            user.variables.set(&quot;IDP_answer&quot;, normalized_answer or &quot;&quot;)&#xa;            user.variables.set(&quot;IDP_external_uuid&quot;, returned_uuid)&#xa;            user.variables.set(&quot;IDP_response_time&quot;, response_time)&#xa;            return&#xa;&#xa;&#xa;        # 424 — проксируем описание ошибки из тела по вашей схеме IDPErrorResponse&#xa;        if resp.status_code == 424:&#xa;            try:&#xa;                err = resp.json()&#xa;            except Exception:&#xa;                err = {}&#xa;&#xa;&#xa;            err_desc = _safe_get(err, [&quot;error_description&quot;], &quot;Ошибка при обращении к IDP&quot;)&#xa;            err_code = _safe_get(err, [&quot;error_code&quot;], &quot;IDP_REQUEST_ERROR&quot;)&#xa;            response_time = _safe_get(err, [&quot;response_time&quot;], time.perf_counter() - t0)&#xa;&#xa;&#xa;            log(f&quot;IDP_SEARCH ✖ 424 | {err_code}: {err_desc} | time={response_time:.2f}s&quot;, level=&quot;ERROR&quot;)&#xa;&#xa;&#xa;            user.variables.set(&quot;IDP_answer&quot;, f&quot;{err_desc} (код: {err_code})&quot;)&#xa;            user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;            user.variables.set(&quot;IDP_response_time&quot;, response_time)&#xa;            return&#xa;&#xa;&#xa;        # Прочие статусы — максимально информативный лог + тело&#xa;        body_preview = &quot;&quot;&#xa;        try:&#xa;            body_preview = json.dumps(resp.json(), ensure_ascii=False)[:500]&#xa;        except Exception:&#xa;            body_preview = (resp.text or &quot;&quot;)[:500]&#xa;&#xa;&#xa;        log(&#xa;            f&quot;IDP_SEARCH ✖ {resp.status_code} {resp.reason} | body=&#39;{body_preview}&#39;&quot;,&#xa;            level=&quot;ERROR&quot;,&#xa;        )&#xa;&#xa;&#xa;        user.variables.set(&#xa;            &quot;IDP_answer&quot;,&#xa;            f&quot;Ошибка: {resp.status_code} {resp.reason}. Обратитесь к логам сервиса.&quot;,&#xa;        )&#xa;        user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;        user.variables.set(&quot;IDP_response_time&quot;, time.perf_counter() - t0)&#xa;&#xa;&#xa;    except requests.Timeout as e:&#xa;        elapsed = time.perf_counter() - t0&#xa;        log(f&quot;IDP_SEARCH ⏱ timeout after {elapsed:.2f}s: {str(e)}&quot;, level=&quot;ERROR&quot;)&#xa;        user.variables.set(&quot;IDP_answer&quot;, &quot;Timeout при обращении к /idp_search&quot;)&#xa;        user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;        user.variables.set(&quot;IDP_response_time&quot;, elapsed)&#xa;&#xa;&#xa;    except requests.RequestException as e:&#xa;        elapsed = time.perf_counter() - t0&#xa;        log(f&quot;IDP_SEARCH ⚠ network error: {str(e)}&quot;, level=&quot;ERROR&quot;)&#xa;        user.variables.set(&quot;IDP_answer&quot;, &quot;Сетевая ошибка при обращении к /idp_search&quot;)&#xa;        user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;        user.variables.set(&quot;IDP_response_time&quot;, elapsed)&#xa;&#xa;&#xa;    except Exception as e:&#xa;        elapsed = time.perf_counter() - t0&#xa;        log(f&quot;IDP_SEARCH ☠ unexpected error: {str(e)}&quot;, level=&quot;ERROR&quot;)&#xa;        user.variables.set(&quot;IDP_answer&quot;, &quot;Неожиданная ошибка клиента IDP&quot;)&#xa;        user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;        user.variables.set(&quot;IDP_response_time&quot;, elapsed)&#xa;&#xa;&#xa;&#xa;&#xa;# --------------------------------------&#xa;# НЕОБЯЗАТЕЛЬНО: асинхронная версия (httpx)&#xa;# --------------------------------------&#xa;# Используй, если у тебя асинхронный воркер, и хочется не блокировать луп.&#xa;# Поведение и контракты идентичны синхронной версии.&#xa;async def run_idp_search_async(user: User, api_base: Optional[str] = None) -&gt; None:&#xa;    import httpx&#xa;    import asyncio&#xa;&#xa;&#xa;    question = user.variables.get(&quot;IDP_question&quot;, &quot;&quot;)&#xa;    if not isinstance(question, str) or len(question.strip()) &lt; 4:&#xa;        msg = &quot;Вопрос пустой или короче 4 символов — IDP его отклонит согласно модели схем.&quot;&#xa;        log(msg, level=&quot;ERROR&quot;)&#xa;        user.variables.set(&quot;IDP_answer&quot;, msg)&#xa;        return&#xa;&#xa;&#xa;    base = api_base or DEFAULT_API_BASE&#xa;    url = _compose_url(base, ENDPOINT_PATH)&#xa;&#xa;&#xa;    external_uuid = str(uuid.uuid4())&#xa;    headers = dict(DEFAULT_HEADERS)&#xa;    headers[&quot;X-External-UUID&quot;] = external_uuid&#xa;&#xa;&#xa;    payload = {&quot;question&quot;: question}&#xa;    log(f&quot;IDP_SEARCH(async) ▶ POST {url} | headers={headers} | payload={payload}&quot;)&#xa;&#xa;&#xa;    # Ретраи вручную, т.к. httpx не имеет встроенного Retry, как requests+urllib3&#xa;    attempts = RETRY_TOTAL + 1&#xa;    backoff = RETRY_BACKOFF&#xa;&#xa;&#xa;    t0 = time.perf_counter()&#xa;&#xa;&#xa;    async with httpx.AsyncClient(timeout=REQUEST_TIMEOUT) as client:&#xa;        for attempt in range(1, attempts + 1):&#xa;            try:&#xa;                resp = await client.post(url, headers=headers, json=payload)&#xa;                elapsed = time.perf_counter() - t0&#xa;&#xa;&#xa;                if resp.status_code == 200:&#xa;                    data = resp.json()&#xa;                    answer = data.get(&quot;answer&quot;, &quot;&quot;)&#xa;                    response_time = data.get(&quot;response_time&quot;, elapsed)&#xa;                    returned_uuid = data.get(&quot;external_uuid&quot;, external_uuid)&#xa;&#xa;&#xa;                    normalized_answer = _normalize_answer_text(answer)&#xa;                    log(&#xa;                        f&quot;IDP_SEARCH(async) ✔ 200 | time={response_time:.2f}s | uuid={returned_uuid} | &quot;&#xa;                        f&quot;answer_preview=&#39;{(normalized_answer or &#39;&#39;)[:180]}...&#39;&quot;,&#xa;                        level=&quot;INFO&quot;,&#xa;                    )&#xa;                    user.variables.set(&quot;IDP_answer&quot;, normalized_answer or &quot;&quot;)&#xa;                    user.variables.set(&quot;IDP_external_uuid&quot;, returned_uuid)&#xa;                    user.variables.set(&quot;IDP_response_time&quot;, response_time)&#xa;                    return&#xa;&#xa;&#xa;                if resp.status_code == 424:&#xa;                    err = resp.json()&#xa;                    err_desc = err.get(&quot;error_description&quot;, &quot;Ошибка при обращении к IDP&quot;)&#xa;                    err_code = err.get(&quot;error_code&quot;, &quot;IDP_REQUEST_ERROR&quot;)&#xa;                    response_time = err.get(&quot;response_time&quot;, elapsed)&#xa;&#xa;&#xa;                    log(f&quot;IDP_SEARCH(async) ✖ 424 | {err_code}: {err_desc} | time={response_time:.2f}s&quot;, level=&quot;ERROR&quot;)&#xa;                    user.variables.set(&quot;IDP_answer&quot;, f&quot;{err_desc} (код: {err_code})&quot;)&#xa;                    user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;                    user.variables.set(&quot;IDP_response_time&quot;, response_time)&#xa;                    return&#xa;&#xa;&#xa;                # На 502/503/504 поделаем ретраи&#xa;                if resp.status_code in (502, 503, 504) and attempt &lt; attempts:&#xa;                    log(f&quot;IDP_SEARCH(async) ↻ retry {attempt}/{attempts-1} after {backoff:.1f}s (status {resp.status_code})&quot;)&#xa;                    await asyncio.sleep(backoff)&#xa;                    backoff *= 2&#xa;                    continue&#xa;&#xa;&#xa;                # Иначе — ошибка без ретрая&#xa;                body_preview = &quot;&quot;&#xa;                try:&#xa;                    body_preview = json.dumps(resp.json(), ensure_ascii=False)[:500]&#xa;                except Exception:&#xa;                    body_preview = (resp.text or &quot;&quot;)[:500]&#xa;&#xa;&#xa;                log(&#xa;                    f&quot;IDP_SEARCH(async) ✖ {resp.status_code} {resp.reason_phrase} | body=&#39;{body_preview}&#39;&quot;,&#xa;                    level=&quot;ERROR&quot;,&#xa;                )&#xa;                user.variables.set(&#xa;                    &quot;IDP_answer&quot;,&#xa;                    f&quot;Ошибка: {resp.status_code} {resp.reason_phrase}. Обратитесь к логам сервиса.&quot;,&#xa;                )&#xa;                user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;                user.variables.set(&quot;IDP_response_time&quot;, elapsed)&#xa;                return&#xa;&#xa;&#xa;            except (httpx.TimeoutException, httpx.TransportError) as e:&#xa;                if attempt &lt; attempts:&#xa;                    log(f&quot;IDP_SEARCH(async) ↻ retry {attempt}/{attempts-1} after {backoff:.1f}s due to network error: {e}&quot;)&#xa;                    await asyncio.sleep(backoff)&#xa;                    backoff *= 2&#xa;                    continue&#xa;&#xa;&#xa;                elapsed = time.perf_counter() - t0&#xa;                log(f&quot;IDP_SEARCH(async) ⚠ network/timeout error: {str(e)}&quot;, level=&quot;ERROR&quot;)&#xa;                user.variables.set(&quot;IDP_answer&quot;, &quot;Сетевая ошибка при обращении к /idp_search&quot;)&#xa;                user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;                user.variables.set(&quot;IDP_response_time&quot;, elapsed)&#xa;                return&#xa;&#xa;&#xa;&#xa;&#xa;if __name__ == &quot;__main__&quot;:&#xa;    # Пример запуска как у тебя, но через новый клиент&#xa;    questions = [&#xa;        &quot;Какие манипуляции с долгом возможны в отчетности?&quot;,&#xa;        &quot;По какому участнику сделки требуется построение прогноза движения денежных средств при установлении ИР на Консолидированную Группу?&quot;,&#xa;        &quot;На какой срок строятся будущие денежные потоки?&quot;,&#xa;        &quot;Как определить, что деятельность носит сезонный характер?&quot;,&#xa;        &quot;Можно ли строить будущие денежные потоки в иностранной валюте?&quot;,&#xa;        &quot;Относится ли к прочим изменениям увеличение срока действующей банковской гарантии?&quot;,&#xa;        &quot;Требуется ли проверка Fraud-риска по техническим изменениям?&quot;,&#xa;        &quot;Является ли прочим изменением продление периода выборки по сделке УФН?&quot;,&#xa;        &quot;Финансирует ли Банк казино?&quot;,&#xa;        &quot;Особенности финансирования по договорам простого товарищества&quot;,&#xa;        &quot;Может ли банк финансировать некоммерческие организации?&quot;,&#xa;    ]&#xa;&#xa;&#xa;    # Импорт твоей модели User остаётся прежним.&#xa;    # Ниже — простая заглушка. В реальном коде у тебя уже есть инстанс user.&#xa;    class _VarStore(dict):&#xa;        def set(self, k, v):&#xa;            self[k] = v&#xa;&#xa;&#xa;    class _User:&#xa;        def __init__(self):&#xa;            self.variables = _VarStore()&#xa;&#xa;&#xa;    for q in questions:&#xa;        u = _User()&#xa;        u.variables.set(&quot;IDP_question&quot;, q)&#xa;        run_idp_search(u)&#xa;        print(f&quot;Q: {q}\nA: {u.variables.get(&#39;IDP_answer&#39;)}\nUUID: {u.variables.get(&#39;IDP_external_uuid&#39;)}, &quot;&#xa;              f&quot;Time: {u.variables.get(&#39;IDP_response_time&#39;)}s\n{&#39;-&#39;*80}&quot;)" link="# idp_client.py&#xa;import os&#xa;import uuid&#xa;import time&#xa;import json&#xa;import requests&#xa;from typing import Optional, Tuple, Dict, Any, List&#xa;from requests.adapters import HTTPAdapter, Retry&#xa;&#xa;&#xa;from core.logging.logger_utils import log&#xa;from scenarios.user.user_model import User&#xa;&#xa;&#xa;&#xa;&#xa;# -----------------------------&#xa;# ВСПОМОГАТЕЛЬНЫЕ НАСТРОЙКИ&#xa;# -----------------------------&#xa;DEFAULT_API_BASE = os.getenv(&quot;IDP_GATEWAY_BASE&quot;, &quot;http://localhost:8000&quot;)  # где крутится твой FastAPI&#xa;ENDPOINT_PATH = os.getenv(&quot;IDP_SEARCH_PATH&quot;, &quot;/idp_search&quot;)&#xa;&#xa;&#xa;# Если ваш Depends(common_headers) ожидает определённые заголовки — добавь их в ENV и сюда&#xa;DEFAULT_HEADERS: Dict[str, str] = {&#xa;    &quot;accept&quot;: &quot;application/json&quot;,&#xa;    &quot;Content-Type&quot;: &quot;application/json&quot;,&#xa;    # Примеры корпоративных заголовков — подставь нужные, если требуется:&#xa;    # &quot;X-Request-Source&quot;: os.getenv(&quot;X_REQUEST_SOURCE&quot;, &quot;your-service&quot;),&#xa;    # &quot;X-Auth-Token&quot;: os.getenv(&quot;X_AUTH_TOKEN&quot;, &quot;&quot;),&#xa;}&#xa;&#xa;&#xa;REQUEST_TIMEOUT = float(os.getenv(&quot;IDP_CLIENT_TIMEOUT&quot;, &quot;30&quot;))  # сек.&#xa;RETRY_TOTAL = int(os.getenv(&quot;IDP_CLIENT_RETRY_TOTAL&quot;, &quot;3&quot;))&#xa;RETRY_BACKOFF = float(os.getenv(&quot;IDP_CLIENT_RETRY_BACKOFF&quot;, &quot;0.5&quot;))  # экспоненциальная пауза&#xa;&#xa;&#xa;&#xa;&#xa;def _build_session() -&gt; requests.Session:&#xa;    &quot;&quot;&quot;&#xa;    Готовим requests.Session с умным ретраем (на случай сетевых глюков, 502/503/504).&#xa;    &quot;&quot;&quot;&#xa;    session = requests.Session()&#xa;    retries = Retry(&#xa;        total=RETRY_TOTAL,&#xa;        backoff_factor=RETRY_BACKOFF,&#xa;        status_forcelist=(502, 503, 504),&#xa;        allowed_methods=frozenset([&quot;POST&quot;]),&#xa;        raise_on_status=False,&#xa;    )&#xa;    adapter = HTTPAdapter(max_retries=retries)&#xa;    session.mount(&quot;http://&quot;, adapter)&#xa;    session.mount(&quot;https://&quot;, adapter)&#xa;    return session&#xa;&#xa;&#xa;&#xa;&#xa;def _safe_get(dct: Dict[str, Any], path: List[str], default=None):&#xa;    &quot;&quot;&quot;&#xa;    Безопасно достаём значение из вложенного словаря по пути ключей.&#xa;    &quot;&quot;&quot;&#xa;    cur = dct&#xa;    for key in path:&#xa;        if not isinstance(cur, dict) or key not in cur:&#xa;            return default&#xa;        cur = cur[key]&#xa;    return cur&#xa;&#xa;&#xa;&#xa;&#xa;def _normalize_answer_text(text: str) -&gt; str:&#xa;    &quot;&quot;&quot;&#xa;    Хук на будущее: если когда-либо вернутся inline-ссылки вида [^1^],&#xa;    здесь можно будет подменять их на понятные ярлыки.&#xa;    Сейчас просто возвращаем как есть.&#xa;    &quot;&quot;&quot;&#xa;    return text&#xa;&#xa;&#xa;&#xa;&#xa;def _compose_url(base: str, path: str) -&gt; str:&#xa;    base = base.rstrip(&quot;/&quot;)&#xa;    path = path if path.startswith(&quot;/&quot;) else f&quot;/{path}&quot;&#xa;    return f&quot;{base}{path}&quot;&#xa;&#xa;&#xa;&#xa;&#xa;def run_idp_search(user: User, api_base: Optional[str] = None) -&gt; None:&#xa;    &quot;&quot;&quot;&#xa;    Отправляет вопрос на FastAPI эндпоинт /idp_search и записывает результат в user.variables.&#xa;&#xa;&#xa;    Вход:&#xa;        - user.variables[&#39;IDP_question&#39;] : строка вопроса.&#xa;    Выход:&#xa;        - user.variables[&#39;IDP_answer&#39;]         : текст ответа или текст ошибки.&#xa;        - user.variables[&#39;IDP_external_uuid&#39;]  : uuid запроса (если вернулся).&#xa;        - user.variables[&#39;IDP_response_time&#39;]  : время ответа в секундах (если вернулось).&#xa;&#xa;&#xa;    Исключения не пробрасываем — всё логируем и безопасно сохраняем в user.variables.&#xa;    &quot;&quot;&quot;&#xa;    question = user.variables.get(&quot;IDP_question&quot;, &quot;&quot;)&#xa;    if not isinstance(question, str) or len(question.strip()) &lt; 4:&#xa;        msg = &quot;Вопрос пустой или короче 4 символов — IDP его отклонит согласно модели схем.&quot;&#xa;        log(msg, level=&quot;ERROR&quot;)&#xa;        user.variables.set(&quot;IDP_answer&quot;, msg)&#xa;        return&#xa;&#xa;&#xa;    base = api_base or DEFAULT_API_BASE&#xa;    url = _compose_url(base, ENDPOINT_PATH)&#xa;&#xa;&#xa;    # Можно прокинуть trace-id в заголовки для сквозной трассировки&#xa;    external_uuid = str(uuid.uuid4())&#xa;&#xa;&#xa;    headers = dict(DEFAULT_HEADERS)&#xa;    headers[&quot;X-External-UUID&quot;] = external_uuid  # опционально — если на бэке это используется&#xa;&#xa;&#xa;    payload = {&quot;question&quot;: question}&#xa;&#xa;&#xa;    log(f&quot;IDP_SEARCH ▶ POST {url} | headers={headers} | payload={payload}&quot;)&#xa;&#xa;&#xa;    session = _build_session()&#xa;    t0 = time.perf_counter()&#xa;&#xa;&#xa;    try:&#xa;        resp = session.post(url, headers=headers, data=json.dumps(payload), timeout=REQUEST_TIMEOUT)&#xa;        elapsed = time.perf_counter() - t0&#xa;&#xa;&#xa;        # 200 OK — успешный ответ&#xa;        if resp.status_code == 200:&#xa;            data = resp.json()&#xa;&#xa;&#xa;            answer = _safe_get(data, [&quot;answer&quot;], &quot;&quot;)&#xa;            response_time = _safe_get(data, [&quot;response_time&quot;], elapsed)&#xa;            returned_uuid = _safe_get(data, [&quot;external_uuid&quot;], external_uuid)&#xa;&#xa;&#xa;            normalized_answer = _normalize_answer_text(answer)&#xa;&#xa;&#xa;            log(&#xa;                f&quot;IDP_SEARCH ✔ 200 | time={response_time:.2f}s | uuid={returned_uuid} | &quot;&#xa;                f&quot;answer_preview=&#39;{(normalized_answer or &#39;&#39;)[:180]}...&#39;&quot;,&#xa;                level=&quot;INFO&quot;,&#xa;            )&#xa;&#xa;&#xa;            user.variables.set(&quot;IDP_answer&quot;, normalized_answer or &quot;&quot;)&#xa;            user.variables.set(&quot;IDP_external_uuid&quot;, returned_uuid)&#xa;            user.variables.set(&quot;IDP_response_time&quot;, response_time)&#xa;            return&#xa;&#xa;&#xa;        # 424 — проксируем описание ошибки из тела по вашей схеме IDPErrorResponse&#xa;        if resp.status_code == 424:&#xa;            try:&#xa;                err = resp.json()&#xa;            except Exception:&#xa;                err = {}&#xa;&#xa;&#xa;            err_desc = _safe_get(err, [&quot;error_description&quot;], &quot;Ошибка при обращении к IDP&quot;)&#xa;            err_code = _safe_get(err, [&quot;error_code&quot;], &quot;IDP_REQUEST_ERROR&quot;)&#xa;            response_time = _safe_get(err, [&quot;response_time&quot;], time.perf_counter() - t0)&#xa;&#xa;&#xa;            log(f&quot;IDP_SEARCH ✖ 424 | {err_code}: {err_desc} | time={response_time:.2f}s&quot;, level=&quot;ERROR&quot;)&#xa;&#xa;&#xa;            user.variables.set(&quot;IDP_answer&quot;, f&quot;{err_desc} (код: {err_code})&quot;)&#xa;            user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;            user.variables.set(&quot;IDP_response_time&quot;, response_time)&#xa;            return&#xa;&#xa;&#xa;        # Прочие статусы — максимально информативный лог + тело&#xa;        body_preview = &quot;&quot;&#xa;        try:&#xa;            body_preview = json.dumps(resp.json(), ensure_ascii=False)[:500]&#xa;        except Exception:&#xa;            body_preview = (resp.text or &quot;&quot;)[:500]&#xa;&#xa;&#xa;        log(&#xa;            f&quot;IDP_SEARCH ✖ {resp.status_code} {resp.reason} | body=&#39;{body_preview}&#39;&quot;,&#xa;            level=&quot;ERROR&quot;,&#xa;        )&#xa;&#xa;&#xa;        user.variables.set(&#xa;            &quot;IDP_answer&quot;,&#xa;            f&quot;Ошибка: {resp.status_code} {resp.reason}. Обратитесь к логам сервиса.&quot;,&#xa;        )&#xa;        user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;        user.variables.set(&quot;IDP_response_time&quot;, time.perf_counter() - t0)&#xa;&#xa;&#xa;    except requests.Timeout as e:&#xa;        elapsed = time.perf_counter() - t0&#xa;        log(f&quot;IDP_SEARCH ⏱ timeout after {elapsed:.2f}s: {str(e)}&quot;, level=&quot;ERROR&quot;)&#xa;        user.variables.set(&quot;IDP_answer&quot;, &quot;Timeout при обращении к /idp_search&quot;)&#xa;        user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;        user.variables.set(&quot;IDP_response_time&quot;, elapsed)&#xa;&#xa;&#xa;    except requests.RequestException as e:&#xa;        elapsed = time.perf_counter() - t0&#xa;        log(f&quot;IDP_SEARCH ⚠ network error: {str(e)}&quot;, level=&quot;ERROR&quot;)&#xa;        user.variables.set(&quot;IDP_answer&quot;, &quot;Сетевая ошибка при обращении к /idp_search&quot;)&#xa;        user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;        user.variables.set(&quot;IDP_response_time&quot;, elapsed)&#xa;&#xa;&#xa;    except Exception as e:&#xa;        elapsed = time.perf_counter() - t0&#xa;        log(f&quot;IDP_SEARCH ☠ unexpected error: {str(e)}&quot;, level=&quot;ERROR&quot;)&#xa;        user.variables.set(&quot;IDP_answer&quot;, &quot;Неожиданная ошибка клиента IDP&quot;)&#xa;        user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;        user.variables.set(&quot;IDP_response_time&quot;, elapsed)&#xa;&#xa;&#xa;&#xa;&#xa;# --------------------------------------&#xa;# НЕОБЯЗАТЕЛЬНО: асинхронная версия (httpx)&#xa;# --------------------------------------&#xa;# Используй, если у тебя асинхронный воркер, и хочется не блокировать луп.&#xa;# Поведение и контракты идентичны синхронной версии.&#xa;async def run_idp_search_async(user: User, api_base: Optional[str] = None) -&gt; None:&#xa;    import httpx&#xa;    import asyncio&#xa;&#xa;&#xa;    question = user.variables.get(&quot;IDP_question&quot;, &quot;&quot;)&#xa;    if not isinstance(question, str) or len(question.strip()) &lt; 4:&#xa;        msg = &quot;Вопрос пустой или короче 4 символов — IDP его отклонит согласно модели схем.&quot;&#xa;        log(msg, level=&quot;ERROR&quot;)&#xa;        user.variables.set(&quot;IDP_answer&quot;, msg)&#xa;        return&#xa;&#xa;&#xa;    base = api_base or DEFAULT_API_BASE&#xa;    url = _compose_url(base, ENDPOINT_PATH)&#xa;&#xa;&#xa;    external_uuid = str(uuid.uuid4())&#xa;    headers = dict(DEFAULT_HEADERS)&#xa;    headers[&quot;X-External-UUID&quot;] = external_uuid&#xa;&#xa;&#xa;    payload = {&quot;question&quot;: question}&#xa;    log(f&quot;IDP_SEARCH(async) ▶ POST {url} | headers={headers} | payload={payload}&quot;)&#xa;&#xa;&#xa;    # Ретраи вручную, т.к. httpx не имеет встроенного Retry, как requests+urllib3&#xa;    attempts = RETRY_TOTAL + 1&#xa;    backoff = RETRY_BACKOFF&#xa;&#xa;&#xa;    t0 = time.perf_counter()&#xa;&#xa;&#xa;    async with httpx.AsyncClient(timeout=REQUEST_TIMEOUT) as client:&#xa;        for attempt in range(1, attempts + 1):&#xa;            try:&#xa;                resp = await client.post(url, headers=headers, json=payload)&#xa;                elapsed = time.perf_counter() - t0&#xa;&#xa;&#xa;                if resp.status_code == 200:&#xa;                    data = resp.json()&#xa;                    answer = data.get(&quot;answer&quot;, &quot;&quot;)&#xa;                    response_time = data.get(&quot;response_time&quot;, elapsed)&#xa;                    returned_uuid = data.get(&quot;external_uuid&quot;, external_uuid)&#xa;&#xa;&#xa;                    normalized_answer = _normalize_answer_text(answer)&#xa;                    log(&#xa;                        f&quot;IDP_SEARCH(async) ✔ 200 | time={response_time:.2f}s | uuid={returned_uuid} | &quot;&#xa;                        f&quot;answer_preview=&#39;{(normalized_answer or &#39;&#39;)[:180]}...&#39;&quot;,&#xa;                        level=&quot;INFO&quot;,&#xa;                    )&#xa;                    user.variables.set(&quot;IDP_answer&quot;, normalized_answer or &quot;&quot;)&#xa;                    user.variables.set(&quot;IDP_external_uuid&quot;, returned_uuid)&#xa;                    user.variables.set(&quot;IDP_response_time&quot;, response_time)&#xa;                    return&#xa;&#xa;&#xa;                if resp.status_code == 424:&#xa;                    err = resp.json()&#xa;                    err_desc = err.get(&quot;error_description&quot;, &quot;Ошибка при обращении к IDP&quot;)&#xa;                    err_code = err.get(&quot;error_code&quot;, &quot;IDP_REQUEST_ERROR&quot;)&#xa;                    response_time = err.get(&quot;response_time&quot;, elapsed)&#xa;&#xa;&#xa;                    log(f&quot;IDP_SEARCH(async) ✖ 424 | {err_code}: {err_desc} | time={response_time:.2f}s&quot;, level=&quot;ERROR&quot;)&#xa;                    user.variables.set(&quot;IDP_answer&quot;, f&quot;{err_desc} (код: {err_code})&quot;)&#xa;                    user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;                    user.variables.set(&quot;IDP_response_time&quot;, response_time)&#xa;                    return&#xa;&#xa;&#xa;                # На 502/503/504 поделаем ретраи&#xa;                if resp.status_code in (502, 503, 504) and attempt &lt; attempts:&#xa;                    log(f&quot;IDP_SEARCH(async) ↻ retry {attempt}/{attempts-1} after {backoff:.1f}s (status {resp.status_code})&quot;)&#xa;                    await asyncio.sleep(backoff)&#xa;                    backoff *= 2&#xa;                    continue&#xa;&#xa;&#xa;                # Иначе — ошибка без ретрая&#xa;                body_preview = &quot;&quot;&#xa;                try:&#xa;                    body_preview = json.dumps(resp.json(), ensure_ascii=False)[:500]&#xa;                except Exception:&#xa;                    body_preview = (resp.text or &quot;&quot;)[:500]&#xa;&#xa;&#xa;                log(&#xa;                    f&quot;IDP_SEARCH(async) ✖ {resp.status_code} {resp.reason_phrase} | body=&#39;{body_preview}&#39;&quot;,&#xa;                    level=&quot;ERROR&quot;,&#xa;                )&#xa;                user.variables.set(&#xa;                    &quot;IDP_answer&quot;,&#xa;                    f&quot;Ошибка: {resp.status_code} {resp.reason_phrase}. Обратитесь к логам сервиса.&quot;,&#xa;                )&#xa;                user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;                user.variables.set(&quot;IDP_response_time&quot;, elapsed)&#xa;                return&#xa;&#xa;&#xa;            except (httpx.TimeoutException, httpx.TransportError) as e:&#xa;                if attempt &lt; attempts:&#xa;                    log(f&quot;IDP_SEARCH(async) ↻ retry {attempt}/{attempts-1} after {backoff:.1f}s due to network error: {e}&quot;)&#xa;                    await asyncio.sleep(backoff)&#xa;                    backoff *= 2&#xa;                    continue&#xa;&#xa;&#xa;                elapsed = time.perf_counter() - t0&#xa;                log(f&quot;IDP_SEARCH(async) ⚠ network/timeout error: {str(e)}&quot;, level=&quot;ERROR&quot;)&#xa;                user.variables.set(&quot;IDP_answer&quot;, &quot;Сетевая ошибка при обращении к /idp_search&quot;)&#xa;                user.variables.set(&quot;IDP_external_uuid&quot;, external_uuid)&#xa;                user.variables.set(&quot;IDP_response_time&quot;, elapsed)&#xa;                return&#xa;&#xa;&#xa;&#xa;&#xa;if __name__ == &quot;__main__&quot;:&#xa;    # Пример запуска как у тебя, но через новый клиент&#xa;    questions = [&#xa;        &quot;Какие манипуляции с долгом возможны в отчетности?&quot;,&#xa;        &quot;По какому участнику сделки требуется построение прогноза движения денежных средств при установлении ИР на Консолидированную Группу?&quot;,&#xa;        &quot;На какой срок строятся будущие денежные потоки?&quot;,&#xa;        &quot;Как определить, что деятельность носит сезонный характер?&quot;,&#xa;        &quot;Можно ли строить будущие денежные потоки в иностранной валюте?&quot;,&#xa;        &quot;Относится ли к прочим изменениям увеличение срока действующей банковской гарантии?&quot;,&#xa;        &quot;Требуется ли проверка Fraud-риска по техническим изменениям?&quot;,&#xa;        &quot;Является ли прочим изменением продление периода выборки по сделке УФН?&quot;,&#xa;        &quot;Финансирует ли Банк казино?&quot;,&#xa;        &quot;Особенности финансирования по договорам простого товарищества&quot;,&#xa;        &quot;Может ли банк финансировать некоммерческие организации?&quot;,&#xa;    ]&#xa;&#xa;&#xa;    # Импорт твоей модели User остаётся прежним.&#xa;    # Ниже — простая заглушка. В реальном коде у тебя уже есть инстанс user.&#xa;    class _VarStore(dict):&#xa;        def set(self, k, v):&#xa;            self[k] = v&#xa;&#xa;&#xa;    class _User:&#xa;        def __init__(self):&#xa;            self.variables = _VarStore()&#xa;&#xa;&#xa;    for q in questions:&#xa;        u = _User()&#xa;        u.variables.set(&quot;IDP_question&quot;, q)&#xa;        run_idp_search(u)&#xa;        print(f&quot;Q: {q}\nA: {u.variables.get(&#39;IDP_answer&#39;)}\nUUID: {u.variables.get(&#39;IDP_external_uuid&#39;)}, &quot;&#xa;              f&quot;Time: {u.variables.get(&#39;IDP_response_time&#39;)}s\n{&#39;-&#39;*80}&quot;)" id="xQ9-_gr5QTslfE1LpaSg-1">
          <mxCell style="text;whiteSpace=wrap;" parent="1" vertex="1">
            <mxGeometry x="1710" y="480" width="560" height="6030" as="geometry" />
          </mxCell>
        </UserObject>
        <UserObject label="from datetime import datetime, timezone, timedelta&#xa;&#xa;&#xa;def request_time_header(offset_hours: int = 3) -&gt; str:&#xa;    &quot;&quot;&quot;Возвращает строку формата &#39;Request-Time: 2025-08-25T22:58:32.469340+03:00&#39;.&quot;&quot;&quot;&#xa;    tz = timezone(timedelta(hours=offset_hours))&#xa;    now = datetime.now(tz)  # TZ-aware&#xa;    # isoformat уже включает оффсет как +HH:MM, микросекунды идут по умолчанию&#xa;    return f&quot;Request-Time: {now.isoformat()}&quot;" link="from datetime import datetime, timezone, timedelta&#xa;&#xa;&#xa;def request_time_header(offset_hours: int = 3) -&gt; str:&#xa;    &quot;&quot;&quot;Возвращает строку формата &#39;Request-Time: 2025-08-25T22:58:32.469340+03:00&#39;.&quot;&quot;&quot;&#xa;    tz = timezone(timedelta(hours=offset_hours))&#xa;    now = datetime.now(tz)  # TZ-aware&#xa;    # isoformat уже включает оффсет как +HH:MM, микросекунды идут по умолчанию&#xa;    return f&quot;Request-Time: {now.isoformat()}&quot;" id="xQ9-_gr5QTslfE1LpaSg-2">
          <mxCell style="text;whiteSpace=wrap;" parent="1" vertex="1">
            <mxGeometry x="1460" y="700" width="520" height="150" as="geometry" />
          </mxCell>
        </UserObject>
        <mxCell id="zrVG6-NDoNrXuYY_pH4w-1" value="Ты - система информационного поиска. Тебе дан вопрос и набор контекстов, являющихся релевантными отрывками текста из нескольких документов ([passage]) или элементами FAQ ([FAQ]).&#xa;Создай краткий и информативный ответ (не более 150 слов) на заданный вопрос, основываясь исключительно на приведенных контекстах. Ты должна использовать только информацию из приведенных контекстов.&#xa;Используй непредвзятый и журналистский тон. Не повторяй текст.&#xa;Создай окончательный ответ (&quot;FINAL ANSWER&quot;), в котором после КАЖДОЙ СМЫСЛОВОЙ ЧАСТИ ДОЛЖЕН быть добавлен источник (&quot;[^i^]&quot;), откуда была взята информация для формирования ответа на вопрос.&#xa;Не выводи подряд одинаковые источники, выведи один актуальный.&#xa;Ответ должен быть красиво отформатирован абзацами.&#xa;Не пытайся придумать ответ.&#xa;Отвечай только на русском языке за исключением специальных терминов.&#xa;Если отрывки не содержат ответа на вопрос, отвечай: &#39;По данному вопросу необходимо обратиться в техподдержку&#39;.&#xa;&#xa;&#xa;ПРИМЕР:&#xa;QUESTION: Законодательство какого штата/страны регулирует толкование контракта?&#xa;=========&#xa;Content: [FAQ] Вопрос: В какой стране законодальтсво регулирует толкование контракта?&#xa;Ответ: Настоящее Соглашение регулируется английским законодательством.&#xa;Source: 1&#xa;Content: [passage] Никаких отказов. Неисполнение или задержка в осуществлении какого-либо права или средства правовой защиты в соответствии с настоящим Соглашением не является отказом от такого (или любого другого) права или средства правовой защиты.&#xa;&#xa;&#xa;11.7 Возможность разделения. Недействительность, незаконность или неисполнимость любого условия (или части срока) настоящего Соглашения не влияет на сохранение в силе оставшегося срока (если таковой имеется) и настоящего Соглашения.&#xa;&#xa;&#xa;11.8 Нет Агентства. За исключением случаев, когда прямо указано иное, ничто в настоящем Соглашении не создает агентства, партнерства или совместного предприятия любого рода между сторонами.&#xa;&#xa;&#xa;11.9 Никаких сторонних бенефициаров.&#xa;Source: 2&#xa;Content: [passage] (б) если Google добросовестно полагает, что Дистрибьютор нарушил или вынудил Google нарушить какие-либо законы о борьбе со взяточничеством (как определено в пункте 8.5) или что такое нарушение с достаточной вероятностью произойдет,&#xa;Source: 3&#xa;Content: [passage] Также законодательство предусматривает случаи, когда Соглашение может быть исполнено законодательством внутренних административных единиц, но для этого нужно специальное разрешение английского суда.&#xa;Source: 4&#xa;=========&#xa;FINAL ANSWER: Настоящее Соглашение регулируется английским законодательством [^1^]. Также предусматриваются случаи, когда Соглашение может быть исполнено внутренними административными единицами, но для этого нужно разрешение английского суда. [^4^].&#xa;&#xa;&#xa;ПРИМЕР:&#xa;QUESTION: Как открыть брокерский счет и сколько это будет стоить?&#xa;=========&#xa;Content:[FAQ] Секция: открытие счетов&#xa;Вопрос: Как открыть брокерский счёт&#xa;Ответ: Для того, чтобы открыть брокерский счёт, нужно в приложении «Сбербанк онлайн» перейти в раздел «Накопления» и нажать на «плюс» справа у раздела «Инвестиции». Далее, следуйте инструкциям.&#xa;Source: 1&#xa;Content: [FAQ] Секция: открытие счетов&#xa;Вопрос:  Какие привилегии дает СберПремьер&#xa;Ответ: Привилегии СберПремьер – это сервис повышенного комфорта, страхование в путешествиях, повышенный кешбэк бонусами и премиальная поддержка, повышенный лимит на переводы и платежи без комиссии, а также скидки от партнеров Сбера.&#xa;Source: 2&#xa;Content:[FAQ] Секция: открытие счетов&#xa;Вопрос: Является ли открытие и обслуживание брокерского счёта платным?&#xa;Ответ: Открытие и обслуживание брокерского счёта в СберБанке бесплатно.&#xa;Source: 3&#xa;=========&#xa;FINAL ANSWER:&#xa;Выполните следующие действия:&#xa;1. В приложении «Сбербанк онлайн» перейдите в раздел «Накопления»&#xa;2. Нажмите на «плюс» рядом с «Инвестиции».&#xa;3. Следуйте инструкциям. [^1^].&#xa;Открытие и обслуживание брокерского счёта бесплатно. [^3^]." style="text;whiteSpace=wrap;" parent="1" vertex="1">
          <mxGeometry x="120" y="150" width="560" height="1190" as="geometry" />
        </mxCell>
        <mxCell id="zntTJmJaQ5f6_OLdWCkL-1" value="Ты — система информационного поиска. Входные данные: QUESTION и набор контекстов — релевантные отрывки из документов ([passage]) или элементов FAQ ([FAQ]) с пометками Source: i.&#xa;&lt;p data-start=&quot;337&quot; data-end=&quot;428&quot;&gt;ЗАДАЧА: Сформируй краткий и информативный ответ (≤150 слов) строго по данным из контекстов.&lt;/p&gt;&#xa;&lt;p data-start=&quot;430&quot; data-end=&quot;450&quot;&gt;ТРЕБОВАНИЯ К ОТВЕТУ:&lt;/p&gt;&#xa;&lt;ol data-start=&quot;451&quot; data-end=&quot;1195&quot;&gt;&#xa;&lt;li data-start=&quot;451&quot; data-end=&quot;546&quot;&gt;&#xa;&lt;p data-start=&quot;454&quot; data-end=&quot;546&quot;&gt;Итоговый формат — &quot;FINAL ANSWER&quot; как компактный «Краткий отчёт»: 3–5 пунктов или 2–3 абзаца.&lt;/p&gt;&#xa;&lt;/li&gt;&#xa;&lt;li data-start=&quot;547&quot; data-end=&quot;685&quot;&gt;&#xa;&lt;p data-start=&quot;550&quot; data-end=&quot;685&quot;&gt;После КАЖДОЙ смысловой части обязательно добавляй источник в формате [^i^]. Не выводи подряд одинаковые источники — чередуй актуальные.&lt;/p&gt;&#xa;&lt;/li&gt;&#xa;&lt;li data-start=&quot;686&quot; data-end=&quot;899&quot;&gt;&#xa;&lt;p data-start=&quot;689&quot; data-end=&quot;899&quot;&gt;Используй только предоставленные фрагменты. Не фантазируй. Если ответа нет или сведения противоречатся и не позволяют дать однозначный вывод — отвечай: &#39;По данному вопросу необходимо обратиться в техподдержку&#39;.&lt;/p&gt;&#xa;&lt;/li&gt;&#xa;&lt;li data-start=&quot;900&quot; data-end=&quot;980&quot;&gt;&#xa;&lt;p data-start=&quot;903&quot; data-end=&quot;980&quot;&gt;Пиши нейтрально (журналистский тон), не копируй текст из источников дословно.&lt;/p&gt;&#xa;&lt;/li&gt;&#xa;&lt;li data-start=&quot;981&quot; data-end=&quot;1140&quot;&gt;&#xa;&lt;p data-start=&quot;984&quot; data-end=&quot;1140&quot;&gt;Нормализуй цифры и сроки (валюта, проценты, даты) и укажи ограничения/исключения, если они есть. При наличии дат упомяни актуальную (самую позднюю) с [^i^].&lt;/p&gt;&#xa;&lt;/li&gt;&#xa;&lt;li data-start=&quot;1141&quot; data-end=&quot;1195&quot;&gt;&#xa;&lt;p data-start=&quot;1144&quot; data-end=&quot;1195&quot;&gt;Язык — русский (кроме специализированных терминов).&lt;/p&gt;&#xa;&lt;/li&gt;&#xa;&lt;/ol&gt;&#xa;&lt;p data-start=&quot;1197&quot; data-end=&quot;1218&quot;&gt;ПРИОРИТЕТ ИНФОРМАЦИИ:&lt;/p&gt;&#xa;&lt;ul data-start=&quot;1219&quot; data-end=&quot;1402&quot;&gt;&#xa;&lt;li data-start=&quot;1219&quot; data-end=&quot;1402&quot;&gt;&#xa;&lt;p data-start=&quot;1221&quot; data-end=&quot;1402&quot;&gt;Если есть [FAQ], используй как первичный источник факта; детали и условия дополняй из [passage]. При конфликтах отдай приоритет более свежему фрагменту (по явной дате), затем [FAQ].&lt;/p&gt;&#xa;&lt;/li&gt;&#xa;&lt;/ul&gt;&#xa;&lt;p data-start=&quot;1404&quot; data-end=&quot;1443&quot;&gt;ВЫВОДИ только &quot;FINAL ANSWER&quot;.&lt;br&gt;&#xa;&amp;lt;/prompt&amp;gt;&lt;/p&gt;&#xa;&lt;p data-start=&quot;1445&quot; data-end=&quot;1468&quot;&gt;ПЕРЕОСМЫСЛЕННЫЕ ПРИМЕРЫ&lt;/p&gt;&#xa;&lt;h1 data-start=&quot;1470&quot; data-end=&quot;1559&quot;&gt;ПРИМЕР:&lt;br&gt;&#xa;QUESTION: Как изменить суточный лимит переводов в мобильном приложении?&lt;/h1&gt;&#xa;&lt;h1 data-start=&quot;1560&quot; data-end=&quot;2102&quot;&gt;Content: [FAQ] Вопрос: Где изменить лимиты?&lt;br&gt;&#xa;Ответ: В приложении: Профиль → Настройки → Лимиты по операциям. [Изменения вступают в силу сразу после подтверждения].&lt;br&gt;&#xa;Source: 1&lt;br&gt;&#xa;Content: [passage] Максимальный суточный лимит для переводов физлиц — 1 000 000 ₽; банк может запросить доп. подтверждение при повышении лимита.&lt;br&gt;&#xa;Source: 2&lt;br&gt;&#xa;Content: [passage] При увеличении лимита требуется SMS/Push-подтверждение; снижение лимита доступно без подтверждения.&lt;br&gt;&#xa;Source: 3&lt;br&gt;&#xa;Content: [passage] Комиссия за изменение лимита не взимается.&lt;br&gt;&#xa;Source: 4&lt;/h1&gt;&#xa;&lt;p data-start=&quot;2103&quot; data-end=&quot;2508&quot;&gt;FINAL ANSWER:&lt;br&gt;&#xa;Итог: Лимит меняется в приложении: Профиль → Настройки → Лимиты по операциям; действует после подтверждения. [^1^]&lt;br data-start=&quot;2231&quot; data-end=&quot;2234&quot;&gt;&#xa;Шаги: Откройте раздел, укажите новый суточный предел и подтвердите SMS/Push (для повышения); снижение — без подтверждения. [^3^]&lt;br data-start=&quot;2362&quot; data-end=&quot;2365&quot;&gt;&#xa;Условия: Максимум 1 000 000 ₽ в сутки; при повышении возможна доп. проверка. [^2^]&lt;br data-start=&quot;2447&quot; data-end=&quot;2450&quot;&gt;&#xa;Стоимость: Комиссия за изменение лимита отсутствует. [^4^]&lt;/p&gt;&#xa;&lt;h1 data-start=&quot;2510&quot; data-end=&quot;2594&quot;&gt;ПРИМЕР:&lt;br&gt;&#xa;QUESTION: Как закрыть накопительный счёт и что будет с процентами?&lt;/h1&gt;&#xa;&lt;h1 data-start=&quot;2595&quot; data-end=&quot;2997&quot;&gt;Content: [FAQ] Вопрос: Как закрыть накопительный счёт?&lt;br&gt;&#xa;Ответ: Приложение → Продукты → Счета → Выбрать счёт → Закрыть.&lt;br&gt;&#xa;Source: 1&lt;br&gt;&#xa;Content: [passage] Проценты начисляются по день закрытия включительно; перевод остатка — на связанный счёт до 1 рабочего дня.&lt;br&gt;&#xa;Source: 2&lt;br&gt;&#xa;Content: [passage] При активной капитализации начисленные проценты добавляются к основному остатку перед закрытием.&lt;br&gt;&#xa;Source: 3&lt;/h1&gt;&#xa;&lt;p data-start=&quot;2998&quot; data-end=&quot;3279&quot;&gt;FINAL ANSWER:&lt;br&gt;&#xa;Шаги: Приложение → Продукты → Счета → выбрать счёт → «Закрыть». [^1^]&lt;br data-start=&quot;3081&quot; data-end=&quot;3084&quot;&gt;&#xa;Проценты: Начисляются по день закрытия включительно; при капитализации они прибавляются к остатку перед закрытием. [^2^][^3^]&lt;br data-start=&quot;3209&quot; data-end=&quot;3212&quot;&gt;&#xa;Сроки: Перевод остатка на связанный счёт — до 1 рабочего дня. [^2^]&lt;/p&gt;&#xa;&lt;h1 data-start=&quot;3281&quot; data-end=&quot;3387&quot;&gt;ПРИМЕР:&lt;br&gt;&#xa;QUESTION: Требуется ли согласие клиента на обработку данных при выпуске дебетовой карты?&lt;/h1&gt;&#xa;&lt;h1 data-start=&quot;3388&quot; data-end=&quot;3664&quot;&gt;Content: [passage] Заявка на дебетовую карту оформляется с согласием на обработку ПДн; без согласия выпуск невозможен.&lt;br&gt;&#xa;Source: 1&lt;br&gt;&#xa;Content: [FAQ] Вопрос: Где дать согласие?&lt;br&gt;&#xa;Ответ: В анкете заявки — чекбокс «Согласие на обработку ПДн» и подтверждение кодом.&lt;br&gt;&#xa;Source: 2&lt;/h1&gt;&#xa;&lt;p data-start=&quot;3665&quot; data-end=&quot;3868&quot; data-is-only-node=&quot;&quot;&gt;FINAL ANSWER:&lt;br&gt;&#xa;Правило: Выпуск дебетовой карты возможен только при наличии согласия на обработку персональных данных. [^1^]&lt;br data-start=&quot;3787&quot; data-end=&quot;3790&quot;&gt;&#xa;Как дать согласие: Отметьте чекбокс в анкете заявки и подтвердите кодом. [^2^]&lt;/p&gt;" style="text;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="750" y="250" width="560" height="4090" as="geometry" />
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
