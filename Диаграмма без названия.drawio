<mxfile host="app.diagrams.net" agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36" version="27.1.1">
  <diagram name="Страница — 1" id="WULPb32uHRo-QUS4CWuH">
    <mxGraphModel dx="1152" dy="692" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="827" pageHeight="1169" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <UserObject label="// solutions.js&#xa;&#xa;&#xa;const SOLUTIONS = {&#xa;  &quot;PS+.OTH.PROB.02&quot;: &quot;Если решение по сделке принято в АС УВЗ, проверьте внесённый в сделке УПР и ФПР. В поле «Требуется НЭР» должен стоять ответ «Нет».\n\nВнесите мотивированное суждение об отказе рассмотрения сделки в АС Сенат, так как задача уже направлялась через АС УВЗ. Укажите дату и номер принятого решения.&quot;,&#xa;  &quot;PS+.OTH.PROB.03&quot;: &quot;Посмотрите на возможные причины блокировки процесса перехода в АС УВЗ: \n1. Кредитный инспектор не имеет доступа в АС УВЗ с ролью «Исполнитель КП». Данная роль необходима, поскольку пользователь передается, как лидер по активу. При отсутствии роли необходимо оформить доступ к АС УВЗ, запросив роль «Исполнитель КП». \n2. В АС УВЗ кредитный инспектор сделки не назначен лидером по активу. Для назначения лидера по активу необходимо обратиться к ответственному сотруднику в вашем территориальном банке за распределение проблемного актива, который имеет роль в системе «Распределитель ПА», или обратиться в АС Друг по шаблону «Консультация/запрос информации у Бизнес-сопровождения». В запросе необходимо указать ИНН проблемного актива и ФИО того, кого нужно назначить лидером.\n3. В команде сделки есть уволенный руководитель клиентского менеджера. Нужно заменить в сделке данного сотрудника | Подробную информацию по оформлению доступа и началу работы в АС УВЗ можно найти по ссылке ниже | В случае, если рекомендация не помогла, давайте оформим обращение в поддержку&quot;,&#xa;  &quot;PS+.OTH.PROB.04&quot;: &quot;Для успешной отправки риск-сегмента на утверждение необходимо:\n1. При заполнении риск-сегмента указывать ID сделки УВЗ (в формате UDL-...), выбрав параметр «КФЮЛ ID». Запрос на НЭР отправляется из АС УВЗ\n2. Проверить, что риск - сегмент был направлен на утверждение. После расчета риск - сегмента нужно нажать на кнопку «Отправить на утверждение» | В остальных случаях давайте оформим обращение в поддержку&quot;,&#xa;  &quot;PS+.FOK..00&quot;: &quot;У меня обширная база знаний по работе с финансовыми документами клиента (ФДК/ФОК). Выберите ситуацию, и я предложу подходящее решение | Если вашей проблемы нет в списке, давайте оформим обращение&quot;,&#xa;  &quot;PS+.FOK.DOC.00&quot;: &quot;Вывел на экран ситуации, в которых могут возникнуть проблемы с созданием или утверждением документа. Выберите ситуацию для вашего случая&quot;,&#xa;  // Добавьте сюда другие коды и решения&#xa;  &quot;PS+.FOK.DOC.05&quot;: &quot;Это пример описания для кода 05. Используется для демонстрации поиска.&quot;&#xa;};" link="// solutions.js&#xa;&#xa;&#xa;const SOLUTIONS = {&#xa;  &quot;PS+.OTH.PROB.02&quot;: &quot;Если решение по сделке принято в АС УВЗ, проверьте внесённый в сделке УПР и ФПР. В поле «Требуется НЭР» должен стоять ответ «Нет».\n\nВнесите мотивированное суждение об отказе рассмотрения сделки в АС Сенат, так как задача уже направлялась через АС УВЗ. Укажите дату и номер принятого решения.&quot;,&#xa;  &quot;PS+.OTH.PROB.03&quot;: &quot;Посмотрите на возможные причины блокировки процесса перехода в АС УВЗ: \n1. Кредитный инспектор не имеет доступа в АС УВЗ с ролью «Исполнитель КП». Данная роль необходима, поскольку пользователь передается, как лидер по активу. При отсутствии роли необходимо оформить доступ к АС УВЗ, запросив роль «Исполнитель КП». \n2. В АС УВЗ кредитный инспектор сделки не назначен лидером по активу. Для назначения лидера по активу необходимо обратиться к ответственному сотруднику в вашем территориальном банке за распределение проблемного актива, который имеет роль в системе «Распределитель ПА», или обратиться в АС Друг по шаблону «Консультация/запрос информации у Бизнес-сопровождения». В запросе необходимо указать ИНН проблемного актива и ФИО того, кого нужно назначить лидером.\n3. В команде сделки есть уволенный руководитель клиентского менеджера. Нужно заменить в сделке данного сотрудника | Подробную информацию по оформлению доступа и началу работы в АС УВЗ можно найти по ссылке ниже | В случае, если рекомендация не помогла, давайте оформим обращение в поддержку&quot;,&#xa;  &quot;PS+.OTH.PROB.04&quot;: &quot;Для успешной отправки риск-сегмента на утверждение необходимо:\n1. При заполнении риск-сегмента указывать ID сделки УВЗ (в формате UDL-...), выбрав параметр «КФЮЛ ID». Запрос на НЭР отправляется из АС УВЗ\n2. Проверить, что риск - сегмент был направлен на утверждение. После расчета риск - сегмента нужно нажать на кнопку «Отправить на утверждение» | В остальных случаях давайте оформим обращение в поддержку&quot;,&#xa;  &quot;PS+.FOK..00&quot;: &quot;У меня обширная база знаний по работе с финансовыми документами клиента (ФДК/ФОК). Выберите ситуацию, и я предложу подходящее решение | Если вашей проблемы нет в списке, давайте оформим обращение&quot;,&#xa;  &quot;PS+.FOK.DOC.00&quot;: &quot;Вывел на экран ситуации, в которых могут возникнуть проблемы с созданием или утверждением документа. Выберите ситуацию для вашего случая&quot;,&#xa;  // Добавьте сюда другие коды и решения&#xa;  &quot;PS+.FOK.DOC.05&quot;: &quot;Это пример описания для кода 05. Используется для демонстрации поиска.&quot;&#xa;};" id="KhpofreyqJjnModskH-O-11">
          <mxCell style="text;whiteSpace=wrap;" vertex="1" parent="1">
            <mxGeometry x="90" y="290" width="560" height="560" as="geometry" />
          </mxCell>
        </UserObject>
        <UserObject label="// config.js&#xa;&#xa;&#xa;const CONFIG = {&#xa;    // --- Основной API для поиска кода ---&#xa;    SEARCH_API_KEY: &quot;&quot;, &#xa;    SEARCH_API_ENDPOINT: &quot;https://aigateway.delta.sbrf.ru/api/v1/run/d38cde4a-0ddc-4b34-afb6-5b15202474e6?stream=false&quot;,&#xa;&#xa;&#xa;    // --- Дополнительный API для УТОЧНЕНИЯ ответа ---&#xa;    VERIFICATION_API_KEY: &quot;&quot;, // Используйте тот же ключ, если API один&#xa;    VERIFICATION_API_ENDPOINT: &quot;https://aigateway.delta.sbrf.ru/api/v1/run/d38cde4a-0ddc-4b34-afb6-5b15202474e6?stream=false&quot;, // &lt;-- ЗАМЕНИТЕ, ЕСЛИ АДРЕС ДРУГОЙ&#xa;&#xa;&#xa;    // --- НОВЫЙ Шаблон промпта для УТОЧНЕНИЯ кода ---&#xa;    PROMPT_TEMPLATE: `&#xa;Проанализируй следующий запрос от пользователя и список возможных вариантов решения.&#xa;Выбери НАИБОЛЕЕ ПОДХОДЯЩИЙ вариант из списка и верни ТОЛЬКО его код (например, PS+.FOK.DOC.05) без каких-либо дополнительных слов или объяснений.&#xa;&#xa;&#xa;ЗАПРОС ПОЛЬЗОВАТЕЛЯ:&#xa;&quot;{{QUESTION}}&quot;&#xa;&#xa;&#xa;СПИСОК ВОЗМОЖНЫХ РЕШЕНИЙ С КОДАМИ:&#xa;{{SOLUTIONS_LIST}}&#xa;&#xa;&#xa;Твоя задача - выбрать самый релевантный код из предоставленного списка на основе запроса пользователя.&#xa;`&#xa;};" link="// config.js&#xa;&#xa;&#xa;const CONFIG = {&#xa;    // --- Основной API для поиска кода ---&#xa;    SEARCH_API_KEY: &quot;&quot;, &#xa;    SEARCH_API_ENDPOINT: &quot;https://aigateway.delta.sbrf.ru/api/v1/run/d38cde4a-0ddc-4b34-afb6-5b15202474e6?stream=false&quot;,&#xa;&#xa;&#xa;    // --- Дополнительный API для УТОЧНЕНИЯ ответа ---&#xa;    VERIFICATION_API_KEY: &quot;&quot;, // Используйте тот же ключ, если API один&#xa;    VERIFICATION_API_ENDPOINT: &quot;https://aigateway.delta.sbrf.ru/api/v1/run/d38cde4a-0ddc-4b34-afb6-5b15202474e6?stream=false&quot;, // &lt;-- ЗАМЕНИТЕ, ЕСЛИ АДРЕС ДРУГОЙ&#xa;&#xa;&#xa;    // --- НОВЫЙ Шаблон промпта для УТОЧНЕНИЯ кода ---&#xa;    PROMPT_TEMPLATE: `&#xa;Проанализируй следующий запрос от пользователя и список возможных вариантов решения.&#xa;Выбери НАИБОЛЕЕ ПОДХОДЯЩИЙ вариант из списка и верни ТОЛЬКО его код (например, PS+.FOK.DOC.05) без каких-либо дополнительных слов или объяснений.&#xa;&#xa;&#xa;ЗАПРОС ПОЛЬЗОВАТЕЛЯ:&#xa;&quot;{{QUESTION}}&quot;&#xa;&#xa;&#xa;СПИСОК ВОЗМОЖНЫХ РЕШЕНИЙ С КОДАМИ:&#xa;{{SOLUTIONS_LIST}}&#xa;&#xa;&#xa;Твоя задача - выбрать самый релевантный код из предоставленного списка на основе запроса пользователя.&#xa;`&#xa;};" id="KhpofreyqJjnModskH-O-12">
          <mxCell style="text;whiteSpace=wrap;" vertex="1" parent="1">
            <mxGeometry x="170" y="890" width="560" height="540" as="geometry" />
          </mxCell>
        </UserObject>
        <UserObject label="// app.js&#xa;&#xa;&#xa;document.addEventListener(&#39;DOMContentLoaded&#39;, () =&gt; {&#xa;    // ... (секция с элементами интерфейса осталась без изменений) ...&#xa;    const inputData = document.getElementById(&#39;inputData&#39;);&#xa;    const runTest = document.getElementById(&#39;runTest&#39;);&#xa;    const clearResults = document.getElementById(&#39;clearResults&#39;);&#xa;    const resultsBody = document.getElementById(&#39;resultsBody&#39;);&#xa;    const progressBar = document.getElementById(&#39;progressBar&#39;);&#xa;    const progressContainer = document.getElementById(&#39;progressContainer&#39;);&#xa;    const summaryElement = document.getElementById(&#39;summary&#39;);&#xa;    const errorMessage = document.getElementById(&#39;errorMessage&#39;);&#xa;    const apiKeyInput = document.getElementById(&#39;apiKey&#39;);&#xa;    const apiEndpointInput = document.getElementById(&#39;apiEndpoint&#39;);&#xa;&#xa;&#xa;    apiEndpointInput.value = CONFIG.SEARCH_API_ENDPOINT;&#xa;    apiKeyInput.placeholder = CONFIG.SEARCH_API_KEY ? &quot;Ключ задан в config.js&quot; : &quot;Введите ваш API ключ&quot;;&#xa;&#xa;&#xa;    let correctCount = 0;&#xa;    let incorrectCount = 0;&#xa;    let errorCount = 0;&#xa;&#xa;&#xa;    function cleanCode(code) {&#xa;        if (!code) return &#39;&#39;;&#xa;        // Улучшенная очистка: убирает кавычки, скобки и лишние пробелы&#xa;        return code.replace(/^\[|\]$|^&quot;|&quot;$/g, &#39;&#39;).trim();&#xa;    }&#xa;&#xa;&#xa;    function extractCodeFromResponse(data) {&#xa;        try {&#xa;            const possiblePaths = [&#xa;                data?.outputs?.[0]?.outputs?.[0]?.artifacts?.message,&#xa;                data?.outputs?.[0]?.outputs?.[0]?.results?.message?.text,&#xa;                data?.outputs?.[0]?.outputs?.[0]?.messages?.[0]?.message&#xa;            ];&#xa;            const foundCode = possiblePaths.find(path =&gt; path);&#xa;            if (foundCode) return cleanCode(foundCode);&#xa;            throw new Error(&quot;Код не найден в ответе API&quot;);&#xa;        } catch (error) {&#xa;            console.error(&quot;Ошибка извлечения кода:&quot;, error);&#xa;            throw new Error(&quot;Не удалось извлечь код из структуры ответа&quot;);&#xa;        }&#xa;    }&#xa;    &#xa;    // ... (callSearchApi осталась без изменений) ...&#xa;    async function callSearchApi(question) {&#xa;        const apiKey = apiKeyInput.value.trim() || CONFIG.SEARCH_API_KEY;&#xa;        const endpoint = apiEndpointInput.value.trim() || CONFIG.SEARCH_API_ENDPOINT;&#xa;        if (!apiKey) throw new Error(&quot;API ключ для поиска не указан&quot;);&#xa;        const startTime = performance.now();&#xa;        try {&#xa;            const response = await fetch(endpoint, {&#xa;                method: &#39;POST&#39;,&#xa;                headers: { &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;x-api-key&#39;: apiKey },&#xa;                body: JSON.stringify({&#xa;                    &quot;input_value&quot;: question,&#xa;                    &quot;output_type&quot;: &quot;chat&quot;, &quot;input_type&quot;: &quot;chat&quot;,&#xa;                    &quot;tweaks&quot;: {}&#xa;                })&#xa;            });&#xa;            const responseTime = Math.round(performance.now() - startTime);&#xa;            if (!response.ok) throw new Error(`Ошибка API поиска: ${response.status} - ${await response.text()}`);&#xa;            const data = await response.json();&#xa;            return { code: extractCodeFromResponse(data), time: responseTime, rawResponse: data };&#xa;        } catch (error) {&#xa;            return { error: error.message, time: Math.round(performance.now() - startTime) };&#xa;        }&#xa;    }&#xa;&#xa;&#xa;    // НОВАЯ ФУНКЦИЯ для поиска релевантных решений в справочнике&#xa;    function findRelatedSolutions(baseCode) {&#xa;        if (!baseCode || typeof baseCode !== &#39;string&#39;) return [];&#xa;        &#xa;        const base = baseCode.substring(0, baseCode.lastIndexOf(&#39;.&#39;));&#xa;        if (!base) return []; // Если нет точки, не ищем&#xa;&#xa;&#xa;        const related = [];&#xa;        for (const key in SOLUTIONS) {&#xa;            if (key.startsWith(base)) {&#xa;                related.push({ code: key, text: SOLUTIONS[key] });&#xa;            }&#xa;        }&#xa;        return related;&#xa;    }&#xa;    &#xa;    // ЗНАЧИТЕЛЬНО ОБНОВЛЕННАЯ ФУНКЦИЯ. Теперь она не &quot;проверяет&quot;, а &quot;уточняет&quot; ответ.&#xa;    async function callRefinementApi(question, initialCode) {&#xa;        const relatedSolutions = findRelatedSolutions(initialCode);&#xa;        if (relatedSolutions.length === 0) {&#xa;            return { refinedCode: initialCode, detail: &quot;Контекст для уточнения не найден.&quot; };&#xa;        }&#xa;&#xa;&#xa;        // Формируем красивый список для промпта&#xa;        const solutionsListString = relatedSolutions&#xa;            .map(s =&gt; `Код: ${s.code}\nОписание: ${s.text}`)&#xa;            .join(&#39;\n\n&#39;);&#xa;&#xa;&#xa;        // Подставляем данные в новый шаблон промпта&#xa;        const finalPrompt = CONFIG.PROMPT_TEMPLATE&#xa;            .replace(&#39;{{QUESTION}}&#39;, question)&#xa;            .replace(&#39;{{SOLUTIONS_LIST}}&#39;, solutionsListString);&#xa;        &#xa;        const apiKey = CONFIG.VERIFICATION_API_KEY || CONFIG.SEARCH_API_KEY;&#xa;        const endpoint = CONFIG.VERIFICATION_API_ENDPOINT;&#xa;        if (!apiKey || !endpoint) return { error: &quot;API для уточнения не настроен&quot; };&#xa;&#xa;&#xa;        try {&#xa;            const response = await fetch(endpoint, {&#xa;                method: &#39;POST&#39;,&#xa;                headers: { &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;x-api-key&#39;: apiKey },&#xa;                body: JSON.stringify({ &quot;input_value&quot;: finalPrompt, /* ...другие параметры, если нужны */ })&#xa;            });&#xa;&#xa;&#xa;            if (!response.ok) return { error: `Ошибка API уточнения: ${response.status}`, detail: await response.text() };&#xa;            &#xa;            const data = await response.json();&#xa;            // Получаем уточненный код из ответа LLM&#xa;            const refinedCode = extractCodeFromResponse(data);&#xa;            return { refinedCode: refinedCode, detail: `LLM выбрала из ${relatedSolutions.length} вар.` };&#xa;        } catch (error) {&#xa;            return { error: &quot;Ошибка сети при уточнении&quot;, detail: error.message };&#xa;        }&#xa;    }&#xa;&#xa;&#xa;    runTest.addEventListener(&#39;click&#39;, async () =&gt; {&#xa;        const data = inputData.value.trim();&#xa;        if (!data) return showError(&quot;Введите данные для тестирования&quot;);&#xa;        &#xa;        resetState();&#xa;        const testCases = parseInputData(data);&#xa;        if (!testCases || testCases.length === 0) return;&#xa;&#xa;&#xa;        progressContainer.classList.remove(&#39;hidden&#39;);&#xa;&#xa;&#xa;        for (let i = 0; i &lt; testCases.length; i++) {&#xa;            progressBar.style.width = `${((i + 1) / testCases.length) * 100}%`;&#xa;            const testCase = testCases[i];&#xa;            const row = createInitialRow(testCase);&#xa;&#xa;&#xa;            // --- Этап 1: Поиск начального кода ---&#xa;            const searchResult = await callSearchApi(testCase.question);&#xa;            let finalCode = searchResult.code; // По умолчанию финальный код = начальному&#xa;            updateRowAfterSearch(row, searchResult);&#xa;&#xa;&#xa;            // --- Этап 2: Уточнение кода через второй LLM вызов ---&#xa;            if (searchResult.code) {&#xa;                const refinementResult = await callRefinementApi(testCase.question, searchResult.code);&#xa;                updateRowAfterRefinement(row, refinementResult);&#xa;                if (refinementResult.refinedCode) {&#xa;                    finalCode = refinementResult.refinedCode; // Обновляем финальный код&#xa;                }&#xa;            }&#xa;&#xa;&#xa;            // --- Этап 3: Финальная проверка и обновление счетчиков ---&#xa;            finalizeRow(row, testCase, finalCode, searchResult.rawResponse);&#xa;            row.scrollIntoView({ behavior: &#39;smooth&#39;, block: &#39;nearest&#39; });&#xa;        }&#xa;        &#xa;        setTimeout(() =&gt; progressContainer.classList.add(&#39;hidden&#39;), 500);&#xa;        showSummary();&#xa;    });&#xa;&#xa;&#xa;    function createInitialRow(testCase) {&#xa;        const row = document.createElement(&#39;tr&#39;);&#xa;        row.innerHTML = `&#xa;            &lt;td&gt;${testCase.question}&lt;/td&gt;&#xa;            &lt;td&gt;${testCase.expected}&lt;/td&gt;&#xa;            &lt;td class=&quot;received-code&quot;&gt;...&lt;/td&gt;&#xa;            &lt;td class=&quot;status-cell&quot;&gt;...&lt;/td&gt;&#xa;            &lt;td class=&quot;verification-cell&quot;&gt;&lt;span class=&quot;status processing&quot;&gt;Обработка&lt;/span&gt;&lt;/td&gt;&#xa;            &lt;td class=&quot;time-cell&quot;&gt;...&lt;/td&gt;&#xa;        `;&#xa;        resultsBody.appendChild(row);&#xa;        return row;&#xa;    }&#xa;&#xa;&#xa;    function updateRowAfterSearch(row, result) {&#xa;        row.querySelector(&#39;.time-cell&#39;).textContent = `${result.time}мс`;&#xa;        if (result.error) {&#xa;            row.querySelector(&#39;.received-code&#39;).innerHTML = `&lt;span class=&quot;error&quot;&gt;${result.error}&lt;/span&gt;`;&#xa;            errorCount++;&#xa;        } else {&#xa;            row.querySelector(&#39;.received-code&#39;).textContent = result.code || &quot;&lt;пустой&gt;&quot;;&#xa;        }&#xa;    }&#xa;    &#xa;    function updateRowAfterRefinement(row, result) {&#xa;        const cell = row.querySelector(&#39;.verification-cell&#39;);&#xa;        if (result.error) {&#xa;            cell.innerHTML = `&lt;span class=&quot;status error-status&quot; title=&quot;${result.detail}&quot;&gt;Ошибка&lt;/span&gt;`;&#xa;        } else {&#xa;            cell.textContent = result.refinedCode;&#xa;            cell.title = result.detail;&#xa;        }&#xa;    }&#xa;&#xa;&#xa;    function finalizeRow(row, testCase, finalCode, rawResponse) {&#xa;        const isMatch = finalCode === testCase.expected;&#xa;        const statusCell = row.querySelector(&#39;.status-cell&#39;);&#xa;        &#xa;        if (row.querySelector(&#39;.error&#39;)) {&#xa;             statusCell.innerHTML = `&lt;span class=&quot;status error-status&quot;&gt;Ошибка&lt;/span&gt;`;&#xa;             return;&#xa;        }&#xa;        &#xa;        if (isMatch) {&#xa;            correctCount++;&#xa;            statusCell.innerHTML = `&lt;span class=&quot;status correct&quot;&gt;Совпадает&lt;/span&gt;`;&#xa;        } else {&#xa;            incorrectCount++;&#xa;            statusCell.innerHTML = `&lt;span class=&quot;status incorrect&quot;&gt;Не совпадает&lt;/span&gt;`;&#xa;            addRawResponseDetail(row, rawResponse);&#xa;        }&#xa;    }&#xa;    &#xa;    // ... (остальные функции: addRawResponseDetail, parseInputData, resetState, showError, showSummary - без изменений) ...&#xa;    function addRawResponseDetail(row, rawResponse) {&#xa;        const detailRow = document.createElement(&#39;tr&#39;);&#xa;        detailRow.className = &#39;response-detail&#39;;&#xa;        detailRow.innerHTML = `&lt;td colspan=&quot;6&quot;&gt;&lt;div class=&quot;json-view&quot;&gt;${JSON.stringify(rawResponse, null, 2)}&lt;/div&gt;&lt;/td&gt;`;&#xa;        row.insertAdjacentElement(&#39;afterend&#39;, detailRow);&#xa;    }&#xa;    function parseInputData(data) {&#xa;        const lines = data.split(&#39;\n&#39;).filter(line =&gt; line.trim() !== &#39;&#39;);&#xa;        return lines.map(line =&gt; {&#xa;            const parts = line.split(&#39;\t&#39;);&#xa;            if (parts.length &lt; 2) {&#xa;                showError(`Ошибка формата в строке: &quot;${line}&quot;. Используйте табуляцию.`);&#xa;                return null;&#xa;            }&#xa;            return { question: parts[0].trim(), expected: cleanCode(parts[1].trim()) };&#xa;        }).filter(Boolean);&#xa;    }&#xa;    function resetState() {&#xa;        correctCount = incorrectCount = errorCount = 0;&#xa;        resultsBody.innerHTML = &#39;&#39;;&#xa;        summaryElement.classList.add(&#39;hidden&#39;);&#xa;        errorMessage.classList.add(&#39;hidden&#39;);&#xa;    }&#xa;    clearResults.addEventListener(&#39;click&#39;, () =&gt; {&#xa;        resetState();&#xa;        inputData.value = &#39;&#39;;&#xa;    });&#xa;    function showError(message) {&#xa;        errorMessage.textContent = message;&#xa;        errorMessage.classList.remove(&#39;hidden&#39;);&#xa;        setTimeout(() =&gt; errorMessage.classList.add(&#39;hidden&#39;), 5000);&#xa;    }&#xa;    function showSummary() {&#xa;        const total = correctCount + incorrectCount + errorCount;&#xa;        const accuracy = (correctCount + incorrectCount) &gt; 0 ? Math.round((correctCount / (correctCount + incorrectCount)) * 100) : 0;&#xa;        summaryElement.innerHTML = `&#xa;            Итоги тестирования: &#xa;            &lt;span style=&quot;color: #28a745&quot;&gt;${correctCount} ✓&lt;/span&gt; | &#xa;            &lt;span style=&quot;color: #dc3545&quot;&gt;${incorrectCount} ✗&lt;/span&gt; | &#xa;            &lt;span style=&quot;color: #ffc107&quot;&gt;${errorCount} ⚠&lt;/span&gt;&#xa;            | Точность (без ошибок API): &lt;strong&gt;${accuracy}%&lt;/strong&gt;&#xa;        `;&#xa;        summaryElement.classList.remove(&#39;hidden&#39;);&#xa;    }&#xa;});" link="// app.js&#xa;&#xa;&#xa;document.addEventListener(&#39;DOMContentLoaded&#39;, () =&gt; {&#xa;    // ... (секция с элементами интерфейса осталась без изменений) ...&#xa;    const inputData = document.getElementById(&#39;inputData&#39;);&#xa;    const runTest = document.getElementById(&#39;runTest&#39;);&#xa;    const clearResults = document.getElementById(&#39;clearResults&#39;);&#xa;    const resultsBody = document.getElementById(&#39;resultsBody&#39;);&#xa;    const progressBar = document.getElementById(&#39;progressBar&#39;);&#xa;    const progressContainer = document.getElementById(&#39;progressContainer&#39;);&#xa;    const summaryElement = document.getElementById(&#39;summary&#39;);&#xa;    const errorMessage = document.getElementById(&#39;errorMessage&#39;);&#xa;    const apiKeyInput = document.getElementById(&#39;apiKey&#39;);&#xa;    const apiEndpointInput = document.getElementById(&#39;apiEndpoint&#39;);&#xa;&#xa;&#xa;    apiEndpointInput.value = CONFIG.SEARCH_API_ENDPOINT;&#xa;    apiKeyInput.placeholder = CONFIG.SEARCH_API_KEY ? &quot;Ключ задан в config.js&quot; : &quot;Введите ваш API ключ&quot;;&#xa;&#xa;&#xa;    let correctCount = 0;&#xa;    let incorrectCount = 0;&#xa;    let errorCount = 0;&#xa;&#xa;&#xa;    function cleanCode(code) {&#xa;        if (!code) return &#39;&#39;;&#xa;        // Улучшенная очистка: убирает кавычки, скобки и лишние пробелы&#xa;        return code.replace(/^\[|\]$|^&quot;|&quot;$/g, &#39;&#39;).trim();&#xa;    }&#xa;&#xa;&#xa;    function extractCodeFromResponse(data) {&#xa;        try {&#xa;            const possiblePaths = [&#xa;                data?.outputs?.[0]?.outputs?.[0]?.artifacts?.message,&#xa;                data?.outputs?.[0]?.outputs?.[0]?.results?.message?.text,&#xa;                data?.outputs?.[0]?.outputs?.[0]?.messages?.[0]?.message&#xa;            ];&#xa;            const foundCode = possiblePaths.find(path =&gt; path);&#xa;            if (foundCode) return cleanCode(foundCode);&#xa;            throw new Error(&quot;Код не найден в ответе API&quot;);&#xa;        } catch (error) {&#xa;            console.error(&quot;Ошибка извлечения кода:&quot;, error);&#xa;            throw new Error(&quot;Не удалось извлечь код из структуры ответа&quot;);&#xa;        }&#xa;    }&#xa;    &#xa;    // ... (callSearchApi осталась без изменений) ...&#xa;    async function callSearchApi(question) {&#xa;        const apiKey = apiKeyInput.value.trim() || CONFIG.SEARCH_API_KEY;&#xa;        const endpoint = apiEndpointInput.value.trim() || CONFIG.SEARCH_API_ENDPOINT;&#xa;        if (!apiKey) throw new Error(&quot;API ключ для поиска не указан&quot;);&#xa;        const startTime = performance.now();&#xa;        try {&#xa;            const response = await fetch(endpoint, {&#xa;                method: &#39;POST&#39;,&#xa;                headers: { &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;x-api-key&#39;: apiKey },&#xa;                body: JSON.stringify({&#xa;                    &quot;input_value&quot;: question,&#xa;                    &quot;output_type&quot;: &quot;chat&quot;, &quot;input_type&quot;: &quot;chat&quot;,&#xa;                    &quot;tweaks&quot;: {}&#xa;                })&#xa;            });&#xa;            const responseTime = Math.round(performance.now() - startTime);&#xa;            if (!response.ok) throw new Error(`Ошибка API поиска: ${response.status} - ${await response.text()}`);&#xa;            const data = await response.json();&#xa;            return { code: extractCodeFromResponse(data), time: responseTime, rawResponse: data };&#xa;        } catch (error) {&#xa;            return { error: error.message, time: Math.round(performance.now() - startTime) };&#xa;        }&#xa;    }&#xa;&#xa;&#xa;    // НОВАЯ ФУНКЦИЯ для поиска релевантных решений в справочнике&#xa;    function findRelatedSolutions(baseCode) {&#xa;        if (!baseCode || typeof baseCode !== &#39;string&#39;) return [];&#xa;        &#xa;        const base = baseCode.substring(0, baseCode.lastIndexOf(&#39;.&#39;));&#xa;        if (!base) return []; // Если нет точки, не ищем&#xa;&#xa;&#xa;        const related = [];&#xa;        for (const key in SOLUTIONS) {&#xa;            if (key.startsWith(base)) {&#xa;                related.push({ code: key, text: SOLUTIONS[key] });&#xa;            }&#xa;        }&#xa;        return related;&#xa;    }&#xa;    &#xa;    // ЗНАЧИТЕЛЬНО ОБНОВЛЕННАЯ ФУНКЦИЯ. Теперь она не &quot;проверяет&quot;, а &quot;уточняет&quot; ответ.&#xa;    async function callRefinementApi(question, initialCode) {&#xa;        const relatedSolutions = findRelatedSolutions(initialCode);&#xa;        if (relatedSolutions.length === 0) {&#xa;            return { refinedCode: initialCode, detail: &quot;Контекст для уточнения не найден.&quot; };&#xa;        }&#xa;&#xa;&#xa;        // Формируем красивый список для промпта&#xa;        const solutionsListString = relatedSolutions&#xa;            .map(s =&gt; `Код: ${s.code}\nОписание: ${s.text}`)&#xa;            .join(&#39;\n\n&#39;);&#xa;&#xa;&#xa;        // Подставляем данные в новый шаблон промпта&#xa;        const finalPrompt = CONFIG.PROMPT_TEMPLATE&#xa;            .replace(&#39;{{QUESTION}}&#39;, question)&#xa;            .replace(&#39;{{SOLUTIONS_LIST}}&#39;, solutionsListString);&#xa;        &#xa;        const apiKey = CONFIG.VERIFICATION_API_KEY || CONFIG.SEARCH_API_KEY;&#xa;        const endpoint = CONFIG.VERIFICATION_API_ENDPOINT;&#xa;        if (!apiKey || !endpoint) return { error: &quot;API для уточнения не настроен&quot; };&#xa;&#xa;&#xa;        try {&#xa;            const response = await fetch(endpoint, {&#xa;                method: &#39;POST&#39;,&#xa;                headers: { &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;x-api-key&#39;: apiKey },&#xa;                body: JSON.stringify({ &quot;input_value&quot;: finalPrompt, /* ...другие параметры, если нужны */ })&#xa;            });&#xa;&#xa;&#xa;            if (!response.ok) return { error: `Ошибка API уточнения: ${response.status}`, detail: await response.text() };&#xa;            &#xa;            const data = await response.json();&#xa;            // Получаем уточненный код из ответа LLM&#xa;            const refinedCode = extractCodeFromResponse(data);&#xa;            return { refinedCode: refinedCode, detail: `LLM выбрала из ${relatedSolutions.length} вар.` };&#xa;        } catch (error) {&#xa;            return { error: &quot;Ошибка сети при уточнении&quot;, detail: error.message };&#xa;        }&#xa;    }&#xa;&#xa;&#xa;    runTest.addEventListener(&#39;click&#39;, async () =&gt; {&#xa;        const data = inputData.value.trim();&#xa;        if (!data) return showError(&quot;Введите данные для тестирования&quot;);&#xa;        &#xa;        resetState();&#xa;        const testCases = parseInputData(data);&#xa;        if (!testCases || testCases.length === 0) return;&#xa;&#xa;&#xa;        progressContainer.classList.remove(&#39;hidden&#39;);&#xa;&#xa;&#xa;        for (let i = 0; i &lt; testCases.length; i++) {&#xa;            progressBar.style.width = `${((i + 1) / testCases.length) * 100}%`;&#xa;            const testCase = testCases[i];&#xa;            const row = createInitialRow(testCase);&#xa;&#xa;&#xa;            // --- Этап 1: Поиск начального кода ---&#xa;            const searchResult = await callSearchApi(testCase.question);&#xa;            let finalCode = searchResult.code; // По умолчанию финальный код = начальному&#xa;            updateRowAfterSearch(row, searchResult);&#xa;&#xa;&#xa;            // --- Этап 2: Уточнение кода через второй LLM вызов ---&#xa;            if (searchResult.code) {&#xa;                const refinementResult = await callRefinementApi(testCase.question, searchResult.code);&#xa;                updateRowAfterRefinement(row, refinementResult);&#xa;                if (refinementResult.refinedCode) {&#xa;                    finalCode = refinementResult.refinedCode; // Обновляем финальный код&#xa;                }&#xa;            }&#xa;&#xa;&#xa;            // --- Этап 3: Финальная проверка и обновление счетчиков ---&#xa;            finalizeRow(row, testCase, finalCode, searchResult.rawResponse);&#xa;            row.scrollIntoView({ behavior: &#39;smooth&#39;, block: &#39;nearest&#39; });&#xa;        }&#xa;        &#xa;        setTimeout(() =&gt; progressContainer.classList.add(&#39;hidden&#39;), 500);&#xa;        showSummary();&#xa;    });&#xa;&#xa;&#xa;    function createInitialRow(testCase) {&#xa;        const row = document.createElement(&#39;tr&#39;);&#xa;        row.innerHTML = `&#xa;            &lt;td&gt;${testCase.question}&lt;/td&gt;&#xa;            &lt;td&gt;${testCase.expected}&lt;/td&gt;&#xa;            &lt;td class=&quot;received-code&quot;&gt;...&lt;/td&gt;&#xa;            &lt;td class=&quot;status-cell&quot;&gt;...&lt;/td&gt;&#xa;            &lt;td class=&quot;verification-cell&quot;&gt;&lt;span class=&quot;status processing&quot;&gt;Обработка&lt;/span&gt;&lt;/td&gt;&#xa;            &lt;td class=&quot;time-cell&quot;&gt;...&lt;/td&gt;&#xa;        `;&#xa;        resultsBody.appendChild(row);&#xa;        return row;&#xa;    }&#xa;&#xa;&#xa;    function updateRowAfterSearch(row, result) {&#xa;        row.querySelector(&#39;.time-cell&#39;).textContent = `${result.time}мс`;&#xa;        if (result.error) {&#xa;            row.querySelector(&#39;.received-code&#39;).innerHTML = `&lt;span class=&quot;error&quot;&gt;${result.error}&lt;/span&gt;`;&#xa;            errorCount++;&#xa;        } else {&#xa;            row.querySelector(&#39;.received-code&#39;).textContent = result.code || &quot;&lt;пустой&gt;&quot;;&#xa;        }&#xa;    }&#xa;    &#xa;    function updateRowAfterRefinement(row, result) {&#xa;        const cell = row.querySelector(&#39;.verification-cell&#39;);&#xa;        if (result.error) {&#xa;            cell.innerHTML = `&lt;span class=&quot;status error-status&quot; title=&quot;${result.detail}&quot;&gt;Ошибка&lt;/span&gt;`;&#xa;        } else {&#xa;            cell.textContent = result.refinedCode;&#xa;            cell.title = result.detail;&#xa;        }&#xa;    }&#xa;&#xa;&#xa;    function finalizeRow(row, testCase, finalCode, rawResponse) {&#xa;        const isMatch = finalCode === testCase.expected;&#xa;        const statusCell = row.querySelector(&#39;.status-cell&#39;);&#xa;        &#xa;        if (row.querySelector(&#39;.error&#39;)) {&#xa;             statusCell.innerHTML = `&lt;span class=&quot;status error-status&quot;&gt;Ошибка&lt;/span&gt;`;&#xa;             return;&#xa;        }&#xa;        &#xa;        if (isMatch) {&#xa;            correctCount++;&#xa;            statusCell.innerHTML = `&lt;span class=&quot;status correct&quot;&gt;Совпадает&lt;/span&gt;`;&#xa;        } else {&#xa;            incorrectCount++;&#xa;            statusCell.innerHTML = `&lt;span class=&quot;status incorrect&quot;&gt;Не совпадает&lt;/span&gt;`;&#xa;            addRawResponseDetail(row, rawResponse);&#xa;        }&#xa;    }&#xa;    &#xa;    // ... (остальные функции: addRawResponseDetail, parseInputData, resetState, showError, showSummary - без изменений) ...&#xa;    function addRawResponseDetail(row, rawResponse) {&#xa;        const detailRow = document.createElement(&#39;tr&#39;);&#xa;        detailRow.className = &#39;response-detail&#39;;&#xa;        detailRow.innerHTML = `&lt;td colspan=&quot;6&quot;&gt;&lt;div class=&quot;json-view&quot;&gt;${JSON.stringify(rawResponse, null, 2)}&lt;/div&gt;&lt;/td&gt;`;&#xa;        row.insertAdjacentElement(&#39;afterend&#39;, detailRow);&#xa;    }&#xa;    function parseInputData(data) {&#xa;        const lines = data.split(&#39;\n&#39;).filter(line =&gt; line.trim() !== &#39;&#39;);&#xa;        return lines.map(line =&gt; {&#xa;            const parts = line.split(&#39;\t&#39;);&#xa;            if (parts.length &lt; 2) {&#xa;                showError(`Ошибка формата в строке: &quot;${line}&quot;. Используйте табуляцию.`);&#xa;                return null;&#xa;            }&#xa;            return { question: parts[0].trim(), expected: cleanCode(parts[1].trim()) };&#xa;        }).filter(Boolean);&#xa;    }&#xa;    function resetState() {&#xa;        correctCount = incorrectCount = errorCount = 0;&#xa;        resultsBody.innerHTML = &#39;&#39;;&#xa;        summaryElement.classList.add(&#39;hidden&#39;);&#xa;        errorMessage.classList.add(&#39;hidden&#39;);&#xa;    }&#xa;    clearResults.addEventListener(&#39;click&#39;, () =&gt; {&#xa;        resetState();&#xa;        inputData.value = &#39;&#39;;&#xa;    });&#xa;    function showError(message) {&#xa;        errorMessage.textContent = message;&#xa;        errorMessage.classList.remove(&#39;hidden&#39;);&#xa;        setTimeout(() =&gt; errorMessage.classList.add(&#39;hidden&#39;), 5000);&#xa;    }&#xa;    function showSummary() {&#xa;        const total = correctCount + incorrectCount + errorCount;&#xa;        const accuracy = (correctCount + incorrectCount) &gt; 0 ? Math.round((correctCount / (correctCount + incorrectCount)) * 100) : 0;&#xa;        summaryElement.innerHTML = `&#xa;            Итоги тестирования: &#xa;            &lt;span style=&quot;color: #28a745&quot;&gt;${correctCount} ✓&lt;/span&gt; | &#xa;            &lt;span style=&quot;color: #dc3545&quot;&gt;${incorrectCount} ✗&lt;/span&gt; | &#xa;            &lt;span style=&quot;color: #ffc107&quot;&gt;${errorCount} ⚠&lt;/span&gt;&#xa;            | Точность (без ошибок API): &lt;strong&gt;${accuracy}%&lt;/strong&gt;&#xa;        `;&#xa;        summaryElement.classList.remove(&#39;hidden&#39;);&#xa;    }&#xa;});" id="KhpofreyqJjnModskH-O-13">
          <mxCell style="text;whiteSpace=wrap;" vertex="1" parent="1">
            <mxGeometry x="230" y="1550" width="560" height="4260" as="geometry" />
          </mxCell>
        </UserObject>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
