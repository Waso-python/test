<mxfile host="app.diagrams.net" agent="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36 SberBrowser/28.0.0.0" version="27.2.0">
  <diagram name="Страница — 1" id="WULPb32uHRo-QUS4CWuH">
    <mxGraphModel dx="1372" dy="743" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="3300" pageHeight="4681" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <UserObject label="LOGGING_CONFIG = {&#xa;    &quot;version&quot;: 1,&#xa;    &quot;disable_existing_loggers&quot;: False,&#xa;    &quot;formatters&quot;: {&#xa;        &quot;default&quot;: {&#xa;            &quot;()&quot;: &quot;uvicorn.logging.DefaultFormatter&quot;,&#xa;            &quot;fmt&quot;: &quot;%(levelname)-7s | %(asctime)s.%(msecs)03d | %(message)s&quot;,&#xa;            &quot;datefmt&quot;: &quot;%Y-%m-%d %H:%M:%S&quot;,&#xa;        }&#xa;    },&#xa;    &quot;handlers&quot;: {&#xa;        &quot;default&quot;: {&#xa;            &quot;formatter&quot;: &quot;default&quot;,&#xa;            &quot;class&quot;: &quot;logging.StreamHandler&quot;,&#xa;            &quot;stream&quot;: &quot;ext://sys.stderr&quot;,&#xa;        }&#xa;    },&#xa;    &quot;loggers&quot;: {&#xa;        &quot;uvicorn&quot;: {&#xa;            &quot;handlers&quot;: [&quot;default&quot;],&#xa;            &quot;level&quot;: &quot;INFO&quot;,&#xa;            &quot;propagate&quot;: False,&#xa;        },&#xa;        # httpx логгер отвечает за логирование langchain&#xa;        &quot;httpx&quot;: {&#xa;            &quot;handlers&quot;: [&quot;default&quot;],&#xa;            &quot;level&quot;: &quot;INFO&quot;,&#xa;            &quot;propagate&quot;: False,&#xa;        }&#xa;    },&#xa;}" link="LOGGING_CONFIG = {&#xa;    &quot;version&quot;: 1,&#xa;    &quot;disable_existing_loggers&quot;: False,&#xa;    &quot;formatters&quot;: {&#xa;        &quot;default&quot;: {&#xa;            &quot;()&quot;: &quot;uvicorn.logging.DefaultFormatter&quot;,&#xa;            &quot;fmt&quot;: &quot;%(levelname)-7s | %(asctime)s.%(msecs)03d | %(message)s&quot;,&#xa;            &quot;datefmt&quot;: &quot;%Y-%m-%d %H:%M:%S&quot;,&#xa;        }&#xa;    },&#xa;    &quot;handlers&quot;: {&#xa;        &quot;default&quot;: {&#xa;            &quot;formatter&quot;: &quot;default&quot;,&#xa;            &quot;class&quot;: &quot;logging.StreamHandler&quot;,&#xa;            &quot;stream&quot;: &quot;ext://sys.stderr&quot;,&#xa;        }&#xa;    },&#xa;    &quot;loggers&quot;: {&#xa;        &quot;uvicorn&quot;: {&#xa;            &quot;handlers&quot;: [&quot;default&quot;],&#xa;            &quot;level&quot;: &quot;INFO&quot;,&#xa;            &quot;propagate&quot;: False,&#xa;        },&#xa;        # httpx логгер отвечает за логирование langchain&#xa;        &quot;httpx&quot;: {&#xa;            &quot;handlers&quot;: [&quot;default&quot;],&#xa;            &quot;level&quot;: &quot;INFO&quot;,&#xa;            &quot;propagate&quot;: False,&#xa;        }&#xa;    },&#xa;}" id="SYt-TXJ_Hw24SwqiqHZK-21">
          <mxCell style="text;whiteSpace=wrap;" vertex="1" parent="1">
            <mxGeometry x="40" y="50" width="440" height="470" as="geometry" />
          </mxCell>
        </UserObject>
        <UserObject label="path_fields = {&#xa;    &quot;common&quot;: {&#xa;        &quot;request&quot;: [],&#xa;        &quot;response&quot;: [],&#xa;        &quot;common&quot;: [],&#xa;    },&#xa;    &quot;/api/v1/predict&quot;: {&#xa;        &quot;request&quot;: [],&#xa;        &quot;response&quot;: [],&#xa;        &quot;common&quot;: [],&#xa;    },&#xa;    &quot;gc.chat&quot;: {&#xa;        &quot;request&quot;: [],&#xa;        &quot;response&quot;: [],&#xa;        &quot;common&quot;: [],&#xa;    },&#xa;    &quot;gc.embeddings&quot;: {&#xa;        &quot;request&quot;: [],&#xa;        &quot;response&quot;: [],&#xa;        &quot;common&quot;: [],&#xa;    },&#xa;}&#xa;&#xa;&#xa;&#xa;&#xa;def mask_sensitive_data(data, path=&quot;common&quot;, message_type=&quot;common&quot;):&#xa;    path = path_fields.get(path, path_fields[&quot;common&quot;])&#xa;    mask_fields = path.get(message_type, [])&#xa;    return _masker(data, mask_fields)&#xa;&#xa;&#xa;&#xa;&#xa;def _masker(data, mask_fields):&#xa;    &quot;&quot;&quot;Маскирует поля с чувствительными данными в словаре&quot;&quot;&quot;&#xa;    if isinstance(data, dict):&#xa;        return {&#xa;            k: (&quot;***&quot; if not mask_fields or k.lower() in mask_fields else _masker(v, mask_fields))&#xa;            for k, v in data.items()&#xa;        }&#xa;    if isinstance(data, list):&#xa;        return [_masker(item, mask_fields) for item in data]&#xa;    return data" link="path_fields = {&#xa;    &quot;common&quot;: {&#xa;        &quot;request&quot;: [],&#xa;        &quot;response&quot;: [],&#xa;        &quot;common&quot;: [],&#xa;    },&#xa;    &quot;/api/v1/predict&quot;: {&#xa;        &quot;request&quot;: [],&#xa;        &quot;response&quot;: [],&#xa;        &quot;common&quot;: [],&#xa;    },&#xa;    &quot;gc.chat&quot;: {&#xa;        &quot;request&quot;: [],&#xa;        &quot;response&quot;: [],&#xa;        &quot;common&quot;: [],&#xa;    },&#xa;    &quot;gc.embeddings&quot;: {&#xa;        &quot;request&quot;: [],&#xa;        &quot;response&quot;: [],&#xa;        &quot;common&quot;: [],&#xa;    },&#xa;}&#xa;&#xa;&#xa;&#xa;&#xa;def mask_sensitive_data(data, path=&quot;common&quot;, message_type=&quot;common&quot;):&#xa;    path = path_fields.get(path, path_fields[&quot;common&quot;])&#xa;    mask_fields = path.get(message_type, [])&#xa;    return _masker(data, mask_fields)&#xa;&#xa;&#xa;&#xa;&#xa;def _masker(data, mask_fields):&#xa;    &quot;&quot;&quot;Маскирует поля с чувствительными данными в словаре&quot;&quot;&quot;&#xa;    if isinstance(data, dict):&#xa;        return {&#xa;            k: (&quot;***&quot; if not mask_fields or k.lower() in mask_fields else _masker(v, mask_fields))&#xa;            for k, v in data.items()&#xa;        }&#xa;    if isinstance(data, list):&#xa;        return [_masker(item, mask_fields) for item in data]&#xa;    return data" id="SYt-TXJ_Hw24SwqiqHZK-22">
          <mxCell style="text;whiteSpace=wrap;" vertex="1" parent="1">
            <mxGeometry x="520" y="50" width="510" height="660" as="geometry" />
          </mxCell>
        </UserObject>
        <UserObject label="import json&#xa;from dataclasses import asdict, dataclass&#xa;&#xa;&#xa;&#xa;&#xa;@dataclass&#xa;class ContextLog:&#xa;    # pylint: disable=C0103,R0902&#xa;    rqUId: None | str&#xa;    rqTime: None | str&#xa;    systemId: None | str&#xa;    gwSessionId: None | str&#xa;&#xa;&#xa;&#xa;&#xa;@dataclass&#xa;class Log:&#xa;    # pylint: disable=C0103,R0902&#xa;    levelName: str&#xa;    asctime: str&#xa;    moduleName: str&#xa;    funcName: str&#xa;    message: str&#xa;    stackTrace: str | None&#xa;    rqUId: None | str&#xa;    rqTime: None | str&#xa;    systemId: None | str&#xa;    gwSessionId: None | str&#xa;    args: str | None&#xa;&#xa;&#xa;&#xa;&#xa;@dataclass&#xa;class Metric:&#xa;    # pylint: disable=C0103,R0902&#xa;    rqUId: str&#xa;    metric_name: str&#xa;    metric_value: int&#xa;&#xa;&#xa;&#xa;&#xa;@dataclass&#xa;class EventParam:&#xa;    # pylint: disable=C0103,R0902&#xa;    name: str&#xa;    value: str&#xa;&#xa;&#xa;&#xa;&#xa;@dataclass&#xa;class Event:&#xa;    # pylint: disable=C0103,R0902&#xa;    name: str&#xa;    createdAt: int&#xa;    params: list[EventParam]&#xa;&#xa;&#xa;&#xa;&#xa;def dataclass_as_json_str(dataclass_object) -&gt; str:&#xa;    return json.dumps(asdict(dataclass_object), ensure_ascii=False)" link="import json&#xa;from dataclasses import asdict, dataclass&#xa;&#xa;&#xa;&#xa;&#xa;@dataclass&#xa;class ContextLog:&#xa;    # pylint: disable=C0103,R0902&#xa;    rqUId: None | str&#xa;    rqTime: None | str&#xa;    systemId: None | str&#xa;    gwSessionId: None | str&#xa;&#xa;&#xa;&#xa;&#xa;@dataclass&#xa;class Log:&#xa;    # pylint: disable=C0103,R0902&#xa;    levelName: str&#xa;    asctime: str&#xa;    moduleName: str&#xa;    funcName: str&#xa;    message: str&#xa;    stackTrace: str | None&#xa;    rqUId: None | str&#xa;    rqTime: None | str&#xa;    systemId: None | str&#xa;    gwSessionId: None | str&#xa;    args: str | None&#xa;&#xa;&#xa;&#xa;&#xa;@dataclass&#xa;class Metric:&#xa;    # pylint: disable=C0103,R0902&#xa;    rqUId: str&#xa;    metric_name: str&#xa;    metric_value: int&#xa;&#xa;&#xa;&#xa;&#xa;@dataclass&#xa;class EventParam:&#xa;    # pylint: disable=C0103,R0902&#xa;    name: str&#xa;    value: str&#xa;&#xa;&#xa;&#xa;&#xa;@dataclass&#xa;class Event:&#xa;    # pylint: disable=C0103,R0902&#xa;    name: str&#xa;    createdAt: int&#xa;    params: list[EventParam]&#xa;&#xa;&#xa;&#xa;&#xa;def dataclass_as_json_str(dataclass_object) -&gt; str:&#xa;    return json.dumps(asdict(dataclass_object), ensure_ascii=False)" id="SYt-TXJ_Hw24SwqiqHZK-23">
          <mxCell style="text;whiteSpace=wrap;" vertex="1" parent="1">
            <mxGeometry x="1110" y="60" width="390" height="970" as="geometry" />
          </mxCell>
        </UserObject>
        <UserObject label="import json&#xa;import sys&#xa;from dataclasses import asdict&#xa;from logging import DEBUG&#xa;from time import time&#xa;&#xa;&#xa;import pytz&#xa;from loguru import logger as loguru_logger&#xa;&#xa;&#xa;from aigw_service.base import Singleton&#xa;&#xa;&#xa;from .context_vars import ContextVarsContainer&#xa;from .models import ContextLog, Event, EventParam, Log, Metric, dataclass_as_json_str&#xa;from .utils import mask_sensitive_data&#xa;&#xa;&#xa;&#xa;&#xa;class LoggerWrapper:&#xa;    def __init__(self, audit_uid_pod, audit_ip_address):&#xa;        self.logger = None&#xa;        self.audit_uid_pod = audit_uid_pod&#xa;        self.audit_ip_address = audit_ip_address&#xa;&#xa;&#xa;    def patch(self, *args, **kwargs):&#xa;        self.logger = loguru_logger.patch(*args, **kwargs)&#xa;        return self&#xa;&#xa;&#xa;    def metric(self, metric_name, metric_value):&#xa;        self.logger.info(&#xa;            &quot;&lt;metric&gt;&quot;,&#xa;            metric_name=metric_name,&#xa;            metric_value=metric_value,&#xa;            target=&quot;metric&quot;,&#xa;        )&#xa;&#xa;&#xa;    def audit(self, event_name, event_params):&#xa;        self.logger.info(&#xa;            &quot;&lt;audit-event&gt;&quot;,&#xa;            audit_event_name=event_name,&#xa;            audit_uid_pod=self.audit_uid_pod,&#xa;            audit_ip_address=self.audit_ip_address,&#xa;            audit_params=event_params,&#xa;            target=&quot;audit-event&quot;,&#xa;        )&#xa;&#xa;&#xa;    def __getattr__(self, name):&#xa;        return getattr(self.logger, name)&#xa;&#xa;&#xa;&#xa;&#xa;class LoguruPatcher:&#xa;    def __init__(self, context_vars_container: ContextVarsContainer, timezone: pytz.timezone, full_message_print: bool):&#xa;        self.context_vars_container = context_vars_container&#xa;        self.timezone: pytz.timezone = timezone&#xa;        self.full_message_print: bool = full_message_print&#xa;&#xa;&#xa;    @staticmethod&#xa;    def format_stdout_record(record) -&gt; str:&#xa;        base_record = &quot;&lt;level&gt;{level: &lt;7}&lt;/level&gt; | &lt;green&gt;{time:YYYY-MM-DD HH:mm:ss.SSS}&lt;/green&gt; | &quot;&#xa;        base_msg = &quot;{name} | {message}\n&quot;&#xa;&#xa;&#xa;        if record[&quot;extra&quot;].get(&quot;rqUId&quot;) is not None:&#xa;            return base_record + &quot;{extra[rqUId]} | &quot; + base_msg&#xa;        return base_record + base_msg&#xa;&#xa;&#xa;    def patching(self, record: dict):&#xa;        _context_log: ContextLog = self.context_vars_container.context_vars&#xa;        _time_iso = record[&quot;time&quot;].replace(tzinfo=self.timezone).isoformat()&#xa;        _target = record[&quot;extra&quot;].get(&quot;target&quot;)&#xa;&#xa;&#xa;        if _target == &quot;metric&quot;:&#xa;            _log_record = Metric(&#xa;                rqUId=_context_log.rqUId,&#xa;                metric_name=record[&quot;extra&quot;].get(&quot;metric_name&quot;, &quot;unknown&quot;),&#xa;                metric_value=record[&quot;extra&quot;].get(&quot;metric_value&quot;, 1),&#xa;            )&#xa;        elif _target == &quot;audit-event&quot;:&#xa;            _log_record = Event(&#xa;                name=record[&quot;extra&quot;].get(&quot;audit_event_name&quot;, None),&#xa;                createdAt=int(time()*1000),&#xa;                params=[&#xa;                    EventParam(name=&quot;uid-pod&quot;, value=record[&quot;extra&quot;].get(&quot;audit_uid_pod&quot;)),&#xa;                    EventParam(name=&quot;ip-address&quot;, value=record[&quot;extra&quot;].get(&quot;audit_ip_address&quot;)),&#xa;                    EventParam(name=&quot;request-Id&quot;, value=_context_log.rqUId),&#xa;                    EventParam(name=&quot;request-Time&quot;, value=_context_log.rqTime),&#xa;                    EventParam(name=&quot;params&quot;, value=record[&quot;extra&quot;].get(&quot;audit_params&quot;)),&#xa;                ],&#xa;            )&#xa;        else:&#xa;            record[&quot;extra&quot;].update({&quot;target&quot;: &quot;log&quot;})&#xa;            args = record[&quot;extra&quot;].get(&quot;args&quot;, None)&#xa;            if args:&#xa;                message = args.get(&quot;message&quot;, {})&#xa;                if self.full_message_print:&#xa;                    print(json.dumps(message, indent=4, ensure_ascii=False))&#xa;                message = mask_sensitive_data(&#xa;                    message, message_type=record[&quot;extra&quot;].get(&quot;message_type&quot;), path=record[&quot;extra&quot;].get(&quot;path&quot;)&#xa;                )&#xa;                args.update({&quot;message&quot;: str(message), &quot;headers&quot;: str(args[&quot;headers&quot;])})&#xa;&#xa;&#xa;            _log_record = Log(&#xa;                levelName=str(record[&quot;level&quot;].name),&#xa;                asctime=_time_iso,&#xa;                moduleName=str(record[&quot;name&quot;]),&#xa;                funcName=str(record[&quot;function&quot;]),&#xa;                message=str(record[&quot;message&quot;]),&#xa;                stackTrace=record[&quot;extra&quot;].get(&quot;exception&quot;, None),&#xa;                rqUId=_context_log.rqUId,&#xa;                rqTime=_context_log.rqTime,&#xa;                systemId=_context_log.systemId,&#xa;                gwSessionId=_context_log.gwSessionId,&#xa;                args=args,&#xa;            )&#xa;&#xa;&#xa;        record[&quot;extra&quot;][&quot;serialized&quot;] = dataclass_as_json_str(_log_record)&#xa;        record[&quot;extra&quot;].update(asdict(_context_log))&#xa;&#xa;&#xa;&#xa;&#xa;class LoggerConfigurator(metaclass=Singleton):&#xa;    # pylint: disable=R0902&#xa;    @property&#xa;    def async_logger(self):&#xa;        return self.logger&#xa;&#xa;&#xa;    def __init__(&#xa;        # pylint: disable=R0917&#xa;        self,&#xa;        log_lvl: int,&#xa;        log_file_path: str,&#xa;        metric_file_path: str,&#xa;        audit_file_path: str,&#xa;        audit_host_ip: str,&#xa;        audit_host_uid: str,&#xa;        context_vars_container: ContextVarsContainer,&#xa;        timezone: pytz.timezone,&#xa;        rotation: str = &quot;10 MB&quot;,&#xa;    ):&#xa;        self.handlers: dict = {0: &quot;standard-loguru&quot;}&#xa;        self.log_lvl: int = log_lvl&#xa;        self.log_file_path: str = log_file_path&#xa;        self.metric_file_path: str = metric_file_path&#xa;        self.audit_file_path: str = audit_file_path&#xa;        self.audit_host_ip: str = audit_host_ip&#xa;        self.audit_host_uid: str = audit_host_uid&#xa;        self.rotation: str = rotation&#xa;&#xa;&#xa;        full_message_print = log_lvl == DEBUG&#xa;        _patcher = LoguruPatcher(context_vars_container, timezone, full_message_print)&#xa;        self._init_async_logger(_patcher)&#xa;&#xa;&#xa;    def add_handler(self, *args, handler_name=&quot;&quot;, **kwargs):&#xa;        self.handlers[self.logger.add(*args, **kwargs)] = handler_name&#xa;&#xa;&#xa;    def list_logger_handlers(self):&#xa;        print(f&quot;Displaying active handlers ({len(self.handlers)}):&quot;)&#xa;        for handler_id, handler_name in self.handlers.items():&#xa;            print(f&quot; -- Handler id: {handler_id} | Status: ready | Handler name: {handler_name}&quot;)&#xa;&#xa;&#xa;    def _init_async_logger(self, loguru_patcher: LoguruPatcher):&#xa;        print(&quot;Setting up logging handlers&quot;)&#xa;        self.list_logger_handlers()&#xa;        self.delete_handler_by_id(0)&#xa;        self.logger = LoggerWrapper(audit_uid_pod=self.audit_host_uid, audit_ip_address=self.audit_host_ip).patch(&#xa;            loguru_patcher.patching&#xa;        )&#xa;&#xa;&#xa;        self.add_handler(&#xa;            handler_name=&quot;log-file-handler&quot;,&#xa;            sink=self.log_file_path,&#xa;            serialize=False,&#xa;            format=&quot;{extra[serialized]}&quot;,&#xa;            rotation=self.rotation,&#xa;            retention=0,&#xa;            compression=None,&#xa;            level=self.log_lvl,&#xa;            enqueue=True,&#xa;            filter=lambda record: record[&quot;extra&quot;].get(&quot;target&quot;) == &quot;log&quot;,&#xa;        )&#xa;&#xa;&#xa;        self.add_handler(&#xa;            handler_name=&quot;metric-file-handler&quot;,&#xa;            sink=self.metric_file_path,&#xa;            serialize=False,&#xa;            format=&quot;{extra[serialized]}&quot;,&#xa;            rotation=self.rotation,&#xa;            retention=0,&#xa;            compression=None,&#xa;            enqueue=True,&#xa;            filter=lambda record: record[&quot;extra&quot;].get(&quot;target&quot;) == &quot;metric&quot;,&#xa;        )&#xa;&#xa;&#xa;        self.add_handler(&#xa;            handler_name=&quot;audit-file-handler&quot;,&#xa;            sink=self.audit_file_path,&#xa;            serialize=False,&#xa;            format=&quot;{extra[serialized]}&quot;,&#xa;            rotation=self.rotation,&#xa;            retention=0,&#xa;            compression=None,&#xa;            enqueue=True,&#xa;            filter=lambda record: record[&quot;extra&quot;].get(&quot;target&quot;) == &quot;audit-event&quot;,&#xa;        )&#xa;&#xa;&#xa;        self.add_handler(&#xa;            handler_name=&quot;log-console-handler&quot;,&#xa;            sink=sys.stdout,&#xa;            level=self.log_lvl,&#xa;            format=loguru_patcher.format_stdout_record,&#xa;            filter=lambda record: record[&quot;extra&quot;].get(&quot;target&quot;) == &quot;log&quot;,&#xa;        )&#xa;&#xa;&#xa;        self.list_logger_handlers()&#xa;        print(&quot;---------------- All handlers are ready, now loguru is in charge ----------------&quot;)&#xa;&#xa;&#xa;    def delete_handler_by_id(self, handler_id):&#xa;        handler_name = self.handlers.get(handler_id, &quot;&lt;None&gt;&quot;)&#xa;        try:&#xa;            loguru_logger.remove(handler_id)&#xa;            self.handlers.pop(handler_id)&#xa;            print(f&quot;Successfully removed {handler_name} logger with id {handler_id}&quot;)&#xa;        except ValueError:&#xa;            print(f&quot;Failed to remove {handler_name} logger with id {handler_id}&quot;)&#xa;&#xa;&#xa;    def remove_logger_handlers(self):&#xa;        self.logger.info(&quot;Destroying logging handlers, loguru says goodbye&quot;)&#xa;&#xa;&#xa;        for handler_id in list(self.handlers):&#xa;            self.delete_handler_by_id(handler_id)&#xa;&#xa;&#xa;        self.list_logger_handlers()&#xa;&#xa;&#xa;&#xa;&#xa;__all__ = [&quot;LoggerConfigurator&quot;]" link="import json&#xa;import sys&#xa;from dataclasses import asdict&#xa;from logging import DEBUG&#xa;from time import time&#xa;&#xa;&#xa;import pytz&#xa;from loguru import logger as loguru_logger&#xa;&#xa;&#xa;from aigw_service.base import Singleton&#xa;&#xa;&#xa;from .context_vars import ContextVarsContainer&#xa;from .models import ContextLog, Event, EventParam, Log, Metric, dataclass_as_json_str&#xa;from .utils import mask_sensitive_data&#xa;&#xa;&#xa;&#xa;&#xa;class LoggerWrapper:&#xa;    def __init__(self, audit_uid_pod, audit_ip_address):&#xa;        self.logger = None&#xa;        self.audit_uid_pod = audit_uid_pod&#xa;        self.audit_ip_address = audit_ip_address&#xa;&#xa;&#xa;    def patch(self, *args, **kwargs):&#xa;        self.logger = loguru_logger.patch(*args, **kwargs)&#xa;        return self&#xa;&#xa;&#xa;    def metric(self, metric_name, metric_value):&#xa;        self.logger.info(&#xa;            &quot;&lt;metric&gt;&quot;,&#xa;            metric_name=metric_name,&#xa;            metric_value=metric_value,&#xa;            target=&quot;metric&quot;,&#xa;        )&#xa;&#xa;&#xa;    def audit(self, event_name, event_params):&#xa;        self.logger.info(&#xa;            &quot;&lt;audit-event&gt;&quot;,&#xa;            audit_event_name=event_name,&#xa;            audit_uid_pod=self.audit_uid_pod,&#xa;            audit_ip_address=self.audit_ip_address,&#xa;            audit_params=event_params,&#xa;            target=&quot;audit-event&quot;,&#xa;        )&#xa;&#xa;&#xa;    def __getattr__(self, name):&#xa;        return getattr(self.logger, name)&#xa;&#xa;&#xa;&#xa;&#xa;class LoguruPatcher:&#xa;    def __init__(self, context_vars_container: ContextVarsContainer, timezone: pytz.timezone, full_message_print: bool):&#xa;        self.context_vars_container = context_vars_container&#xa;        self.timezone: pytz.timezone = timezone&#xa;        self.full_message_print: bool = full_message_print&#xa;&#xa;&#xa;    @staticmethod&#xa;    def format_stdout_record(record) -&gt; str:&#xa;        base_record = &quot;&lt;level&gt;{level: &lt;7}&lt;/level&gt; | &lt;green&gt;{time:YYYY-MM-DD HH:mm:ss.SSS}&lt;/green&gt; | &quot;&#xa;        base_msg = &quot;{name} | {message}\n&quot;&#xa;&#xa;&#xa;        if record[&quot;extra&quot;].get(&quot;rqUId&quot;) is not None:&#xa;            return base_record + &quot;{extra[rqUId]} | &quot; + base_msg&#xa;        return base_record + base_msg&#xa;&#xa;&#xa;    def patching(self, record: dict):&#xa;        _context_log: ContextLog = self.context_vars_container.context_vars&#xa;        _time_iso = record[&quot;time&quot;].replace(tzinfo=self.timezone).isoformat()&#xa;        _target = record[&quot;extra&quot;].get(&quot;target&quot;)&#xa;&#xa;&#xa;        if _target == &quot;metric&quot;:&#xa;            _log_record = Metric(&#xa;                rqUId=_context_log.rqUId,&#xa;                metric_name=record[&quot;extra&quot;].get(&quot;metric_name&quot;, &quot;unknown&quot;),&#xa;                metric_value=record[&quot;extra&quot;].get(&quot;metric_value&quot;, 1),&#xa;            )&#xa;        elif _target == &quot;audit-event&quot;:&#xa;            _log_record = Event(&#xa;                name=record[&quot;extra&quot;].get(&quot;audit_event_name&quot;, None),&#xa;                createdAt=int(time()*1000),&#xa;                params=[&#xa;                    EventParam(name=&quot;uid-pod&quot;, value=record[&quot;extra&quot;].get(&quot;audit_uid_pod&quot;)),&#xa;                    EventParam(name=&quot;ip-address&quot;, value=record[&quot;extra&quot;].get(&quot;audit_ip_address&quot;)),&#xa;                    EventParam(name=&quot;request-Id&quot;, value=_context_log.rqUId),&#xa;                    EventParam(name=&quot;request-Time&quot;, value=_context_log.rqTime),&#xa;                    EventParam(name=&quot;params&quot;, value=record[&quot;extra&quot;].get(&quot;audit_params&quot;)),&#xa;                ],&#xa;            )&#xa;        else:&#xa;            record[&quot;extra&quot;].update({&quot;target&quot;: &quot;log&quot;})&#xa;            args = record[&quot;extra&quot;].get(&quot;args&quot;, None)&#xa;            if args:&#xa;                message = args.get(&quot;message&quot;, {})&#xa;                if self.full_message_print:&#xa;                    print(json.dumps(message, indent=4, ensure_ascii=False))&#xa;                message = mask_sensitive_data(&#xa;                    message, message_type=record[&quot;extra&quot;].get(&quot;message_type&quot;), path=record[&quot;extra&quot;].get(&quot;path&quot;)&#xa;                )&#xa;                args.update({&quot;message&quot;: str(message), &quot;headers&quot;: str(args[&quot;headers&quot;])})&#xa;&#xa;&#xa;            _log_record = Log(&#xa;                levelName=str(record[&quot;level&quot;].name),&#xa;                asctime=_time_iso,&#xa;                moduleName=str(record[&quot;name&quot;]),&#xa;                funcName=str(record[&quot;function&quot;]),&#xa;                message=str(record[&quot;message&quot;]),&#xa;                stackTrace=record[&quot;extra&quot;].get(&quot;exception&quot;, None),&#xa;                rqUId=_context_log.rqUId,&#xa;                rqTime=_context_log.rqTime,&#xa;                systemId=_context_log.systemId,&#xa;                gwSessionId=_context_log.gwSessionId,&#xa;                args=args,&#xa;            )&#xa;&#xa;&#xa;        record[&quot;extra&quot;][&quot;serialized&quot;] = dataclass_as_json_str(_log_record)&#xa;        record[&quot;extra&quot;].update(asdict(_context_log))&#xa;&#xa;&#xa;&#xa;&#xa;class LoggerConfigurator(metaclass=Singleton):&#xa;    # pylint: disable=R0902&#xa;    @property&#xa;    def async_logger(self):&#xa;        return self.logger&#xa;&#xa;&#xa;    def __init__(&#xa;        # pylint: disable=R0917&#xa;        self,&#xa;        log_lvl: int,&#xa;        log_file_path: str,&#xa;        metric_file_path: str,&#xa;        audit_file_path: str,&#xa;        audit_host_ip: str,&#xa;        audit_host_uid: str,&#xa;        context_vars_container: ContextVarsContainer,&#xa;        timezone: pytz.timezone,&#xa;        rotation: str = &quot;10 MB&quot;,&#xa;    ):&#xa;        self.handlers: dict = {0: &quot;standard-loguru&quot;}&#xa;        self.log_lvl: int = log_lvl&#xa;        self.log_file_path: str = log_file_path&#xa;        self.metric_file_path: str = metric_file_path&#xa;        self.audit_file_path: str = audit_file_path&#xa;        self.audit_host_ip: str = audit_host_ip&#xa;        self.audit_host_uid: str = audit_host_uid&#xa;        self.rotation: str = rotation&#xa;&#xa;&#xa;        full_message_print = log_lvl == DEBUG&#xa;        _patcher = LoguruPatcher(context_vars_container, timezone, full_message_print)&#xa;        self._init_async_logger(_patcher)&#xa;&#xa;&#xa;    def add_handler(self, *args, handler_name=&quot;&quot;, **kwargs):&#xa;        self.handlers[self.logger.add(*args, **kwargs)] = handler_name&#xa;&#xa;&#xa;    def list_logger_handlers(self):&#xa;        print(f&quot;Displaying active handlers ({len(self.handlers)}):&quot;)&#xa;        for handler_id, handler_name in self.handlers.items():&#xa;            print(f&quot; -- Handler id: {handler_id} | Status: ready | Handler name: {handler_name}&quot;)&#xa;&#xa;&#xa;    def _init_async_logger(self, loguru_patcher: LoguruPatcher):&#xa;        print(&quot;Setting up logging handlers&quot;)&#xa;        self.list_logger_handlers()&#xa;        self.delete_handler_by_id(0)&#xa;        self.logger = LoggerWrapper(audit_uid_pod=self.audit_host_uid, audit_ip_address=self.audit_host_ip).patch(&#xa;            loguru_patcher.patching&#xa;        )&#xa;&#xa;&#xa;        self.add_handler(&#xa;            handler_name=&quot;log-file-handler&quot;,&#xa;            sink=self.log_file_path,&#xa;            serialize=False,&#xa;            format=&quot;{extra[serialized]}&quot;,&#xa;            rotation=self.rotation,&#xa;            retention=0,&#xa;            compression=None,&#xa;            level=self.log_lvl,&#xa;            enqueue=True,&#xa;            filter=lambda record: record[&quot;extra&quot;].get(&quot;target&quot;) == &quot;log&quot;,&#xa;        )&#xa;&#xa;&#xa;        self.add_handler(&#xa;            handler_name=&quot;metric-file-handler&quot;,&#xa;            sink=self.metric_file_path,&#xa;            serialize=False,&#xa;            format=&quot;{extra[serialized]}&quot;,&#xa;            rotation=self.rotation,&#xa;            retention=0,&#xa;            compression=None,&#xa;            enqueue=True,&#xa;            filter=lambda record: record[&quot;extra&quot;].get(&quot;target&quot;) == &quot;metric&quot;,&#xa;        )&#xa;&#xa;&#xa;        self.add_handler(&#xa;            handler_name=&quot;audit-file-handler&quot;,&#xa;            sink=self.audit_file_path,&#xa;            serialize=False,&#xa;            format=&quot;{extra[serialized]}&quot;,&#xa;            rotation=self.rotation,&#xa;            retention=0,&#xa;            compression=None,&#xa;            enqueue=True,&#xa;            filter=lambda record: record[&quot;extra&quot;].get(&quot;target&quot;) == &quot;audit-event&quot;,&#xa;        )&#xa;&#xa;&#xa;        self.add_handler(&#xa;            handler_name=&quot;log-console-handler&quot;,&#xa;            sink=sys.stdout,&#xa;            level=self.log_lvl,&#xa;            format=loguru_patcher.format_stdout_record,&#xa;            filter=lambda record: record[&quot;extra&quot;].get(&quot;target&quot;) == &quot;log&quot;,&#xa;        )&#xa;&#xa;&#xa;        self.list_logger_handlers()&#xa;        print(&quot;---------------- All handlers are ready, now loguru is in charge ----------------&quot;)&#xa;&#xa;&#xa;    def delete_handler_by_id(self, handler_id):&#xa;        handler_name = self.handlers.get(handler_id, &quot;&lt;None&gt;&quot;)&#xa;        try:&#xa;            loguru_logger.remove(handler_id)&#xa;            self.handlers.pop(handler_id)&#xa;            print(f&quot;Successfully removed {handler_name} logger with id {handler_id}&quot;)&#xa;        except ValueError:&#xa;            print(f&quot;Failed to remove {handler_name} logger with id {handler_id}&quot;)&#xa;&#xa;&#xa;    def remove_logger_handlers(self):&#xa;        self.logger.info(&quot;Destroying logging handlers, loguru says goodbye&quot;)&#xa;&#xa;&#xa;        for handler_id in list(self.handlers):&#xa;            self.delete_handler_by_id(handler_id)&#xa;&#xa;&#xa;        self.list_logger_handlers()&#xa;&#xa;&#xa;&#xa;&#xa;__all__ = [&quot;LoggerConfigurator&quot;]" id="SYt-TXJ_Hw24SwqiqHZK-24">
          <mxCell style="text;whiteSpace=wrap;" vertex="1" parent="1">
            <mxGeometry x="1580" y="80" width="560" height="3910" as="geometry" />
          </mxCell>
        </UserObject>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
