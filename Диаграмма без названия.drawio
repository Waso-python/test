<mxfile host="app.diagrams.net" agent="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36 SberBrowser/28.0.0.0" version="27.2.0">
  <diagram name="Страница — 1" id="WULPb32uHRo-QUS4CWuH">
    <mxGraphModel dx="1372" dy="743" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="3300" pageHeight="4681" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <mxCell id="SYt-TXJ_Hw24SwqiqHZK-9" value="from pydantic import BaseModel, Field&#xa;&#xa;&#xa;&#xa;&#xa;class HealthResponse(BaseModel):&#xa;    &quot;&quot;&quot;Ответ для ручки /health&quot;&quot;&quot;&#xa;&#xa;&#xa;    status: str = Field(default=&quot;running&quot;, description=&quot;Service health check&quot;, max_length=7)&#xa;&#xa;&#xa;    class Config:&#xa;        json_schema_extra = {&quot;example&quot;: {&quot;status&quot;: &quot;running&quot;}}&#xa;&#xa;&#xa;&#xa;&#xa;class InfoResponse(BaseModel):&#xa;    &quot;&quot;&quot;Ответ для ручки /info&quot;&quot;&quot;&#xa;&#xa;&#xa;    name: str = Field(description=&quot;Service name&quot;, max_length=50)&#xa;    description: str = Field(description=&quot;Service description&quot;, max_length=200)&#xa;    type: str = Field(default=&quot;REST API&quot;, description=&quot;Service type&quot;, max_length=20)&#xa;    version: str = Field(description=&quot;Service version&quot;, max_length=20, pattern=r&quot;^\d+.\d+.\d+&quot;)&#xa;&#xa;&#xa;    class Config:&#xa;        json_schema_extra = {&#xa;            &quot;example&quot;: {&#xa;                &quot;name&quot;: &quot;rest-template&quot;,&#xa;                &quot;description&quot;: &#39;Python &quot;Ai gateway&quot; template for developing REST microservices&#39;,&#xa;                &quot;type&quot;: &quot;REST API&quot;,&#xa;                &quot;version&quot;: &quot;0.1.0&quot;,&#xa;            }&#xa;        }&#xa;&#xa;&#xa;&#xa;&#xa;class RateResponse(BaseModel):&#xa;    rating_result: str = Field(description=&quot;Rating that was recorded&quot;, max_length=50)" style="text;whiteSpace=wrap;" vertex="1" parent="1">
          <mxGeometry x="40" y="40" width="520" height="640" as="geometry" />
        </mxCell>
        <UserObject label="&quot;&quot;&quot;&#xa;!!!!!! НЕ РЕДАКТИРОВАТЬ !!!!!!&#xa;&quot;&quot;&quot;&#xa;&#xa;&#xa;from importlib.metadata import distribution&#xa;&#xa;&#xa;from fastapi import APIRouter, status&#xa;&#xa;&#xa;from . import schemas&#xa;&#xa;&#xa;router = APIRouter()&#xa;&#xa;&#xa;&#xa;&#xa;@router.get(&#xa;    &quot;/health&quot;,&#xa;    status_code=status.HTTP_200_OK,&#xa;    response_model=schemas.HealthResponse,&#xa;)&#xa;async def health():&#xa;    return {&#xa;        &quot;health_status&quot;: &quot;running&quot;,&#xa;    }&#xa;&#xa;&#xa;&#xa;&#xa;@router.get(&#xa;    &quot;/info&quot;,&#xa;    status_code=status.HTTP_200_OK,&#xa;    response_model=schemas.InfoResponse,&#xa;)&#xa;async def info():&#xa;    dist = distribution(&quot;aigw-rest-service&quot;)&#xa;&#xa;&#xa;    return schemas.InfoResponse(&#xa;        name=str(dist.metadata[&quot;Name&quot;]),&#xa;        description=str(dist.metadata[&quot;Summary&quot;]),&#xa;        type=&quot;REST API&quot;,&#xa;        version=str(dist.version),&#xa;    )" link="&quot;&quot;&quot;&#xa;!!!!!! НЕ РЕДАКТИРОВАТЬ !!!!!!&#xa;&quot;&quot;&quot;&#xa;&#xa;&#xa;from importlib.metadata import distribution&#xa;&#xa;&#xa;from fastapi import APIRouter, status&#xa;&#xa;&#xa;from . import schemas&#xa;&#xa;&#xa;router = APIRouter()&#xa;&#xa;&#xa;&#xa;&#xa;@router.get(&#xa;    &quot;/health&quot;,&#xa;    status_code=status.HTTP_200_OK,&#xa;    response_model=schemas.HealthResponse,&#xa;)&#xa;async def health():&#xa;    return {&#xa;        &quot;health_status&quot;: &quot;running&quot;,&#xa;    }&#xa;&#xa;&#xa;&#xa;&#xa;@router.get(&#xa;    &quot;/info&quot;,&#xa;    status_code=status.HTTP_200_OK,&#xa;    response_model=schemas.InfoResponse,&#xa;)&#xa;async def info():&#xa;    dist = distribution(&quot;aigw-rest-service&quot;)&#xa;&#xa;&#xa;    return schemas.InfoResponse(&#xa;        name=str(dist.metadata[&quot;Name&quot;]),&#xa;        description=str(dist.metadata[&quot;Summary&quot;]),&#xa;        type=&quot;REST API&quot;,&#xa;        version=str(dist.version),&#xa;    )" id="SYt-TXJ_Hw24SwqiqHZK-10">
          <mxCell style="text;whiteSpace=wrap;" vertex="1" parent="1">
            <mxGeometry x="650" y="70" width="290" height="700" as="geometry" />
          </mxCell>
        </UserObject>
        <UserObject label="import json&#xa;import time&#xa;from datetime import datetime&#xa;&#xa;&#xa;from fastapi import Request, status&#xa;from starlette.concurrency import iterate_in_threadpool&#xa;&#xa;&#xa;from aigw_service.context import APP_CTX&#xa;&#xa;&#xa;NON_LOGGED_ENDPOINTS = (&#xa;    &quot;/like&quot;,&#xa;    &quot;/dislike&quot;,&#xa;    &quot;/health&quot;,&#xa;    &quot;/info&quot;,&#xa;    &quot;/openapi.json&quot;,&#xa;    &quot;/docs&quot;,&#xa;)&#xa;&#xa;&#xa;HEADERS_WHITE_LIST_TO_LOG = (&#xa;    &quot;Request-Id&quot;,&#xa;    &quot;Request-Time&quot;,&#xa;    &quot;System-Id&quot;,&#xa;    &quot;GateWay-Session-Id&quot;,&#xa;    &quot;Client-Id&quot;,&#xa;)&#xa;&#xa;&#xa;&#xa;&#xa;def _get_decoded_body(raw_body: bytes, message_type: str, logger):&#xa;    decoded_body = {}&#xa;    try:&#xa;        decoded_body = json.loads(raw_body.decode())&#xa;    except (json.JSONDecodeError, UnicodeDecodeError):&#xa;        logger.warning(f&quot;{message_type} body is not json&quot;)&#xa;    return decoded_body&#xa;&#xa;&#xa;&#xa;&#xa;async def log_requests(request: Request, call_next):&#xa;    start_time = time.time()&#xa;    logger = APP_CTX.get_logger()&#xa;    request_path = request.url.path&#xa;&#xa;&#xa;    # Достаем заголовки запроса&#xa;    allowed_headers_to_log = ((k, request.headers.get(k)) for k in HEADERS_WHITE_LIST_TO_LOG)&#xa;    headers_to_log = {header_name: header_value for header_name, header_value in allowed_headers_to_log if header_value}&#xa;&#xa;&#xa;    # Устанавливаем контекстные переменные&#xa;    APP_CTX.get_context_vars_container().set_context_vars(&#xa;        request_id=headers_to_log.get(&quot;Request-Id&quot;, &quot;&quot;),&#xa;        request_time=headers_to_log.get(&quot;Request-Time&quot;, &quot;&quot;),&#xa;        system_id=headers_to_log.get(&quot;System-Id&quot;, &quot;&quot;),&#xa;        gw_session_id=headers_to_log.get(&quot;GateWay-Session-Id&quot;, &quot;&quot;),&#xa;    )&#xa;&#xa;&#xa;    # Логируем получение запроса&#xa;    if request_path in NON_LOGGED_ENDPOINTS:  # Не следует логировать эти эндпоинты&#xa;        response = await call_next(request)&#xa;        logger.debug(f&quot;Processed request for {request_path} with code {response.status_code}&quot;)&#xa;    # Проверка на наличие заголовка Request-Id в запросе&#xa;    elif headers_to_log.get(&quot;Request-Id&quot;, None):&#xa;        # Получаем тело запроса&#xa;        raw_request_body = await request.body()&#xa;        request_body_decoded = _get_decoded_body(raw_request_body, &quot;request&quot;, logger)&#xa;        # Логируем, кидаем событие в аудит, кидаем метрику о количестве запросов&#xa;        logger.info(&#xa;            f&quot;Incoming {request.method}-request for {request_path}&quot;,&#xa;            args={&#xa;                &quot;headers&quot;: headers_to_log,&#xa;                &quot;message&quot;: request_body_decoded,&#xa;            },&#xa;            message_type=&quot;request&quot;,&#xa;            path=request_path,&#xa;        )&#xa;        client_id = headers_to_log.get(&quot;Client-Id&quot;, None)&#xa;        if client_id:&#xa;            logger.metric(&#xa;                metric_name=f&quot;aigw_service_user_{client_id}&quot;,&#xa;                metric_value=1,&#xa;            )&#xa;        logger.metric(&#xa;            metric_name=&quot;aigw_service_requests_total&quot;,&#xa;            metric_value=1,&#xa;        )&#xa;        logger.audit(&#xa;            event_name=&quot;BusinessRequestReceived&quot;,&#xa;            event_params=json.dumps(&#xa;                request_body_decoded,&#xa;                ensure_ascii=False,&#xa;            ),&#xa;        )&#xa;&#xa;&#xa;        response = await call_next(request)&#xa;&#xa;&#xa;        # Тело response - это итератор, по которому нельзя пройти повторно.&#xa;        # Один из вариантов решения - это собрать итератор повторно, что и представлено ниже&#xa;        response_body = [chunk async for chunk in response.body_iterator]&#xa;        response.body_iterator = iterate_in_threadpool(iter(response_body))&#xa;&#xa;&#xa;        # Добавляем заголовки ответа&#xa;        headers_to_log[&quot;Response-Time&quot;] = datetime.now(APP_CTX.get_pytz_timezone()).isoformat()&#xa;        for header in headers_to_log:&#xa;            response.headers[header] = headers_to_log[header]&#xa;&#xa;&#xa;        # Логируем ответ приложения и кидаем метрику количества ответов&#xa;        response_body_extracted = response_body[0] if len(response_body) &gt; 0 else b&quot;&quot;&#xa;        decoded_response_body = _get_decoded_body(response_body_extracted, &quot;response&quot;, logger)&#xa;        logger.info(&#xa;            &quot;Outgoing response to client system&quot;,&#xa;            args={&#xa;                &quot;headers&quot;: headers_to_log,&#xa;                &quot;message&quot;: decoded_response_body,&#xa;            },&#xa;            message_type=&quot;response&quot;,&#xa;            path=request_path,&#xa;        )&#xa;        logger.metric(&#xa;            metric_name=&quot;aigw_service_responses_total&quot;,&#xa;            metric_value=1,&#xa;        )&#xa;        logger.audit(&#xa;            event_name=&quot;BusinessRequestFinished&quot;,&#xa;            event_params=json.dumps(&#xa;                decoded_response_body,&#xa;                ensure_ascii=False,&#xa;            ),&#xa;        )&#xa;&#xa;&#xa;        # Логируем время обработки запроса и кидаем метрику скорости ответа&#xa;        processing_time_ms = int(round(time.time() - start_time, 3) * 1000)&#xa;        logger.info(f&quot;Request processing time for {request_path}: {processing_time_ms} ms&quot;)&#xa;        logger.metric(&#xa;            metric_name=&quot;aigw_service_process_duration_ms&quot;,&#xa;            metric_value=processing_time_ms,&#xa;        )&#xa;&#xa;&#xa;        # Кидаем метрику статуса обработки запроса&#xa;        if response.status_code &lt; status.HTTP_400_BAD_REQUEST:&#xa;            logger.metric(&#xa;                metric_name=&quot;aigw_service_request_status_success_total&quot;,&#xa;                metric_value=1,&#xa;            )&#xa;        else:&#xa;            logger.metric(&#xa;                metric_name=&quot;aigw_service_request_status_failure_total&quot;,&#xa;                metric_value=1,&#xa;            )&#xa;    else:&#xa;        # Логируем получение запроса без request-id и обрабатываем его&#xa;        logger.info(f&quot;Incoming {request.method}-request with no id for {request_path}&quot;)&#xa;        response = await call_next(request)&#xa;        logger.info(f&quot;Request with no id for {request_path} processing time: {time.time() - start_time: .3f} s&quot;)&#xa;&#xa;&#xa;    return response&#xa;&#xa;&#xa;&#xa;&#xa;__all__ = [&#xa;    &quot;log_requests&quot;,&#xa;]" link="import json&#xa;import time&#xa;from datetime import datetime&#xa;&#xa;&#xa;from fastapi import Request, status&#xa;from starlette.concurrency import iterate_in_threadpool&#xa;&#xa;&#xa;from aigw_service.context import APP_CTX&#xa;&#xa;&#xa;NON_LOGGED_ENDPOINTS = (&#xa;    &quot;/like&quot;,&#xa;    &quot;/dislike&quot;,&#xa;    &quot;/health&quot;,&#xa;    &quot;/info&quot;,&#xa;    &quot;/openapi.json&quot;,&#xa;    &quot;/docs&quot;,&#xa;)&#xa;&#xa;&#xa;HEADERS_WHITE_LIST_TO_LOG = (&#xa;    &quot;Request-Id&quot;,&#xa;    &quot;Request-Time&quot;,&#xa;    &quot;System-Id&quot;,&#xa;    &quot;GateWay-Session-Id&quot;,&#xa;    &quot;Client-Id&quot;,&#xa;)&#xa;&#xa;&#xa;&#xa;&#xa;def _get_decoded_body(raw_body: bytes, message_type: str, logger):&#xa;    decoded_body = {}&#xa;    try:&#xa;        decoded_body = json.loads(raw_body.decode())&#xa;    except (json.JSONDecodeError, UnicodeDecodeError):&#xa;        logger.warning(f&quot;{message_type} body is not json&quot;)&#xa;    return decoded_body&#xa;&#xa;&#xa;&#xa;&#xa;async def log_requests(request: Request, call_next):&#xa;    start_time = time.time()&#xa;    logger = APP_CTX.get_logger()&#xa;    request_path = request.url.path&#xa;&#xa;&#xa;    # Достаем заголовки запроса&#xa;    allowed_headers_to_log = ((k, request.headers.get(k)) for k in HEADERS_WHITE_LIST_TO_LOG)&#xa;    headers_to_log = {header_name: header_value for header_name, header_value in allowed_headers_to_log if header_value}&#xa;&#xa;&#xa;    # Устанавливаем контекстные переменные&#xa;    APP_CTX.get_context_vars_container().set_context_vars(&#xa;        request_id=headers_to_log.get(&quot;Request-Id&quot;, &quot;&quot;),&#xa;        request_time=headers_to_log.get(&quot;Request-Time&quot;, &quot;&quot;),&#xa;        system_id=headers_to_log.get(&quot;System-Id&quot;, &quot;&quot;),&#xa;        gw_session_id=headers_to_log.get(&quot;GateWay-Session-Id&quot;, &quot;&quot;),&#xa;    )&#xa;&#xa;&#xa;    # Логируем получение запроса&#xa;    if request_path in NON_LOGGED_ENDPOINTS:  # Не следует логировать эти эндпоинты&#xa;        response = await call_next(request)&#xa;        logger.debug(f&quot;Processed request for {request_path} with code {response.status_code}&quot;)&#xa;    # Проверка на наличие заголовка Request-Id в запросе&#xa;    elif headers_to_log.get(&quot;Request-Id&quot;, None):&#xa;        # Получаем тело запроса&#xa;        raw_request_body = await request.body()&#xa;        request_body_decoded = _get_decoded_body(raw_request_body, &quot;request&quot;, logger)&#xa;        # Логируем, кидаем событие в аудит, кидаем метрику о количестве запросов&#xa;        logger.info(&#xa;            f&quot;Incoming {request.method}-request for {request_path}&quot;,&#xa;            args={&#xa;                &quot;headers&quot;: headers_to_log,&#xa;                &quot;message&quot;: request_body_decoded,&#xa;            },&#xa;            message_type=&quot;request&quot;,&#xa;            path=request_path,&#xa;        )&#xa;        client_id = headers_to_log.get(&quot;Client-Id&quot;, None)&#xa;        if client_id:&#xa;            logger.metric(&#xa;                metric_name=f&quot;aigw_service_user_{client_id}&quot;,&#xa;                metric_value=1,&#xa;            )&#xa;        logger.metric(&#xa;            metric_name=&quot;aigw_service_requests_total&quot;,&#xa;            metric_value=1,&#xa;        )&#xa;        logger.audit(&#xa;            event_name=&quot;BusinessRequestReceived&quot;,&#xa;            event_params=json.dumps(&#xa;                request_body_decoded,&#xa;                ensure_ascii=False,&#xa;            ),&#xa;        )&#xa;&#xa;&#xa;        response = await call_next(request)&#xa;&#xa;&#xa;        # Тело response - это итератор, по которому нельзя пройти повторно.&#xa;        # Один из вариантов решения - это собрать итератор повторно, что и представлено ниже&#xa;        response_body = [chunk async for chunk in response.body_iterator]&#xa;        response.body_iterator = iterate_in_threadpool(iter(response_body))&#xa;&#xa;&#xa;        # Добавляем заголовки ответа&#xa;        headers_to_log[&quot;Response-Time&quot;] = datetime.now(APP_CTX.get_pytz_timezone()).isoformat()&#xa;        for header in headers_to_log:&#xa;            response.headers[header] = headers_to_log[header]&#xa;&#xa;&#xa;        # Логируем ответ приложения и кидаем метрику количества ответов&#xa;        response_body_extracted = response_body[0] if len(response_body) &gt; 0 else b&quot;&quot;&#xa;        decoded_response_body = _get_decoded_body(response_body_extracted, &quot;response&quot;, logger)&#xa;        logger.info(&#xa;            &quot;Outgoing response to client system&quot;,&#xa;            args={&#xa;                &quot;headers&quot;: headers_to_log,&#xa;                &quot;message&quot;: decoded_response_body,&#xa;            },&#xa;            message_type=&quot;response&quot;,&#xa;            path=request_path,&#xa;        )&#xa;        logger.metric(&#xa;            metric_name=&quot;aigw_service_responses_total&quot;,&#xa;            metric_value=1,&#xa;        )&#xa;        logger.audit(&#xa;            event_name=&quot;BusinessRequestFinished&quot;,&#xa;            event_params=json.dumps(&#xa;                decoded_response_body,&#xa;                ensure_ascii=False,&#xa;            ),&#xa;        )&#xa;&#xa;&#xa;        # Логируем время обработки запроса и кидаем метрику скорости ответа&#xa;        processing_time_ms = int(round(time.time() - start_time, 3) * 1000)&#xa;        logger.info(f&quot;Request processing time for {request_path}: {processing_time_ms} ms&quot;)&#xa;        logger.metric(&#xa;            metric_name=&quot;aigw_service_process_duration_ms&quot;,&#xa;            metric_value=processing_time_ms,&#xa;        )&#xa;&#xa;&#xa;        # Кидаем метрику статуса обработки запроса&#xa;        if response.status_code &lt; status.HTTP_400_BAD_REQUEST:&#xa;            logger.metric(&#xa;                metric_name=&quot;aigw_service_request_status_success_total&quot;,&#xa;                metric_value=1,&#xa;            )&#xa;        else:&#xa;            logger.metric(&#xa;                metric_name=&quot;aigw_service_request_status_failure_total&quot;,&#xa;                metric_value=1,&#xa;            )&#xa;    else:&#xa;        # Логируем получение запроса без request-id и обрабатываем его&#xa;        logger.info(f&quot;Incoming {request.method}-request with no id for {request_path}&quot;)&#xa;        response = await call_next(request)&#xa;        logger.info(f&quot;Request with no id for {request_path} processing time: {time.time() - start_time: .3f} s&quot;)&#xa;&#xa;&#xa;    return response&#xa;&#xa;&#xa;&#xa;&#xa;__all__ = [&#xa;    &quot;log_requests&quot;,&#xa;]" id="SYt-TXJ_Hw24SwqiqHZK-11">
          <mxCell style="text;whiteSpace=wrap;" vertex="1" parent="1">
            <mxGeometry x="1090" y="180" width="560" height="2660" as="geometry" />
          </mxCell>
        </UserObject>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
