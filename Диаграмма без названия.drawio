<mxfile host="app.diagrams.net" agent="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36 SberBrowser/28.0.0.0" version="27.2.0">
  <diagram name="Страница — 1" id="WULPb32uHRo-QUS4CWuH">
    <mxGraphModel dx="1372" dy="743" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="3300" pageHeight="4681" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <UserObject label="import os&#xa;from logging import DEBUG, INFO&#xa;&#xa;&#xa;from dotenv import load_dotenv&#xa;from pydantic import Field, field_validator, model_validator&#xa;from pydantic_settings import BaseSettings&#xa;&#xa;&#xa;load_dotenv()&#xa;&#xa;&#xa;&#xa;&#xa;class BaseAppSettings(BaseSettings):&#xa;    &quot;&quot;&quot;&#xa;    Базовый класс для настроек.&#xa;    &quot;&quot;&quot;&#xa;&#xa;&#xa;    local: bool = Field(validation_alias=&quot;LOCAL&quot;, default=False)&#xa;    debug: bool = Field(validation_alias=&quot;DEBUG&quot;, default=False)&#xa;&#xa;&#xa;    @property&#xa;    def protocol(self) -&gt; str:&#xa;        return &quot;https&quot; if self.local else &quot;http&quot;&#xa;&#xa;&#xa;&#xa;&#xa;class AppSettings(BaseAppSettings):&#xa;    &quot;&quot;&quot;&#xa;    Настройки приложения.&#xa;    &quot;&quot;&quot;&#xa;&#xa;&#xa;    app_host: str = Field(validation_alias=&quot;APP_HOST&quot;, default=&quot;0.0.0.0&quot;)&#xa;    app_port: int = Field(validation_alias=&quot;APP_PORT&quot;, default=8080)&#xa;    kube_net_name: str = Field(validation_alias=&quot;PROJECT_NAME&quot;, default=&quot;AIGATEWAY&quot;)&#xa;    timezone: str = Field(validation_alias=&quot;TIMEZONE&quot;, default=&quot;Europe/Moscow&quot;)&#xa;&#xa;&#xa;&#xa;&#xa;class LogSettings(BaseAppSettings):&#xa;    &quot;&quot;&quot;&#xa;    Настройки логирования.&#xa;    &quot;&quot;&quot;&#xa;&#xa;&#xa;    private_log_file_path: str = Field(validation_alias=&quot;LOG_PATH&quot;, default=os.getcwd())&#xa;    private_log_file_name: str = Field(validation_alias=&quot;LOG_FILE_NAME&quot;, default=&quot;app.log&quot;)&#xa;    log_rotation: str = Field(validation_alias=&quot;LOG_ROTATION&quot;, default=&quot;10 MB&quot;)&#xa;    private_metric_file_path: str = Field(validation_alias=&quot;METRIC_PATH&quot;, default=os.getcwd())&#xa;    private_metric_file_name: str = Field(validation_alias=&quot;METRIC_FILE_NAME&quot;, default=&quot;app-metric.log&quot;)&#xa;    private_audit_file_path: str = Field(validation_alias=&quot;AUDIT_LOG_PATH&quot;, default=os.getcwd())&#xa;    private_audit_file_name: str = Field(validation_alias=&quot;AUDIT_LOG_FILE_NAME&quot;, default=&quot;events.log&quot;)&#xa;    audit_host_ip: str = Field(validation_alias=&quot;HOST_IP&quot;, default=&quot;127.0.0.1&quot;)&#xa;    audit_host_uid: str = Field(validation_alias=&quot;HOST_UID&quot;, default=&quot;63bd6cbe-170b-49bf-a65c-3ce967398ccd&quot;)&#xa;&#xa;&#xa;    @field_validator(&#xa;        &quot;private_log_file_path&quot;,&#xa;        &quot;private_metric_file_path&quot;,&#xa;        &quot;private_audit_file_path&quot;,&#xa;    )&#xa;    @classmethod&#xa;    def validate_path(cls, value):&#xa;        if not os.path.exists(value):&#xa;            raise ValueError(f&quot;Path does not exist: {value}&quot;)&#xa;        if not os.path.isdir(value):&#xa;            raise ValueError(f&quot;Path is not a directory: {value}&quot;)&#xa;        return value&#xa;&#xa;&#xa;    @staticmethod&#xa;    def get_file_abs_path(path_name: str, file_name: str) -&gt; str:&#xa;        return os.path.join(path_name.strip(), file_name.lstrip(&quot;/&quot;).strip())&#xa;&#xa;&#xa;    @property&#xa;    def log_file_abs_path(self) -&gt; str:&#xa;        return self.get_file_abs_path(self.private_log_file_path, self.private_log_file_name)&#xa;&#xa;&#xa;    @property&#xa;    def metric_file_abs_path(self) -&gt; str:&#xa;        return self.get_file_abs_path(self.private_metric_file_path, self.private_metric_file_name)&#xa;&#xa;&#xa;    @property&#xa;    def audit_file_abs_path(self) -&gt; str:&#xa;        return self.get_file_abs_path(self.private_audit_file_path, self.private_audit_file_name)&#xa;&#xa;&#xa;    @property&#xa;    def log_lvl(self) -&gt; int:&#xa;        return DEBUG if self.debug else INFO&#xa;&#xa;&#xa;&#xa;&#xa;class GigachatSettings(BaseAppSettings):&#xa;    &quot;&quot;&quot;&#xa;    Настройки GigaChat.&#xa;    &quot;&quot;&quot;&#xa;&#xa;&#xa;    gigachat_host: str = Field(validation_alias=&quot;GIGACHAT_HOST&quot;)&#xa;    gigachat_port: str = Field(validation_alias=&quot;GIGACHAT_PORT&quot;)&#xa;    gigachat_endpoint: str = Field(validation_alias=&quot;GIGACHAT_ENDPOINT&quot;, default=&quot;/v1&quot;)&#xa;    gigachat_tls_cert_filepath: None | str = Field(validation_alias=&quot;GIGACHAT_TLS_CERT_FILEPATH&quot;, default=&quot;&quot;)&#xa;    gigachat_key_filepath: None | str = Field(validation_alias=&quot;GIGACHAT_KEY_FILEPATH&quot;, default=&quot;&quot;)&#xa;    gigachat_ca_bundle_filepath: None | str = Field(validation_alias=&quot;GIGACHAT_CA_BUNDLE_FILEPATH&quot;, default=&quot;&quot;)&#xa;&#xa;&#xa;    @model_validator(mode=&quot;after&quot;)&#xa;    def validate_file_path(self):&#xa;        for gigachat_cert_file in [&#xa;            self.gigachat_tls_cert_filepath,&#xa;            self.gigachat_ca_bundle_filepath,&#xa;            self.gigachat_key_filepath,&#xa;        ]:&#xa;            if self.local:&#xa;                if not os.path.exists(gigachat_cert_file):&#xa;                    raise ValueError(f&quot;Path does not exist: {gigachat_cert_file}&quot;)&#xa;                if os.path.isdir(gigachat_cert_file):&#xa;                    raise ValueError(f&quot;Path is a directory: {gigachat_cert_file}&quot;)&#xa;        return self&#xa;&#xa;&#xa;    @property&#xa;    def gigachat_base_url(self) -&gt; str:&#xa;        return f&quot;{self.protocol}://{self.gigachat_host}:{self.gigachat_port}{self.gigachat_endpoint}&quot;&#xa;&#xa;&#xa;    @property&#xa;    def gigachat_certs(self) -&gt; dict:&#xa;        certs = {}&#xa;        if self.local:&#xa;            certs = {&#xa;                &quot;ca_bundle_file&quot;: self.gigachat_ca_bundle_filepath,&#xa;                &quot;cert_file&quot;: self.gigachat_tls_cert_filepath,&#xa;                &quot;key_file&quot;: self.gigachat_key_filepath,&#xa;            }&#xa;        return certs&#xa;&#xa;&#xa;    @property&#xa;    def base_params(self) -&gt; dict:&#xa;        return {&#xa;            &quot;base_url&quot;: self.gigachat_base_url,&#xa;            &quot;verify_ssl_certs&quot;: False,&#xa;            **self.gigachat_certs,&#xa;        }&#xa;&#xa;&#xa;&#xa;&#xa;class Secrets:&#xa;    &quot;&quot;&quot;&#xa;    Класс, агрегирующий все настройки приложения.&#xa;    &quot;&quot;&quot;&#xa;&#xa;&#xa;    app: AppSettings = AppSettings()&#xa;    log: LogSettings = LogSettings()&#xa;    gigachat: GigachatSettings = GigachatSettings()&#xa;&#xa;&#xa;&#xa;&#xa;APP_CONFIG = Secrets()&#xa;&#xa;&#xa;__all__ = [&#xa;    &quot;Secrets&quot;,&#xa;    &quot;APP_CONFIG&quot;,&#xa;]" link="import os&#xa;from logging import DEBUG, INFO&#xa;&#xa;&#xa;from dotenv import load_dotenv&#xa;from pydantic import Field, field_validator, model_validator&#xa;from pydantic_settings import BaseSettings&#xa;&#xa;&#xa;load_dotenv()&#xa;&#xa;&#xa;&#xa;&#xa;class BaseAppSettings(BaseSettings):&#xa;    &quot;&quot;&quot;&#xa;    Базовый класс для настроек.&#xa;    &quot;&quot;&quot;&#xa;&#xa;&#xa;    local: bool = Field(validation_alias=&quot;LOCAL&quot;, default=False)&#xa;    debug: bool = Field(validation_alias=&quot;DEBUG&quot;, default=False)&#xa;&#xa;&#xa;    @property&#xa;    def protocol(self) -&gt; str:&#xa;        return &quot;https&quot; if self.local else &quot;http&quot;&#xa;&#xa;&#xa;&#xa;&#xa;class AppSettings(BaseAppSettings):&#xa;    &quot;&quot;&quot;&#xa;    Настройки приложения.&#xa;    &quot;&quot;&quot;&#xa;&#xa;&#xa;    app_host: str = Field(validation_alias=&quot;APP_HOST&quot;, default=&quot;0.0.0.0&quot;)&#xa;    app_port: int = Field(validation_alias=&quot;APP_PORT&quot;, default=8080)&#xa;    kube_net_name: str = Field(validation_alias=&quot;PROJECT_NAME&quot;, default=&quot;AIGATEWAY&quot;)&#xa;    timezone: str = Field(validation_alias=&quot;TIMEZONE&quot;, default=&quot;Europe/Moscow&quot;)&#xa;&#xa;&#xa;&#xa;&#xa;class LogSettings(BaseAppSettings):&#xa;    &quot;&quot;&quot;&#xa;    Настройки логирования.&#xa;    &quot;&quot;&quot;&#xa;&#xa;&#xa;    private_log_file_path: str = Field(validation_alias=&quot;LOG_PATH&quot;, default=os.getcwd())&#xa;    private_log_file_name: str = Field(validation_alias=&quot;LOG_FILE_NAME&quot;, default=&quot;app.log&quot;)&#xa;    log_rotation: str = Field(validation_alias=&quot;LOG_ROTATION&quot;, default=&quot;10 MB&quot;)&#xa;    private_metric_file_path: str = Field(validation_alias=&quot;METRIC_PATH&quot;, default=os.getcwd())&#xa;    private_metric_file_name: str = Field(validation_alias=&quot;METRIC_FILE_NAME&quot;, default=&quot;app-metric.log&quot;)&#xa;    private_audit_file_path: str = Field(validation_alias=&quot;AUDIT_LOG_PATH&quot;, default=os.getcwd())&#xa;    private_audit_file_name: str = Field(validation_alias=&quot;AUDIT_LOG_FILE_NAME&quot;, default=&quot;events.log&quot;)&#xa;    audit_host_ip: str = Field(validation_alias=&quot;HOST_IP&quot;, default=&quot;127.0.0.1&quot;)&#xa;    audit_host_uid: str = Field(validation_alias=&quot;HOST_UID&quot;, default=&quot;63bd6cbe-170b-49bf-a65c-3ce967398ccd&quot;)&#xa;&#xa;&#xa;    @field_validator(&#xa;        &quot;private_log_file_path&quot;,&#xa;        &quot;private_metric_file_path&quot;,&#xa;        &quot;private_audit_file_path&quot;,&#xa;    )&#xa;    @classmethod&#xa;    def validate_path(cls, value):&#xa;        if not os.path.exists(value):&#xa;            raise ValueError(f&quot;Path does not exist: {value}&quot;)&#xa;        if not os.path.isdir(value):&#xa;            raise ValueError(f&quot;Path is not a directory: {value}&quot;)&#xa;        return value&#xa;&#xa;&#xa;    @staticmethod&#xa;    def get_file_abs_path(path_name: str, file_name: str) -&gt; str:&#xa;        return os.path.join(path_name.strip(), file_name.lstrip(&quot;/&quot;).strip())&#xa;&#xa;&#xa;    @property&#xa;    def log_file_abs_path(self) -&gt; str:&#xa;        return self.get_file_abs_path(self.private_log_file_path, self.private_log_file_name)&#xa;&#xa;&#xa;    @property&#xa;    def metric_file_abs_path(self) -&gt; str:&#xa;        return self.get_file_abs_path(self.private_metric_file_path, self.private_metric_file_name)&#xa;&#xa;&#xa;    @property&#xa;    def audit_file_abs_path(self) -&gt; str:&#xa;        return self.get_file_abs_path(self.private_audit_file_path, self.private_audit_file_name)&#xa;&#xa;&#xa;    @property&#xa;    def log_lvl(self) -&gt; int:&#xa;        return DEBUG if self.debug else INFO&#xa;&#xa;&#xa;&#xa;&#xa;class GigachatSettings(BaseAppSettings):&#xa;    &quot;&quot;&quot;&#xa;    Настройки GigaChat.&#xa;    &quot;&quot;&quot;&#xa;&#xa;&#xa;    gigachat_host: str = Field(validation_alias=&quot;GIGACHAT_HOST&quot;)&#xa;    gigachat_port: str = Field(validation_alias=&quot;GIGACHAT_PORT&quot;)&#xa;    gigachat_endpoint: str = Field(validation_alias=&quot;GIGACHAT_ENDPOINT&quot;, default=&quot;/v1&quot;)&#xa;    gigachat_tls_cert_filepath: None | str = Field(validation_alias=&quot;GIGACHAT_TLS_CERT_FILEPATH&quot;, default=&quot;&quot;)&#xa;    gigachat_key_filepath: None | str = Field(validation_alias=&quot;GIGACHAT_KEY_FILEPATH&quot;, default=&quot;&quot;)&#xa;    gigachat_ca_bundle_filepath: None | str = Field(validation_alias=&quot;GIGACHAT_CA_BUNDLE_FILEPATH&quot;, default=&quot;&quot;)&#xa;&#xa;&#xa;    @model_validator(mode=&quot;after&quot;)&#xa;    def validate_file_path(self):&#xa;        for gigachat_cert_file in [&#xa;            self.gigachat_tls_cert_filepath,&#xa;            self.gigachat_ca_bundle_filepath,&#xa;            self.gigachat_key_filepath,&#xa;        ]:&#xa;            if self.local:&#xa;                if not os.path.exists(gigachat_cert_file):&#xa;                    raise ValueError(f&quot;Path does not exist: {gigachat_cert_file}&quot;)&#xa;                if os.path.isdir(gigachat_cert_file):&#xa;                    raise ValueError(f&quot;Path is a directory: {gigachat_cert_file}&quot;)&#xa;        return self&#xa;&#xa;&#xa;    @property&#xa;    def gigachat_base_url(self) -&gt; str:&#xa;        return f&quot;{self.protocol}://{self.gigachat_host}:{self.gigachat_port}{self.gigachat_endpoint}&quot;&#xa;&#xa;&#xa;    @property&#xa;    def gigachat_certs(self) -&gt; dict:&#xa;        certs = {}&#xa;        if self.local:&#xa;            certs = {&#xa;                &quot;ca_bundle_file&quot;: self.gigachat_ca_bundle_filepath,&#xa;                &quot;cert_file&quot;: self.gigachat_tls_cert_filepath,&#xa;                &quot;key_file&quot;: self.gigachat_key_filepath,&#xa;            }&#xa;        return certs&#xa;&#xa;&#xa;    @property&#xa;    def base_params(self) -&gt; dict:&#xa;        return {&#xa;            &quot;base_url&quot;: self.gigachat_base_url,&#xa;            &quot;verify_ssl_certs&quot;: False,&#xa;            **self.gigachat_certs,&#xa;        }&#xa;&#xa;&#xa;&#xa;&#xa;class Secrets:&#xa;    &quot;&quot;&quot;&#xa;    Класс, агрегирующий все настройки приложения.&#xa;    &quot;&quot;&quot;&#xa;&#xa;&#xa;    app: AppSettings = AppSettings()&#xa;    log: LogSettings = LogSettings()&#xa;    gigachat: GigachatSettings = GigachatSettings()&#xa;&#xa;&#xa;&#xa;&#xa;APP_CONFIG = Secrets()&#xa;&#xa;&#xa;__all__ = [&#xa;    &quot;Secrets&quot;,&#xa;    &quot;APP_CONFIG&quot;,&#xa;]" id="SYt-TXJ_Hw24SwqiqHZK-6">
          <mxCell style="text;whiteSpace=wrap;" vertex="1" parent="1">
            <mxGeometry x="50" y="40" width="560" height="2700" as="geometry" />
          </mxCell>
        </UserObject>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
